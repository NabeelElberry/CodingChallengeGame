[
  {
    "title": "Two Sum",
    "source": "https://leetcode.com/problems/two-sum/",
    "description": "<p>Given an array of integers <code>nums</code>&nbsp;and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p>\n\n<p>You may assume that each input would have <strong><em>exactly</em> one solution</strong>, and you may not use the <em>same</em> element twice.</p>\n\n<p>You can return the answer in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,7,11,15], target = 9\n<strong>Output:</strong> [0,1]\n<strong>Explanation:</strong> Because nums[0] + nums[1] == 9, we return [0, 1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,4], target = 6\n<strong>Output:</strong> [1,2]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,3], target = 6\n<strong>Output:</strong> [0,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n\t<li><strong>Only one valid answer exists.</strong></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow-up:&nbsp;</strong>Can you come up with an algorithm that is less than <code>O(n<sup>2</sup>)</code><font face=\"monospace\">&nbsp;</font>time complexity?",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "[2,7,11,15], 9",
        "expected_output": "[0,1]"
      },
      {
        "input": "[3,2,4], 6",
        "expected_output": "[1,2]"
      },
      {
        "input": "[3,3], 6",
        "expected_output": "[0,1]"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[49,61,74,96,29,88,53,-34,-48], 184",
        "expected_output": "[3,5]"
      },
      {
        "input": "[62,15,-95,26,-65,12,-86,-5,-40,-64,-91,-14,20,-36,83], -60",
        "expected_output": "[3,6]"
      },
      {
        "input": "[-12,-75,90,56,-15,-55,-51,-27,61,24,-9,-58], -85",
        "expected_output": "[7,11]"
      },
      {
        "input": "[-87,21,-26,13,-29,-53,-87,11], -140",
        "expected_output": "[0,5]"
      },
      {
        "input": "[-65,6,58,-29], -7",
        "expected_output": "[0,2]"
      },
      {
        "input": "[-87,54], -33",
        "expected_output": "[0,1]"
      },
      {
        "input": "[-97,-10,89], -8",
        "expected_output": "[0,2]"
      },
      {
        "input": "[30,57,-82,-8,92,99,82,-76], 74",
        "expected_output": "[3,6]"
      },
      {
        "input": "[75,-74,40], 1",
        "expected_output": "[0,1]"
      },
      {
        "input": "[-67,-35,76,71,-85,91,-55,-42,66,-28,1,89], 56",
        "expected_output": "[1,5]"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        ",
      "java": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return sorted(result) == sorted(eval(expected))",
      "java": "int[] resultArr = (int[]) result;\n    int[] expectedArr = (int[]) expected;\n    \n    if (resultArr.length != expectedArr.length) {\n        return false;\n    }\n    \n    // Sort both arrays to make order-independent comparison\n    int[] sortedResult = resultArr.clone();\n    int[] sortedExpected = expectedArr.clone();\n    Arrays.sort(sortedResult);\n    Arrays.sort(sortedExpected);\n    \n    return Arrays.equals(sortedResult, sortedExpected);",
      "cpp": "std::vector<int> result_vector;\n    for (const auto& value : result) {\n        result_vector.push_back(value.asInt());\n    }\n\n    std::vector<int> expected_vector;\n    for (const auto& value : expected) {\n        expected_vector.push_back(value.asInt());\n    }\n\n    std::sort(result_vector.begin(), result_vector.end());\n    std::sort(expected_vector.begin(), expected_vector.end());\n\n    return result_vector == expected_vector;"
    },
    "explanation": "https://www.youtube.com/watch?v=KLlXCFG5TnA&pp=ygUQTmVldENvZGUgVHdvIFN1bQ%3D%3D",
    "method_name": "twoSum"
  },
  {
    "title": "Palindrome Number",
    "source": "https://leetcode.com/problems/palindrome-number/",
    "description": "Determine whether an integer `x` is a palindrome. An integer is a palindrome when it reads the same backward as forward.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "121",
        "expected_output": "true"
      },
      {
        "input": "-121",
        "expected_output": "false"
      },
      {
        "input": "10",
        "expected_output": "false"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "0",
        "expected_output": "true"
      },
      {
        "input": "1234321",
        "expected_output": "true"
      },
      {
        "input": "-1",
        "expected_output": "false"
      },
      {
        "input": "1000",
        "expected_output": "false"
      },
      {
        "input": "12321",
        "expected_output": "true"
      },
      {
        "input": "100001",
        "expected_output": "true"
      },
      {
        "input": "2147483647",
        "expected_output": "false"
      },
      {
        "input": "-2147483648",
        "expected_output": "false"
      },
      {
        "input": "11",
        "expected_output": "true"
      },
      {
        "input": "1000021",
        "expected_output": "false"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        ",
      "java": "class Solution {\n    public boolean isPalindrome(int x) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == eval(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asBool() == expected.asBool();"
    },
    "explanation": "https://www.youtube.com/watch?v=yubRKwixN-U&pp=ygUaTmVldENvZGUgUGFsaW5kcm9tZSBOdW1iZXI%3D",
    "method_name": "isPalindrome"
  },
  {
    "title": "Longest Common Prefix",
    "source": "https://leetcode.com/problems/longest-common-prefix/",
    "description": "Write a function to find the longest common prefix string among an array of strings. If there is no common prefix, return an empty string.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "['flower','flow','flight']",
        "expected_output": "'fl'"
      },
      {
        "input": "['dog','racecar','car']",
        "expected_output": "''"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "['interspecies','interstellar','interstate']",
        "expected_output": "'inters'"
      },
      {
        "input": "['throne','throne']",
        "expected_output": "'throne'"
      },
      {
        "input": "['']",
        "expected_output": "''"
      },
      {
        "input": "['a']",
        "expected_output": "'a'"
      },
      {
        "input": "['','b']",
        "expected_output": "''"
      },
      {
        "input": "['prefix','prefix','prefix']",
        "expected_output": "'prefix'"
      },
      {
        "input": "['abc','def','ghi']",
        "expected_output": "''"
      },
      {
        "input": "['flower','flower','flower','flower']",
        "expected_output": "'flower'"
      },
      {
        "input": "['x','xy','xyz']",
        "expected_output": "'x'"
      },
      {
        "input": "['ab','a']",
        "expected_output": "'a'"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        ",
      "java": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == eval(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asString() == expected.asString();"
    },
    "explanation": "https://www.youtube.com/watch?v=0sWShKIJoo4&pp=ygUeTmVldENvZGUgTG9uZ2VzdCBDb21tb24gUHJlZml4",
    "method_name": "longestCommonPrefix"
  },
  {
    "title": "Valid Parentheses",
    "source": "https://leetcode.com/problems/valid-parentheses/",
    "description": "Given a string `s` containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\nAn input string is valid if:\n1. Open brackets are closed by the same type of brackets.\n2. Open brackets are closed in the correct order.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "'()'",
        "expected_output": "true"
      },
      {
        "input": "'()[]{}'",
        "expected_output": "true"
      },
      {
        "input": "'(]'",
        "expected_output": "false"
      },
      {
        "input": "'([])'",
        "expected_output": "true"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "'{[]}'",
        "expected_output": "true"
      },
      {
        "input": "'((()))'",
        "expected_output": "true"
      },
      {
        "input": "'(()[]{})'",
        "expected_output": "true"
      },
      {
        "input": "'}{}'",
        "expected_output": "false"
      },
      {
        "input": "''",
        "expected_output": "true"
      },
      {
        "input": "'((())'",
        "expected_output": "false"
      },
      {
        "input": "'())'",
        "expected_output": "false"
      },
      {
        "input": "'([)]'",
        "expected_output": "false"
      },
      {
        "input": "'{{{}}}'",
        "expected_output": "true"
      },
      {
        "input": "'[({})]'",
        "expected_output": "true"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def isValid(self, s: str) -> bool:\n        ",
      "java": "class Solution {\n    public boolean isValid(String s) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    bool isValid(string s) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == eval(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asBool() == expected.asBool();"
    },
    "explanation": "https://www.youtube.com/watch?v=WTzjTskDFMg&pp=ygUaTmVldENvZGUgVmFsaWQgUGFyZW50aGVzZXM%3D",
    "method_name": "isValid"
  },
  {
    "title": "Find the Index of the First Occurrence in a String",
    "source": "https://leetcode.com/problems/implement-strstr/",
    "description": "Given two strings `haystack` and `needle`, return the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "'sadbutsad', 'sad'",
        "expected_output": "0"
      },
      {
        "input": "'leetcode', 'leeto'",
        "expected_output": "-1"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "'hello', 'll'",
        "expected_output": "2"
      },
      {
        "input": "'aaaaa', 'bba'",
        "expected_output": "-1"
      },
      {
        "input": "'', ''",
        "expected_output": "0"
      },
      {
        "input": "'a', 'a'",
        "expected_output": "0"
      },
      {
        "input": "'mississippi', 'issi'",
        "expected_output": "1"
      },
      {
        "input": "'aaaaaa', 'aa'",
        "expected_output": "0"
      },
      {
        "input": "'abc', 'c'",
        "expected_output": "2"
      },
      {
        "input": "'hello, world', 'world'",
        "expected_output": "6"
      },
      {
        "input": "'abcabcd', 'abcd'",
        "expected_output": "3"
      },
      {
        "input": "'testing', ''",
        "expected_output": "0"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        ",
      "java": "class Solution {\n    public int strStr(String haystack, String needle) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == int(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asInt() == expected.asInt();"
    },
    "explanation": "https://www.youtube.com/watch?v=Gjkhm1gYIMw&pp=ygU7TmVldENvZGUgRmluZCB0aGUgSW5kZXggb2YgdGhlIEZpcnN0IE9jY3VycmVuY2UgaW4gYSBTdHJpbmc%3D",
    "method_name": "strStr"
  },
  {
    "title": "Search Insert Position",
    "source": "https://leetcode.com/problems/search-insert-position/",
    "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "[1,3,5,6], 5",
        "expected_output": "2"
      },
      {
        "input": "[1,3,5,6], 2",
        "expected_output": "1"
      },
      {
        "input": "[1,3,5,6], 7",
        "expected_output": "4"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[1], 0",
        "expected_output": "0"
      },
      {
        "input": "[1], 2",
        "expected_output": "1"
      },
      {
        "input": "[1,3,5,6,8,10], 9",
        "expected_output": "5"
      },
      {
        "input": "[1,4,6,7,8,9], 6",
        "expected_output": "2"
      },
      {
        "input": "[-5,-3,0,1,3], -4",
        "expected_output": "1"
      },
      {
        "input": "[-3,-1,0,2], 1",
        "expected_output": "3"
      },
      {
        "input": "[1,2,3,4,5], 5",
        "expected_output": "4"
      },
      {
        "input": "[2,4,6,8], 1",
        "expected_output": "0"
      },
      {
        "input": "[1,3,5,7], 4",
        "expected_output": "2"
      },
      {
        "input": "[1,3,5,7,9], 8",
        "expected_output": "4"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        ",
      "java": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == int(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asInt() == std::stoi(expected.asString());"
    },
    "explanation": "https://www.youtube.com/watch?v=K-RYzDZkzCI&pp=ygUfTmVldENvZGUgU2VhcmNoIEluc2VydCBQb3NpdGlvbg%3D%3D",
    "method_name": "searchInsert"
  },
  {
    "title": "Length of Last Word",
    "source": "https://leetcode.com/problems/length-of-last-word/",
    "description": "Given a string `s` consisting of words and spaces, return the length of the last word in the string. A word is a maximal substring consisting of non-space characters only.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "\"Hello, World\"",
        "expected_output": "5"
      },
      {
        "input": "\", fly, me, to, the, moon, \"",
        "expected_output": "4"
      },
      {
        "input": "\"luffy, is, still, joyboy\"",
        "expected_output": "6"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "\"a\"",
        "expected_output": "1"
      },
      {
        "input": "\"hello, \"",
        "expected_output": "5"
      },
      {
        "input": "\", space\"",
        "expected_output": "5"
      },
      {
        "input": "\"multiple, words, here\"",
        "expected_output": "4"
      },
      {
        "input": "\"oneword\"",
        "expected_output": "7"
      },
      {
        "input": "\", spaces, between, words, \"",
        "expected_output": "5"
      },
      {
        "input": "\"trailing, space, \"",
        "expected_output": "5"
      },
      {
        "input": "\", leading, space\"",
        "expected_output": "5"
      },
      {
        "input": "\"multiple, spaces, between\"",
        "expected_output": "7"
      },
      {
        "input": "\"z\"",
        "expected_output": "1"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        ",
      "java": "class Solution {\n    public int lengthOfLastWord(String s) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int lengthOfLastWord(string s) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == int(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asInt() == expected.asInt();"
    },
    "explanation": "https://www.youtube.com/watch?v=KT9rltZTybQ&pp=ygUcTmVldENvZGUgTGVuZ3RoIG9mIExhc3QgV29yZA%3D%3D",
    "method_name": "lengthOfLastWord"
  },
  {
    "title": "Plus One",
    "source": "https://leetcode.com/problems/plus-one/",
    "description": "Solve the problem titled \"Plus One\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "[1,2,3]",
        "expected_output": "[1,2,4]"
      },
      {
        "input": "[4,3,2,1]",
        "expected_output": "[4,3,2,2]"
      },
      {
        "input": "[9]",
        "expected_output": "[1,0]"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[0]",
        "expected_output": "[1]"
      },
      {
        "input": "[9,9]",
        "expected_output": "[1,0,0]"
      },
      {
        "input": "[1,0,0]",
        "expected_output": "[1,0,1]"
      },
      {
        "input": "[1,9,9]",
        "expected_output": "[2,0,0]"
      },
      {
        "input": "[9,8,9]",
        "expected_output": "[9,9,0]"
      },
      {
        "input": "[1,2,3,4]",
        "expected_output": "[1,2,3,5]"
      },
      {
        "input": "[9,9,9,9]",
        "expected_output": "[1,0,0,0,0]"
      },
      {
        "input": "[5,0,9]",
        "expected_output": "[5,1,0]"
      },
      {
        "input": "[1]",
        "expected_output": "[2]"
      },
      {
        "input": "[4,9,9,9]",
        "expected_output": "[5,0,0,0]"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        ",
      "java": "class Solution {\n    public int[] plusOne(int[] digits) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == eval(expected)",
      "java": "return Arrays.equals((int[]) result, (int []) expected);",
      "cpp": "return result == expected;"
    },
    "explanation": "https://www.youtube.com/watch?v=jIaA8boiG1s&pp=ygURTmVldENvZGUgUGx1cyBPbmU%3D",
    "method_name": "plusOne"
  },
  {
    "title": "Add Binary",
    "source": "https://leetcode.com/problems/add-binary/",
    "description": "Solve the problem titled \"Add Binary\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "\"11\", \"1\"",
        "expected_output": "'100'"
      },
      {
        "input": "\"1010\", \"1011\"",
        "expected_output": "'10101'"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "\"0\", \"0\"",
        "expected_output": "'0'"
      },
      {
        "input": "\"1\", \"1\"",
        "expected_output": "'10'"
      },
      {
        "input": "\"111\", \"111\"",
        "expected_output": "'1110'"
      },
      {
        "input": "\"1111\", \"1111\"",
        "expected_output": "'11110'"
      },
      {
        "input": "\"1010\", \"0101\"",
        "expected_output": "'1111'"
      },
      {
        "input": "\"100\", \"110\"",
        "expected_output": "'1010'"
      },
      {
        "input": "\"11\", \"11\"",
        "expected_output": "'110'"
      },
      {
        "input": "\"1\", \"111\"",
        "expected_output": "'1000'"
      },
      {
        "input": "\"1000\", \"1100\"",
        "expected_output": "'10100'"
      },
      {
        "input": "\"1111\", \"1\"",
        "expected_output": "'10000'"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        ",
      "java": "class Solution {\n    public String addBinary(String a, String b) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    string addBinary(string a, string b) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == eval(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asString() == expected.asString();"
    },
    "explanation": "https://www.youtube.com/watch?v=keuWJ47xG8g&pp=ygUTTmVldENvZGUgQWRkIEJpbmFyeQ%3D%3D",
    "method_name": "addBinary"
  },
  {
    "title": "Climbing Stairs",
    "source": "https://leetcode.com/problems/climbing-stairs/",
    "description": "Solve the problem titled \"Climbing Stairs\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "2",
        "expected_output": "2"
      },
      {
        "input": "3",
        "expected_output": "3"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "1",
        "expected_output": "1"
      },
      {
        "input": "4",
        "expected_output": "5"
      },
      {
        "input": "5",
        "expected_output": "8"
      },
      {
        "input": "6",
        "expected_output": "13"
      },
      {
        "input": "7",
        "expected_output": "21"
      },
      {
        "input": "8",
        "expected_output": "34"
      },
      {
        "input": "9",
        "expected_output": "55"
      },
      {
        "input": "10",
        "expected_output": "89"
      },
      {
        "input": "20",
        "expected_output": "10946"
      },
      {
        "input": "30",
        "expected_output": "1346269"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        ",
      "java": "class Solution {\n    public int climbStairs(int n) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int climbStairs(int n) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == int(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asInt() == std::stoi(expected.asString());"
    },
    "explanation": "https://www.youtube.com/watch?v=Y0lT9Fck7qI&pp=ygUYTmVldENvZGUgQ2xpbWJpbmcgU3RhaXJz",
    "method_name": "climbStairs"
  },
  {
    "title": "Best Time to Buy and Sell Stock",
    "source": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
    "description": "Solve the problem titled \"Best Time to Buy and Sell Stock\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "[7,1,5,3,6,4]",
        "expected_output": "5"
      },
      {
        "input": "[7,6,4,3,1]",
        "expected_output": "0"
      },
      {
        "input": "[2,4,1,7]",
        "expected_output": "6"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[1]",
        "expected_output": "0"
      },
      {
        "input": "[1,2]",
        "expected_output": "1"
      },
      {
        "input": "[2,1]",
        "expected_output": "0"
      },
      {
        "input": "[3,3,3]",
        "expected_output": "0"
      },
      {
        "input": "[1,2,4,2,5,7,2,4,9,0]",
        "expected_output": "8"
      },
      {
        "input": "[2,1,2,1,0,1,2]",
        "expected_output": "2"
      },
      {
        "input": "[9,8,7,6,5,4,3,2,1]",
        "expected_output": "0"
      },
      {
        "input": "[1,4,1,4,3,1]",
        "expected_output": "3"
      },
      {
        "input": "[10000,9999,9998,9997]",
        "expected_output": "0"
      },
      {
        "input": "[0,2,0,2,0,2]",
        "expected_output": "2"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        ",
      "java": "class Solution {\n    public int maxProfit(int[] prices) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result) == expected",
      "java": "return result.equals(expected);",
      "cpp": "return std::to_string(result.asInt()) == expected.asString();"
    },
    "explanation": "https://www.youtube.com/watch?v=1pkOgXD63yU&pp=ygUoTmVldENvZGUgQmVzdCBUaW1lIHRvIEJ1eSBhbmQgU2VsbCBTdG9jaw%3D%3D",
    "method_name": "maxProfit"
  },
  {
    "title": "Valid Palindrome",
    "source": "https://leetcode.com/problems/valid-palindrome/",
    "description": "<p>A phrase is a <strong>palindrome</strong> if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.</p>\n\n<p>Given a string <code>s</code>, return <code>true</code><em> if it is a <strong>palindrome</strong>, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;A man, a plan, a canal: Panama&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> &quot;amanaplanacanalpanama&quot; is a palindrome.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;race a car&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> &quot;raceacar&quot; is not a palindrome.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot; &quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> s is an empty string &quot;&quot; after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists only of printable ASCII characters.</li>\n</ul>\n",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "\"A, man,, a, plan,, a, canal:, Panama\"",
        "expected_output": "true"
      },
      {
        "input": "\"race, a, car\"",
        "expected_output": "false"
      },
      {
        "input": "\", \"",
        "expected_output": "true"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "\"\"",
        "expected_output": "true"
      },
      {
        "input": "\".,\"",
        "expected_output": "true"
      },
      {
        "input": "\"0P\"",
        "expected_output": "false"
      },
      {
        "input": "\"abc123cba\"",
        "expected_output": "false"
      },
      {
        "input": "\"Race, a, Car\"",
        "expected_output": "false"
      },
      {
        "input": "\"!@#$%^&*()\"",
        "expected_output": "true"
      },
      {
        "input": "\"12321\"",
        "expected_output": "true"
      },
      {
        "input": "\"Never, odd, or, even\"",
        "expected_output": "true"
      },
      {
        "input": "\"a\"",
        "expected_output": "true"
      },
      {
        "input": "\".,a,.\"",
        "expected_output": "true"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        ",
      "java": "class Solution {\n    public boolean isPalindrome(String s) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result).lower() == expected.lower()",
      "java": "return result.equals(expected);",
      "cpp": "return result.asBool() == expected.asBool();"
    },
    "explanation": "https://www.youtube.com/watch?v=jJXJ16kPFWg&pp=ygUZTmVldENvZGUgVmFsaWQgUGFsaW5kcm9tZQ%3D%3D",
    "method_name": "isPalindrome"
  },
  {
    "title": "Excel Sheet Column Title",
    "source": "https://leetcode.com/problems/excel-sheet-column-title/",
    "description": "Solve the problem titled \"Excel Sheet Column Title\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "1",
        "expected_output": "'A'"
      },
      {
        "input": "28",
        "expected_output": "'AB'"
      },
      {
        "input": "701",
        "expected_output": "'ZY'"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "26",
        "expected_output": "'Z'"
      },
      {
        "input": "27",
        "expected_output": "'AA'"
      },
      {
        "input": "52",
        "expected_output": "'AZ'"
      },
      {
        "input": "676",
        "expected_output": "'YZ'"
      },
      {
        "input": "702",
        "expected_output": "'ZZ'"
      },
      {
        "input": "1000",
        "expected_output": "'ALL'"
      },
      {
        "input": "2147483647",
        "expected_output": "'FXSHRXW'"
      },
      {
        "input": "18278",
        "expected_output": "'ZZZ'"
      },
      {
        "input": "17576",
        "expected_output": "'YYZ'"
      },
      {
        "input": "18277",
        "expected_output": "'ZZY'"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        ",
      "java": "class Solution {\n    public String convertToTitle(int columnNumber) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    string convertToTitle(int columnNumber) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == eval(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asString() == expected.asString();"
    },
    "explanation": "https://www.youtube.com/watch?v=X_vJDpCCuoA&pp=ygUhTmVldENvZGUgRXhjZWwgU2hlZXQgQ29sdW1uIFRpdGxl",
    "method_name": "convertToTitle"
  },
  {
    "title": "Happy Number",
    "source": "https://leetcode.com/problems/happy-number/",
    "description": "Solve the problem titled \"Happy Number\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "19",
        "expected_output": "true"
      },
      {
        "input": "2",
        "expected_output": "false"
      },
      {
        "input": "7",
        "expected_output": "true"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "1",
        "expected_output": "true"
      },
      {
        "input": "4",
        "expected_output": "false"
      },
      {
        "input": "16",
        "expected_output": "false"
      },
      {
        "input": "89",
        "expected_output": "false"
      },
      {
        "input": "100",
        "expected_output": "true"
      },
      {
        "input": "1111111",
        "expected_output": "true"
      },
      {
        "input": "999999",
        "expected_output": "false"
      },
      {
        "input": "123",
        "expected_output": "false"
      },
      {
        "input": "3",
        "expected_output": "false"
      },
      {
        "input": "44",
        "expected_output": "true"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def isHappy(self, n: int) -> bool:\n        ",
      "java": "class Solution {\n    public boolean isHappy(int n) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    bool isHappy(int n) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result).lower() == expected.lower()",
      "java": "return result.equals(expected);",
      "cpp": "return result.asBool() == expected.asBool();"
    },
    "explanation": "https://www.youtube.com/watch?v=ljz85bxOYJ0&pp=ygUVTmVldENvZGUgSGFwcHkgTnVtYmVy",
    "method_name": "isHappy"
  },
  {
    "title": "Isomorphic Strings",
    "source": "https://leetcode.com/problems/isomorphic-strings/",
    "description": "Solve the problem titled \"Isomorphic Strings\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "\"egg\", \"add\"",
        "expected_output": "true"
      },
      {
        "input": "\"foo\", \"bar\"",
        "expected_output": "false"
      },
      {
        "input": "\"paper\", \"title\"",
        "expected_output": "true"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "\"\", \"\"",
        "expected_output": "true"
      },
      {
        "input": "\"a\", \"b\"",
        "expected_output": "true"
      },
      {
        "input": "\"ab\", \"aa\"",
        "expected_output": "false"
      },
      {
        "input": "\"badc\", \"bada\"",
        "expected_output": "false"
      },
      {
        "input": "\"abcde\", \"vwxyz\"",
        "expected_output": "true"
      },
      {
        "input": "\"hello\", \"world\"",
        "expected_output": "false"
      },
      {
        "input": "\"aaaa\", \"bbbb\"",
        "expected_output": "true"
      },
      {
        "input": "\"ab\", \"cd\"",
        "expected_output": "true"
      },
      {
        "input": "\"13\", \"42\"",
        "expected_output": "true"
      },
      {
        "input": "\"ACAB\", \"XCXY\"",
        "expected_output": "true"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        ",
      "java": "class Solution {\n    public boolean isIsomorphic(String s, String t) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result).lower() == expected.lower()",
      "java": "return result.equals(expected);",
      "cpp": "return result.asBool() == expected.asBool();"
    },
    "explanation": "https://www.youtube.com/watch?v=7yF-U1hLEqQ&pp=ygUbTmVldENvZGUgSXNvbW9ycGhpYyBTdHJpbmdz",
    "method_name": "isIsomorphic"
  },
  {
    "title": "Contains Duplicate II",
    "source": "https://leetcode.com/problems/contains-duplicate-ii/",
    "description": "Solve the problem titled \"Contains Duplicate II\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "[1,2,3,1], 3",
        "expected_output": "true"
      },
      {
        "input": "[1,0,1,1], 1",
        "expected_output": "true"
      },
      {
        "input": "[1,2,3,1,2,3], 2",
        "expected_output": "false"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[1,2,3,4,5], 2",
        "expected_output": "false"
      },
      {
        "input": "[1,1], 1",
        "expected_output": "true"
      },
      {
        "input": "[1,2,1], 0",
        "expected_output": "false"
      },
      {
        "input": "[1,2,3,4,1], 4",
        "expected_output": "true"
      },
      {
        "input": "[1,2,3,4,1], 3",
        "expected_output": "false"
      },
      {
        "input": "[-1,-1], 1",
        "expected_output": "true"
      },
      {
        "input": "[1], 1",
        "expected_output": "false"
      },
      {
        "input": "[1,2,3,4,2], 3",
        "expected_output": "true"
      },
      {
        "input": "[1,1,1,1], 2",
        "expected_output": "true"
      },
      {
        "input": "[1,2,1,2], 2",
        "expected_output": "true"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        ",
      "java": "class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result).lower() == expected.lower()",
      "java": "return result.equals(expected);",
      "cpp": "return result.asBool() == expected.asBool();"
    },
    "explanation": "https://www.youtube.com/watch?v=ypn0aZ0nrL4&pp=ygUeTmVldENvZGUgQ29udGFpbnMgRHVwbGljYXRlIElJ",
    "method_name": "containsNearbyDuplicate"
  },
  {
    "title": "Summary Ranges",
    "source": "https://leetcode.com/problems/summary-ranges/",
    "description": "Solve the problem titled \"Summary Ranges\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "[0,1,2,4,5,7]",
        "expected_output": "[\"0->2\",\"4->5\",\"7\"]"
      },
      {
        "input": "[0,2,3,4,6,8,9]",
        "expected_output": "[\"0\",\"2->4\",\"6\",\"8->9\"]"
      },
      {
        "input": "[]",
        "expected_output": "[]"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[1]",
        "expected_output": "[\"1\"]"
      },
      {
        "input": "[1,2]",
        "expected_output": "[\"1->2\"]"
      },
      {
        "input": "[1,3,5,7]",
        "expected_output": "[\"1\",\"3\",\"5\",\"7\"]"
      },
      {
        "input": "[1,2,3,4,5]",
        "expected_output": "[\"1->5\"]"
      },
      {
        "input": "[-1,0,1,2]",
        "expected_output": "[\"-1->2\"]"
      },
      {
        "input": "[-5,-4,-3,-1,0,2]",
        "expected_output": "[\"-5->-3\",\"-1->0\",\"2\"]"
      },
      {
        "input": "[1,3]",
        "expected_output": "[\"1\",\"3\"]"
      },
      {
        "input": "[1,2,4,6,7,8]",
        "expected_output": "[\"1->2\",\"4\",\"6->8\"]"
      },
      {
        "input": "[0,1,3,5,6,7,9]",
        "expected_output": "[\"0->1\",\"3\",\"5->7\",\"9\"]"
      },
      {
        "input": "[-2147483648,2147483647]",
        "expected_output": "[\"-2147483648\",\"2147483647\"]"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        ",
      "java": "class Solution {\n    public List<String> summaryRanges(int[] nums) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    vector<string> summaryRanges(vector<int>& nums) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return sorted(result) == sorted(eval(expected))",
      "java": "return result.equals(expected);",
      "cpp": "if (!result.isArray() || !expected.isArray()) {\n        return false;\n    }\n    if (result.size() != expected.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < result.size(); ++i) {\n        if (result[static_cast<int>(i)] != expected[static_cast<int>(i)]) { \n            return false;\n        }\n    }\n    return true;"
    },
    "explanation": "https://www.youtube.com/watch?v=ZHJDwbfqoa8&pp=ygUXTmVldENvZGUgU3VtbWFyeSBSYW5nZXM%3D",
    "method_name": "summaryRanges"
  },
  {
    "title": "Power of Two",
    "source": "https://leetcode.com/problems/power-of-two/",
    "description": "Solve the problem titled \"Power of Two\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "1",
        "expected_output": "true"
      },
      {
        "input": "16",
        "expected_output": "true"
      },
      {
        "input": "3",
        "expected_output": "false"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "0",
        "expected_output": "false"
      },
      {
        "input": "-16",
        "expected_output": "false"
      },
      {
        "input": "2",
        "expected_output": "true"
      },
      {
        "input": "4",
        "expected_output": "true"
      },
      {
        "input": "5",
        "expected_output": "false"
      },
      {
        "input": "32",
        "expected_output": "true"
      },
      {
        "input": "64",
        "expected_output": "true"
      },
      {
        "input": "100",
        "expected_output": "false"
      },
      {
        "input": "2147483647",
        "expected_output": "false"
      },
      {
        "input": "-2147483648",
        "expected_output": "false"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        ",
      "java": "class Solution {\n    public boolean isPowerOfTwo(int n) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result).lower() == expected.lower()",
      "java": "return result.equals(expected);",
      "cpp": "return result.asBool() == (expected.asString() == \"true\");"
    },
    "explanation": "https://www.youtube.com/watch?v=H2bjttEV4Vc&pp=ygUVTmVldENvZGUgUG93ZXIgb2YgVHdv",
    "method_name": "isPowerOfTwo"
  },
  {
    "title": "Ugly Number",
    "source": "https://leetcode.com/problems/ugly-number/",
    "description": "Solve the problem titled \"Ugly Number\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "6",
        "expected_output": "true"
      },
      {
        "input": "1",
        "expected_output": "true"
      },
      {
        "input": "14",
        "expected_output": "false"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "8",
        "expected_output": "true"
      },
      {
        "input": "0",
        "expected_output": "false"
      },
      {
        "input": "-6",
        "expected_output": "false"
      },
      {
        "input": "25",
        "expected_output": "true"
      },
      {
        "input": "15",
        "expected_output": "true"
      },
      {
        "input": "49",
        "expected_output": "false"
      },
      {
        "input": "30",
        "expected_output": "true"
      },
      {
        "input": "100",
        "expected_output": "true"
      },
      {
        "input": "-2147483648",
        "expected_output": "false"
      },
      {
        "input": "2147483647",
        "expected_output": "false"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def isUgly(self, n: int) -> bool:\n        ",
      "java": "class Solution {\n    public boolean isUgly(int n) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    bool isUgly(int n) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result).lower() == expected.lower()",
      "java": "return result.equals(expected);",
      "cpp": "return result.asBool() == expected.asBool();"
    },
    "explanation": "https://www.youtube.com/watch?v=M0Zay1Qr9ws&pp=ygUUTmVldENvZGUgVWdseSBOdW1iZXI%3D",
    "method_name": "isUgly"
  },
  {
    "title": "Word Pattern",
    "source": "https://leetcode.com/problems/word-pattern/",
    "description": "Solve the problem titled \"Word Pattern\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "\"abba\", \"dog, cat, cat, dog\"",
        "expected_output": "true"
      },
      {
        "input": "\"abba\", \"dog, cat, cat, fish\"",
        "expected_output": "false"
      },
      {
        "input": "\"aaaa\", \"dog, cat, cat, dog\"",
        "expected_output": "false"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "\"abc\", \"dog, cat, dog\"",
        "expected_output": "false"
      },
      {
        "input": "\"jquery\", \"jquery\"",
        "expected_output": "false"
      },
      {
        "input": "\"aaa\", \"aa, aa, aa\"",
        "expected_output": "true"
      },
      {
        "input": "\"abba\", \"dog, dog, dog, dog\"",
        "expected_output": "false"
      },
      {
        "input": "\"ab\", \"dog, cat\"",
        "expected_output": "true"
      },
      {
        "input": "\"abc\", \"b, c, a\"",
        "expected_output": "true"
      },
      {
        "input": "\"aabb\", \"cat, cat, dog, dog\"",
        "expected_output": "true"
      },
      {
        "input": "\"abba\", \"dog, cat, cat, fish\"",
        "expected_output": "false"
      },
      {
        "input": "\"\", \"\"",
        "expected_output": "true"
      },
      {
        "input": "\"a\", \"dog\"",
        "expected_output": "true"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        ",
      "java": "class Solution {\n    public boolean wordPattern(String pattern, String s) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    bool wordPattern(string pattern, string s) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result).lower() == expected.lower()",
      "java": "return result.equals(expected);",
      "cpp": "return result.asBool() == expected.asBool();"
    },
    "explanation": "https://www.youtube.com/watch?v=W_akoecmCbM&pp=ygUVTmVldENvZGUgV29yZCBQYXR0ZXJu",
    "method_name": "wordPattern"
  },
  {
    "title": "Nim Game",
    "source": "https://leetcode.com/problems/nim-game/",
    "description": "Solve the problem titled \"Nim Game\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "4",
        "expected_output": "false"
      },
      {
        "input": "1",
        "expected_output": "true"
      },
      {
        "input": "2",
        "expected_output": "true"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "3",
        "expected_output": "true"
      },
      {
        "input": "5",
        "expected_output": "true"
      },
      {
        "input": "6",
        "expected_output": "true"
      },
      {
        "input": "7",
        "expected_output": "true"
      },
      {
        "input": "8",
        "expected_output": "false"
      },
      {
        "input": "9",
        "expected_output": "true"
      },
      {
        "input": "10",
        "expected_output": "true"
      },
      {
        "input": "100",
        "expected_output": "false"
      },
      {
        "input": "1000000",
        "expected_output": "false"
      },
      {
        "input": "2147483647",
        "expected_output": "true"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def canWinNim(self, n: int) -> bool:\n        ",
      "java": "class Solution {\n    public boolean canWinNim(int n) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    bool canWinNim(int n) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result).lower() == expected.lower()",
      "java": "return result.equals(expected);",
      "cpp": "return result.asBool() == (expected.asString() == \"true\");"
    },
    "explanation": "https://www.youtube.com/watch?v=ndR2buBWVc8&pp=ygURTmVldENvZGUgTmltIEdhbWU%3D",
    "method_name": "canWinNim"
  },
  {
    "title": "Power of Three",
    "source": "https://leetcode.com/problems/power-of-three/",
    "description": "Solve the problem titled \"Power of Three\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "27",
        "expected_output": "true"
      },
      {
        "input": "0",
        "expected_output": "false"
      },
      {
        "input": "-1",
        "expected_output": "false"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "1",
        "expected_output": "true"
      },
      {
        "input": "9",
        "expected_output": "true"
      },
      {
        "input": "45",
        "expected_output": "false"
      },
      {
        "input": "81",
        "expected_output": "true"
      },
      {
        "input": "243",
        "expected_output": "true"
      },
      {
        "input": "-3",
        "expected_output": "false"
      },
      {
        "input": "2",
        "expected_output": "false"
      },
      {
        "input": "99",
        "expected_output": "false"
      },
      {
        "input": "19683",
        "expected_output": "true"
      },
      {
        "input": "-729",
        "expected_output": "false"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def isPowerOfThree(self, n: int) -> bool:\n        ",
      "java": "class Solution {\n    public boolean isPowerOfThree(int n) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    bool isPowerOfThree(int n) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result).lower() == expected.lower()",
      "java": "return result.equals(expected);",
      "cpp": "return result.asBool() == expected.asBool();"
    },
    "explanation": "https://www.youtube.com/watch?v=M2P2BAFmLlo&pp=ygUXTmVldENvZGUgUG93ZXIgb2YgVGhyZWU%3D",
    "method_name": "isPowerOfThree"
  },
  {
    "title": "Power of Four",
    "source": "https://leetcode.com/problems/power-of-four/",
    "description": "Solve the problem titled \"Power of Four\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "16",
        "expected_output": "true"
      },
      {
        "input": "5",
        "expected_output": "false"
      },
      {
        "input": "1",
        "expected_output": "true"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "4",
        "expected_output": "true"
      },
      {
        "input": "64",
        "expected_output": "true"
      },
      {
        "input": "8",
        "expected_output": "false"
      },
      {
        "input": "256",
        "expected_output": "true"
      },
      {
        "input": "-4",
        "expected_output": "false"
      },
      {
        "input": "0",
        "expected_output": "false"
      },
      {
        "input": "2",
        "expected_output": "false"
      },
      {
        "input": "100",
        "expected_output": "false"
      },
      {
        "input": "1024",
        "expected_output": "true"
      },
      {
        "input": "-1024",
        "expected_output": "false"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        ",
      "java": "class Solution {\n    public boolean isPowerOfFour(int n) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    bool isPowerOfFour(int n) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result).lower() == expected.lower()",
      "java": "return result.equals(expected);",
      "cpp": "return result.asBool() == expected.asBool();"
    },
    "explanation": "https://www.youtube.com/watch?v=qEYZPwnlM0U&pp=ygUWTmVldENvZGUgUG93ZXIgb2YgRm91cg%3D%3D",
    "method_name": "isPowerOfFour"
  },
  {
    "title": "Reverse Vowels of a String",
    "source": "https://leetcode.com/problems/reverse-vowels-of-a-string/",
    "description": "Solve the problem titled \"Reverse Vowels of a String\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "'IceCreAm'",
        "expected_output": "'AceCreIm'"
      },
      {
        "input": "'leetcode'",
        "expected_output": "'leotcede'"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "'hello'",
        "expected_output": "'holle'"
      },
      {
        "input": "'aA'",
        "expected_output": "'Aa'"
      },
      {
        "input": "'race, a, car'",
        "expected_output": "'raca e car'"
      },
      {
        "input": "''",
        "expected_output": "''"
      },
      {
        "input": "'xyz'",
        "expected_output": "'xyz'"
      },
      {
        "input": "'AEIOU'",
        "expected_output": "'UOIEA'"
      },
      {
        "input": "'aeiou'",
        "expected_output": "'uoiea'"
      },
      {
        "input": "'.,!'",
        "expected_output": "'.,!'"
      },
      {
        "input": "'Aa'",
        "expected_output": "'aA'"
      },
      {
        "input": "'LEetcOde'",
        "expected_output": "'LeOtcedE'"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def reverseVowels(self, s: str) -> str:\n        ",
      "java": "class Solution {\n    public String reverseVowels(String s) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    string reverseVowels(string s) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == eval(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asString() == expected.asString();"
    },
    "explanation": "https://www.youtube.com/watch?v=uHYjUMR3Tg8&pp=ygUjTmVldENvZGUgUmV2ZXJzZSBWb3dlbHMgb2YgYSBTdHJpbmc%3D",
    "method_name": "reverseVowels"
  },
  {
    "title": "Intersection of Two Arrays II",
    "source": "https://leetcode.com/problems/intersection-of-two-arrays-ii/",
    "description": "Solve the problem titled \"Intersection of Two Arrays II\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "[1,2,2,1], [2,2]",
        "expected_output": "[2,2]"
      },
      {
        "input": "[4,9,5], [9,4,9,8,4]",
        "expected_output": "[9,4]"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[1,1,1], [1,1]",
        "expected_output": "[1,1]"
      },
      {
        "input": "[1,2], [1,1]",
        "expected_output": "[1]"
      },
      {
        "input": "[1], [1]",
        "expected_output": "[1]"
      },
      {
        "input": "[1,2,3], [4,5,6]",
        "expected_output": "[]"
      },
      {
        "input": "[1,2,3,4], [1,2,3,4]",
        "expected_output": "[1,2,3,4]"
      },
      {
        "input": "[1,1,1,1], [1]",
        "expected_output": "[1]"
      },
      {
        "input": "[], [1]",
        "expected_output": "[]"
      },
      {
        "input": "[1,2,2,3], [2,2,2,3]",
        "expected_output": "[2,2,3]"
      },
      {
        "input": "[1,2,3,4,5], [5,4,3,2,1]",
        "expected_output": "[5,4,3,2,1]"
      },
      {
        "input": "[1000,1000], [1000,1000]",
        "expected_output": "[1000,1000]"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        ",
      "java": "class Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return sorted(result) == sorted(eval(expected))",
      "java": "if (result instanceof Unknown || expected instanceof Unknown) {\n            return true;\n        }\n\n        if (result == null || expected == null) {\n            return result == expected;\n        }\n\n        if (result.getClass().isArray()) {\n            if (!expected.getClass().isArray()) {\n                return false;\n            }\n            int length = Array.getLength(result);\n            if (length != Array.getLength(expected)) {\n                return false;\n            }\n            // Convert arrays to lists for sorting\n            List<Object> resultList = new ArrayList<>();\n            List<Object> expectedList = new ArrayList<>();\n            for (int i = 0; i < length; i++) {\n                resultList.add(Array.get(result, i));\n                expectedList.add(Array.get(expected, i));\n            }\n            Collections.sort(resultList, Comparator.comparing(Object::toString));\n            Collections.sort(expectedList, Comparator.comparing(Object::toString));\n            for (int i = 0; i < length; i++) {\n                if (!compare(resultList.get(i), expectedList.get(i))) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        if (result instanceof List && expected instanceof List) {\n            if (!(expected instanceof List)) {\n                return false;\n            }\n            List<?> resultList = new ArrayList<>((List<?>) result);\n            List<?> expectedList = new ArrayList<>((List<?>) expected);\n            if (resultList.size() != expectedList.size()) {\n                return false;\n            }\n            // Sort both lists\n            Collections.sort((List)resultList, Comparator.comparing(Object::toString));\n            Collections.sort((List)expectedList, Comparator.comparing(Object::toString));\n            for (int i = 0; i < resultList.size(); i++) {\n                if (!compare(resultList.get(i), expectedList.get(i))) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        return result.equals(expected);",
      "cpp": "std::vector<int> result_vector;\n    for (const auto& value : result) {\n        result_vector.push_back(value.asInt());\n    }\n\n    std::vector<int> expected_vector;\n    for (const auto& value : expected) {\n        expected_vector.push_back(value.asInt());\n    }\n\n    std::sort(result_vector.begin(), result_vector.end());\n    std::sort(expected_vector.begin(), expected_vector.end());\n\n    return result_vector == expected_vector;"
    },
    "explanation": "https://www.youtube.com/watch?v=fwUTXaMom6U&pp=ygUmTmVldENvZGUgSW50ZXJzZWN0aW9uIG9mIFR3byBBcnJheXMgSUk%3D",
    "method_name": "intersect"
  },
  {
    "title": "Valid Perfect Square",
    "source": "https://leetcode.com/problems/valid-perfect-square/",
    "description": "Solve the problem titled \"Valid Perfect Square\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "16",
        "expected_output": "true"
      },
      {
        "input": "14",
        "expected_output": "false"
      },
      {
        "input": "1",
        "expected_output": "true"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "0",
        "expected_output": "true"
      },
      {
        "input": "4",
        "expected_output": "true"
      },
      {
        "input": "9",
        "expected_output": "true"
      },
      {
        "input": "25",
        "expected_output": "true"
      },
      {
        "input": "26",
        "expected_output": "false"
      },
      {
        "input": "100",
        "expected_output": "true"
      },
      {
        "input": "2147483647",
        "expected_output": "false"
      },
      {
        "input": "808201",
        "expected_output": "true"
      },
      {
        "input": "2",
        "expected_output": "false"
      },
      {
        "input": "3",
        "expected_output": "false"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        ",
      "java": "class Solution {\n    public boolean isPerfectSquare(int num) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    bool isPerfectSquare(int num) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result).lower() == expected.lower()",
      "java": "return result.equals(expected);",
      "cpp": "return result.asBool() == expected.asBool();"
    },
    "explanation": "https://www.youtube.com/watch?v=Cg_wWPHJ2Sk&pp=ygUdTmVldENvZGUgVmFsaWQgUGVyZmVjdCBTcXVhcmU%3D",
    "method_name": "isPerfectSquare"
  },
  {
    "title": "Find the Difference",
    "source": "https://leetcode.com/problems/find-the-difference/",
    "description": "Solve the problem titled \"Find the Difference\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "'abcd', 'abcde'",
        "expected_output": "'e'"
      },
      {
        "input": "'', 'y'",
        "expected_output": "'y'"
      },
      {
        "input": "'ae', 'aea'",
        "expected_output": "'a'"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "'abcd', 'abcde'",
        "expected_output": "'e'"
      },
      {
        "input": "'', 'y'",
        "expected_output": "'y'"
      },
      {
        "input": "'a', 'aa'",
        "expected_output": "'a'"
      },
      {
        "input": "'ae', 'aea'",
        "expected_output": "'a'"
      },
      {
        "input": "'abc', 'cabd'",
        "expected_output": "'d'"
      },
      {
        "input": "'xyz', 'xyzz'",
        "expected_output": "'z'"
      },
      {
        "input": "'aaa', 'aaaa'",
        "expected_output": "'a'"
      },
      {
        "input": "'bb', 'bbb'",
        "expected_output": "'b'"
      },
      {
        "input": "'abcd', 'dbcae'",
        "expected_output": "'e'"
      },
      {
        "input": "'hello', 'hollae'",
        "expected_output": "'a'"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        ",
      "java": "class Solution {\n    public char findTheDifference(String s, String t) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    char findTheDifference(string s, string t) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == eval(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asString() == expected.asString();"
    },
    "explanation": "https://www.youtube.com/watch?v=a4wqKR-znBE&pp=ygUcTmVldENvZGUgRmluZCB0aGUgRGlmZmVyZW5jZQ%3D%3D",
    "method_name": "findTheDifference"
  },
  {
    "title": "Is Subsequence",
    "source": "https://leetcode.com/problems/is-subsequence/",
    "description": "Solve the problem titled \"Is Subsequence\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "'abc', 'ahbgdc'",
        "expected_output": "true"
      },
      {
        "input": "'axc', 'ahbgdc'",
        "expected_output": "false"
      },
      {
        "input": "'', 'ahbgdc'",
        "expected_output": "true"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "'abc', 'ahbgdc'",
        "expected_output": "true"
      },
      {
        "input": "'', ''",
        "expected_output": "true"
      },
      {
        "input": "'abc', 'abc'",
        "expected_output": "true"
      },
      {
        "input": "'abc', 'abcd'",
        "expected_output": "true"
      },
      {
        "input": "'abc', 'acb'",
        "expected_output": "false"
      },
      {
        "input": "'ab', 'baab'",
        "expected_output": "true"
      },
      {
        "input": "'leetcode', 'yleets'",
        "expected_output": "false"
      },
      {
        "input": "'b', 'abc'",
        "expected_output": "true"
      },
      {
        "input": "'bb', 'ahbgb'",
        "expected_output": "true"
      },
      {
        "input": "'aaaaaa', 'bbaaaa'",
        "expected_output": "false"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        ",
      "java": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    bool isSubsequence(string s, string t) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result).lower() == expected.lower()",
      "java": "return result.equals(expected);",
      "cpp": "return result.asBool() == expected.asBool();"
    },
    "explanation": "https://www.youtube.com/watch?v=99RVfqklbCE&pp=ygUXTmVldENvZGUgSXMgU3Vic2VxdWVuY2U%3D",
    "method_name": "isSubsequence"
  },
  {
    "title": "Binary Watch",
    "source": "https://leetcode.com/problems/binary-watch/",
    "description": "Solve the problem titled \"Binary Watch\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "1",
        "expected_output": "['0:01','0:02','0:04','0:08','0:16','0:32','1:00','2:00','4:00','8:00']"
      },
      {
        "input": "9",
        "expected_output": "[]"
      },
      {
        "input": "2",
        "expected_output": "['0:03','0:05','0:06','0:09','0:10','0:12','0:17','0:18','0:20','0:24','0:33','0:34','0:36','0:40','0:48','1:01','1:02','1:04','1:08','1:16','1:32','2:01','2:02','2:04','2:08','2:16','2:32','3:00','4:01','4:02','4:04','4:08','4:16','4:32','5:00','6:00','8:01','8:02','8:04','8:08','8:16','8:32','9:00','10:00']"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "0",
        "expected_output": "['0:00']"
      },
      {
        "input": "1",
        "expected_output": "['0:01','0:02','0:04','0:08','0:16','0:32','1:00','2:00','4:00','8:00']"
      },
      {
        "input": "2",
        "expected_output": "['0:03','0:05','0:06','0:09','0:10','0:12','0:17','0:18','0:20','0:24','0:33','0:34','0:36','0:40','0:48','1:01','1:02','1:04','1:08','1:16','1:32','2:01','2:02','2:04','2:08','2:16','2:32','3:00','4:01','4:02','4:04','4:08','4:16','4:32','5:00','6:00','8:01','8:02','8:04','8:08','8:16','8:32','9:00','10:00']"
      },
      {
        "input": "3",
        "expected_output": "['0:07','0:11','0:13','0:14','0:19','0:21','0:22','0:25','0:26','0:28','0:35','0:37','0:38','0:41','0:42','0:44','0:49','0:50','0:52','0:56','1:03','1:05','1:06','1:09','1:10','1:12','1:17','1:18','1:20','1:24','1:33','1:34','1:36','1:40','1:48','2:03','2:05','2:06','2:09','2:10','2:12','2:17','2:18','2:20','2:24','2:33','2:34','2:36','2:40','2:48','3:01','3:02','3:04','3:08','3:16','3:32','4:03','4:05','4:06','4:09','4:10','4:12','4:17','4:18','4:20','4:24','4:33','4:34','4:36','4:40','4:48','5:01','5:02','5:04','5:08','5:16','5:32','6:01','6:02','6:04','6:08','6:16','6:32','7:00','8:03','8:05','8:06','8:09','8:10','8:12','8:17','8:18','8:20','8:24','8:33','8:34','8:36','8:40','8:48','9:01','9:02','9:04','9:08','9:16','9:32','10:01','10:02','10:04','10:08','10:16','10:32','11:00']"
      },
      {
        "input": "4",
        "expected_output": "['0:15','0:23','0:27','0:29','0:30','0:39','0:43','0:45','0:46','0:51','0:53','0:54','0:57','0:58','1:07','1:11','1:13','1:14','1:19','1:21','1:22','1:25','1:26','1:28','1:35','1:37','1:38','1:41','1:42','1:44','1:49','1:50','1:52','1:56','2:07','2:11','2:13','2:14','2:19','2:21','2:22','2:25','2:26','2:28','2:35','2:37','2:38','2:41','2:42','2:44','2:49','2:50','2:52','2:56','3:03','3:05','3:06','3:09','3:10','3:12','3:17','3:18','3:20','3:24','3:33','3:34','3:36','3:40','3:48','4:07','4:11','4:13','4:14','4:19','4:21','4:22','4:25','4:26','4:28','4:35','4:37','4:38','4:41','4:42','4:44','4:49','4:50','4:52','4:56','5:03','5:05','5:06','5:09','5:10','5:12','5:17','5:18','5:20','5:24','5:33','5:34','5:36','5:40','5:48','6:03','6:05','6:06','6:09','6:10','6:12','6:17','6:18','6:20','6:24','6:33','6:34','6:36','6:40','6:48','7:01','7:02','7:04','7:08','7:16','7:32','8:07','8:11','8:13','8:14','8:19','8:21','8:22','8:25','8:26','8:28','8:35','8:37','8:38','8:41','8:42','8:44','8:49','8:50','8:52','8:56','9:03','9:05','9:06','9:09','9:10','9:12','9:17','9:18','9:20','9:24','9:33','9:34','9:36','9:40','9:48','10:03','10:05','10:06','10:09','10:10','10:12','10:17','10:18','10:20','10:24','10:33','10:34','10:36','10:40','10:48','11:01','11:02','11:04','11:08','11:16','11:32']"
      },
      {
        "input": "5",
        "expected_output": "['0:31','0:47','0:55','0:59','1:15','1:23','1:27','1:29','1:30','1:39','1:43','1:45','1:46','1:51','1:53','1:54','1:57','1:58','2:15','2:23','2:27','2:29','2:30','2:39','2:43','2:45','2:46','2:51','2:53','2:54','2:57','2:58','3:07','3:11','3:13','3:14','3:19','3:21','3:22','3:25','3:26','3:28','3:35','3:37','3:38','3:41','3:42','3:44','3:49','3:50','3:52','3:56','4:15','4:23','4:27','4:29','4:30','4:39','4:43','4:45','4:46','4:51','4:53','4:54','4:57','4:58','5:07','5:11','5:13','5:14','5:19','5:21','5:22','5:25','5:26','5:28','5:35','5:37','5:38','5:41','5:42','5:44','5:49','5:50','5:52','5:56','6:07','6:11','6:13','6:14','6:19','6:21','6:22','6:25','6:26','6:28','6:35','6:37','6:38','6:41','6:42','6:44','6:49','6:50','6:52','6:56','7:03','7:05','7:06','7:09','7:10','7:12','7:17','7:18','7:20','7:24','7:33','7:34','7:36','7:40','7:48','8:15','8:23','8:27','8:29','8:30','8:39','8:43','8:45','8:46','8:51','8:53','8:54','8:57','8:58','9:07','9:11','9:13','9:14','9:19','9:21','9:22','9:25','9:26','9:28','9:35','9:37','9:38','9:41','9:42','9:44','9:49','9:50','9:52','9:56','10:07','10:11','10:13','10:14','10:19','10:21','10:22','10:25','10:26','10:28','10:35','10:37','10:38','10:41','10:42','10:44','10:49','10:50','10:52','10:56','11:03','11:05','11:06','11:09','11:10','11:12','11:17','11:18','11:20','11:24','11:33','11:34','11:36','11:40','11:48']"
      },
      {
        "input": "6",
        "expected_output": "['1:31','1:47','1:55','1:59','2:31','2:47','2:55','2:59','3:15','3:23','3:27','3:29','3:30','3:39','3:43','3:45','3:46','3:51','3:53','3:54','3:57','3:58','4:31','4:47','4:55','4:59','5:15','5:23','5:27','5:29','5:30','5:39','5:43','5:45','5:46','5:51','5:53','5:54','5:57','5:58','6:15','6:23','6:27','6:29','6:30','6:39','6:43','6:45','6:46','6:51','6:53','6:54','6:57','6:58','7:07','7:11','7:13','7:14','7:19','7:21','7:22','7:25','7:26','7:28','7:35','7:37','7:38','7:41','7:42','7:44','7:49','7:50','7:52','7:56','8:31','8:47','8:55','8:59','9:15','9:23','9:27','9:29','9:30','9:39','9:43','9:45','9:46','9:51','9:53','9:54','9:57','9:58','10:15','10:23','10:27','10:29','10:30','10:39','10:43','10:45','10:46','10:51','10:53','10:54','10:57','10:58','11:07','11:11','11:13','11:14','11:19','11:21','11:22','11:25','11:26','11:28','11:35','11:37','11:38','11:41','11:42','11:44','11:49','11:50','11:52','11:56']"
      },
      {
        "input": "7",
        "expected_output": "['3:31','3:47','3:55','3:59','5:31','5:47','5:55','5:59','6:31','6:47','6:55','6:59','7:15','7:23','7:27','7:29','7:30','7:39','7:43','7:45','7:46','7:51','7:53','7:54','7:57','7:58','9:31','9:47','9:55','9:59','10:31','10:47','10:55','10:59','11:15','11:23','11:27','11:29','11:30','11:39','11:43','11:45','11:46','11:51','11:53','11:54','11:57','11:58']"
      },
      {
        "input": "8",
        "expected_output": "['7:31','7:47','7:55','7:59','11:31','11:47','11:55','11:59']"
      },
      {
        "input": "9",
        "expected_output": "[]"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        ",
      "java": "class Solution {\n    public List<String> readBinaryWatch(int turnedOn) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    vector<string> readBinaryWatch(int turnedOn) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "def sorted_list_strings(lst):\n        return sorted([str(x) for x in eval(lst)])\n    return sorted(result) == sorted_list_strings(expected)",
      "java": "if (result == null && expected == null) {\n            return true;\n        }\n        if (result == null || expected == null) {\n            return false;\n        }\n\n        List<String> resultList;\n        List<String> expectedList;\n\n        if (result instanceof List) {\n            resultList = (List<String>) result;\n        } else if (result instanceof String[]) {\n            resultList = Arrays.asList((String[]) result);\n        } else {\n            return false;\n        }\n\n        if (expected instanceof List) {\n            expectedList = (List<String>) expected;\n        } else if (expected instanceof String[]) {\n            expectedList = Arrays.asList((String[]) expected);\n        } else {\n            return false;\n        }\n\n        if (resultList.size() != expectedList.size()) {\n            return false;\n        }\n        List<String> sortedResult = new ArrayList<>(resultList);\n        List<String> sortedExpected = new ArrayList<>(expectedList);\n        Collections.sort(sortedResult);\n        Collections.sort(sortedExpected);\n        return sortedResult.equals(sortedExpected);\n",
      "cpp": "if (!result.isArray() ||!expected.isArray()) {\n        return false; // Both must be arrays\n    }\n\n    if (result.size()!= expected.size()) return false;\n\n    std::vector<std::string> resultVec;\n    std::vector<std::string> expectedVec;\n\n    for (const auto& val: result) {\n        if (!val.isString()) return false; // Ensure all elements are strings\n        resultVec.push_back(val.asString());\n    }\n    for (const auto& val: expected) {\n        if (!val.isString()) return false; // Ensure all elements are strings\n        expectedVec.push_back(val.asString());\n    }\n\n    std::sort(resultVec.begin(), resultVec.end());\n    std::sort(expectedVec.begin(), expectedVec.end());\n\n    return resultVec == expectedVec;"
    },
    "explanation": "https://www.youtube.com/watch?v=0BanwDe6cMY&pp=ygUVTmVldENvZGUgQmluYXJ5IFdhdGNo",
    "method_name": "readBinaryWatch"
  },
  {
    "title": "Convert a Number to Hexadecimal",
    "source": "https://leetcode.com/problems/convert-a-number-to-hexadecimal/",
    "description": "Solve the problem titled \"Convert a Number to Hexadecimal\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "26",
        "expected_output": "'1a'"
      },
      {
        "input": "-1",
        "expected_output": "'ffffffff'"
      },
      {
        "input": "0",
        "expected_output": "'0'"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "0",
        "expected_output": "'0'"
      },
      {
        "input": "16",
        "expected_output": "'10'"
      },
      {
        "input": "26",
        "expected_output": "'1a'"
      },
      {
        "input": "-1",
        "expected_output": "'ffffffff'"
      },
      {
        "input": "2147483647",
        "expected_output": "'7fffffff'"
      },
      {
        "input": "-2147483648",
        "expected_output": "'80000000'"
      },
      {
        "input": "100",
        "expected_output": "'64'"
      },
      {
        "input": "-100",
        "expected_output": "'ffffff9c'"
      },
      {
        "input": "255",
        "expected_output": "'ff'"
      },
      {
        "input": "-255",
        "expected_output": "'ffffff01'"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def toHex(self, num: int) -> str:\n        ",
      "java": "class Solution {\n    public String toHex(int num) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    string toHex(int num) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == eval(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asString() == expected.asString();"
    },
    "explanation": "https://www.youtube.com/watch?v=I1HBykyZvbc&pp=ygUoTmVldENvZGUgQ29udmVydCBhIE51bWJlciB0byBIZXhhZGVjaW1hbA%3D%3D",
    "method_name": "toHex"
  },
  {
    "title": "Longest Palindrome",
    "source": "https://leetcode.com/problems/longest-palindrome/",
    "description": "Given a string or array, determine how to compute or maximize a palindrome under the logic defined by the problem titled \"Longest Palindrome\". Return the result based on the transformation rules involved.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "'abccccdd'",
        "expected_output": "7"
      },
      {
        "input": "'a'",
        "expected_output": "1"
      },
      {
        "input": "'Aa'",
        "expected_output": "1"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "'racecar'",
        "expected_output": "7"
      },
      {
        "input": "'aaaaaa'",
        "expected_output": "6"
      },
      {
        "input": "'abcde'",
        "expected_output": "1"
      },
      {
        "input": "'AAaa'",
        "expected_output": "4"
      },
      {
        "input": "'aA'",
        "expected_output": "1"
      },
      {
        "input": "'z'",
        "expected_output": "1"
      },
      {
        "input": "'abccba'",
        "expected_output": "6"
      },
      {
        "input": "'aaabbbcccc'",
        "expected_output": "9"
      },
      {
        "input": "'abcABC'",
        "expected_output": "1"
      },
      {
        "input": "''",
        "expected_output": "0"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def longestPalindrome(self, s: str) -> int:\n        ",
      "java": "class Solution {\n    public int longestPalindrome(String s) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int longestPalindrome(string s) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return int(result) == int(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return std::stoi(result.asString()) == std::stoi(expected.asString());"
    },
    "explanation": "https://www.youtube.com/watch?v=_g9jrLuAphs&pp=ygUbTmVldENvZGUgTG9uZ2VzdCBQYWxpbmRyb21l",
    "method_name": "longestPalindrome"
  },
  {
    "title": "Add Strings",
    "source": "https://leetcode.com/problems/add-strings/",
    "description": "Solve the problem titled \"Add Strings\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "'11', '123'",
        "expected_output": "'134'"
      },
      {
        "input": "'456', '77'",
        "expected_output": "'533'"
      },
      {
        "input": "'0', '0'",
        "expected_output": "'0'"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "'9', '1'",
        "expected_output": "'10'"
      },
      {
        "input": "'999', '1'",
        "expected_output": "'1000'"
      },
      {
        "input": "'1', '999'",
        "expected_output": "'1000'"
      },
      {
        "input": "'0', '1'",
        "expected_output": "'1'"
      },
      {
        "input": "'1', '0'",
        "expected_output": "'1'"
      },
      {
        "input": "'999999', '1'",
        "expected_output": "'1000000'"
      },
      {
        "input": "'123', '456'",
        "expected_output": "'579'"
      },
      {
        "input": "'1000', '2000'",
        "expected_output": "'3000'"
      },
      {
        "input": "'9999', '9999'",
        "expected_output": "'19998'"
      },
      {
        "input": "'1111', '9999'",
        "expected_output": "'11110'"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        ",
      "java": "class Solution {\n    public String addStrings(String num1, String num2) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    string addStrings(string num1, string num2) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result) == eval(expected)",
      "java": "return result.toString().equals(expected.toString());",
      "cpp": "return result == expected;"
    },
    "explanation": "https://www.youtube.com/watch?v=jziDtPZJ4fw&pp=ygUUTmVldENvZGUgQWRkIFN0cmluZ3M%3D",
    "method_name": "addStrings"
  },
  {
    "title": "Arranging Coins",
    "source": "https://leetcode.com/problems/arranging-coins/",
    "description": "Solve the problem titled \"Arranging Coins\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "5",
        "expected_output": "2"
      },
      {
        "input": "8",
        "expected_output": "3"
      },
      {
        "input": "1",
        "expected_output": "1"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "0",
        "expected_output": "0"
      },
      {
        "input": "3",
        "expected_output": "2"
      },
      {
        "input": "10",
        "expected_output": "4"
      },
      {
        "input": "15",
        "expected_output": "5"
      },
      {
        "input": "21",
        "expected_output": "6"
      },
      {
        "input": "100",
        "expected_output": "13"
      },
      {
        "input": "1000",
        "expected_output": "44"
      },
      {
        "input": "10000",
        "expected_output": "140"
      },
      {
        "input": "2147483647",
        "expected_output": "65535"
      },
      {
        "input": "6",
        "expected_output": "3"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def arrangeCoins(self, n: int) -> int:\n        ",
      "java": "class Solution {\n    public int arrangeCoins(int n) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int arrangeCoins(int n) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return int(result) == int(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asInt() == std::stoi(expected.asString());"
    },
    "explanation": "https://www.youtube.com/watch?v=5rHz_6s2Buw&pp=ygUYTmVldENvZGUgQXJyYW5naW5nIENvaW5z",
    "method_name": "arrangeCoins"
  },
  {
    "title": "Assign Cookies",
    "source": "https://leetcode.com/problems/assign-cookies/",
    "description": "Solve the problem titled \"Assign Cookies\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "[1,2,3], [1,1]",
        "expected_output": "1"
      },
      {
        "input": "[1,2], [1,2,3]",
        "expected_output": "2"
      },
      {
        "input": "[1,2,3], []",
        "expected_output": "0"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[], [1,2,3]",
        "expected_output": "0"
      },
      {
        "input": "[1,2], [1]",
        "expected_output": "1"
      },
      {
        "input": "[2], [1]",
        "expected_output": "0"
      },
      {
        "input": "[1,2,3], [1,2,3]",
        "expected_output": "3"
      },
      {
        "input": "[10,9,8,7], [5,6,7,8]",
        "expected_output": "2"
      },
      {
        "input": "[1,1,1], [1,1,1]",
        "expected_output": "3"
      },
      {
        "input": "[2,3,4,5], [1,2,3]",
        "expected_output": "2"
      },
      {
        "input": "[1], [2]",
        "expected_output": "1"
      },
      {
        "input": "[3,4,5], [1,2]",
        "expected_output": "0"
      },
      {
        "input": "[1,2,3], [3]",
        "expected_output": "1"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        ",
      "java": "class Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return int(result) == int(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return std::stoi(result.asString()) == std::stoi(expected.asString());"
    },
    "explanation": "https://www.youtube.com/watch?v=JW8fgvoxPTg&pp=ygUXTmVldENvZGUgQXNzaWduIENvb2tpZXM%3D",
    "method_name": "findContentChildren"
  },
  {
    "title": "Repeated Substring Pattern",
    "source": "https://leetcode.com/problems/repeated-substring-pattern/",
    "description": "Solve the problem titled \"Repeated Substring Pattern\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "'abab'",
        "expected_output": "true"
      },
      {
        "input": "'aba'",
        "expected_output": "false"
      },
      {
        "input": "'abcabcabcabc'",
        "expected_output": "true"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "''",
        "expected_output": "true"
      },
      {
        "input": "'a'",
        "expected_output": "false"
      },
      {
        "input": "'aa'",
        "expected_output": "true"
      },
      {
        "input": "'aaa'",
        "expected_output": "true"
      },
      {
        "input": "'aabaaba'",
        "expected_output": "false"
      },
      {
        "input": "'abaababaab'",
        "expected_output": "true"
      },
      {
        "input": "'aaaaa'",
        "expected_output": "true"
      },
      {
        "input": "'abcabc'",
        "expected_output": "true"
      },
      {
        "input": "'abcabcabc'",
        "expected_output": "true"
      },
      {
        "input": "'abac'",
        "expected_output": "false"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        ",
      "java": "class Solution {\n    public boolean repeatedSubstringPattern(String s) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    bool repeatedSubstringPattern(string s) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result).lower() == expected.lower()",
      "java": "return result.equals(expected);",
      "cpp": "return result.asBool() == expected.asBool();"
    },
    "explanation": "https://www.youtube.com/watch?v=2qEmA76Unm4&pp=ygUjTmVldENvZGUgUmVwZWF0ZWQgU3Vic3RyaW5nIFBhdHRlcm4%3D",
    "method_name": "repeatedSubstringPattern"
  },
  {
    "title": "License Key Formatting",
    "source": "https://leetcode.com/problems/license-key-formatting/",
    "description": "Solve the problem titled \"License Key Formatting\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "'5F3Z-2e-9-w', 4",
        "expected_output": "'5F3Z-2E9W'"
      },
      {
        "input": "'2-5g-3-J', 2",
        "expected_output": "'2-5G-3J'"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "'a-a-a-a-', 1",
        "expected_output": "'A-A-A-A'"
      },
      {
        "input": "'---', 3",
        "expected_output": "''"
      },
      {
        "input": "'2', 2",
        "expected_output": "'2'"
      },
      {
        "input": "'r', 1",
        "expected_output": "'R'"
      },
      {
        "input": "'5F3Z-2e-9-w-a-b-c-d', 4",
        "expected_output": "'5F3Z-2E9W-ABCD'"
      },
      {
        "input": "'2-5g-3-J-k-L', 3",
        "expected_output": "'2-5G3-JKL'"
      },
      {
        "input": "'a-b-c', 3",
        "expected_output": "'ABC'"
      },
      {
        "input": "'12345', 1",
        "expected_output": "'1-2-3-4-5'"
      },
      {
        "input": "'ABCD', 2",
        "expected_output": "'AB-CD'"
      },
      {
        "input": "'a-1-B-2', 2",
        "expected_output": "'A1-B2'"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\n        ",
      "java": "class Solution {\n    public String licenseKeyFormatting(String s, int k) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    string licenseKeyFormatting(string s, int k) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == eval(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asString() == expected.asString();"
    },
    "explanation": "https://www.youtube.com/watch?v=3KMlpe8eZ0E&pp=ygUfTmVldENvZGUgTGljZW5zZSBLZXkgRm9ybWF0dGluZw%3D%3D",
    "method_name": "licenseKeyFormatting"
  },
  {
    "title": "Construct the Rectangle",
    "source": "https://leetcode.com/problems/construct-the-rectangle/",
    "description": "Solve the problem titled \"Construct the Rectangle\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "4",
        "expected_output": "[2,2]"
      },
      {
        "input": "37",
        "expected_output": "[37,1]"
      },
      {
        "input": "122122",
        "expected_output": "[427,286]"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "1",
        "expected_output": "[1,1]"
      },
      {
        "input": "9",
        "expected_output": "[3,3]"
      },
      {
        "input": "16",
        "expected_output": "[4,4]"
      },
      {
        "input": "24",
        "expected_output": "[6,4]"
      },
      {
        "input": "100",
        "expected_output": "[10,10]"
      },
      {
        "input": "1000",
        "expected_output": "[40,25]"
      },
      {
        "input": "10000",
        "expected_output": "[100,100]"
      },
      {
        "input": "99999",
        "expected_output": "[369,271]"
      },
      {
        "input": "1000000",
        "expected_output": "[1000,1000]"
      },
      {
        "input": "9999999",
        "expected_output": "[4649,2151]"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def constructRectangle(self, area: int) -> List[int]:\n        ",
      "java": "class Solution {\n    public int[] constructRectangle(int area) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    vector<int> constructRectangle(int area) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "expected = eval(expected); return result[0]*result[1] == expected[0]*expected[1] and result[0] >= result[1] and abs(result[0]-result[1]) <= abs(expected[0]-expected[1])",
      "java": "if (result == null && expected == null) return true;\n    if (result == null || expected == null) return false;\n    try {\n        int[] r = (int[])result;\n        int[] e = (int[])expected;\n        return r.length == e.length && Arrays.equals(r, e);\n    } catch (ClassCastException ex) {\n        return false;\n    }",
      "cpp": "if (!result.isArray() ||!expected.isArray()) {\n        return false;\n    }\n\n    if (result.size()!= expected.size() || result.size()!= 2) {\n        return false;\n    }\n\n    std::vector<int> resultVec;\n    std::vector<int> expectedVec;\n\n    for (const auto& val: result) {\n        if (!val.isInt()) return false;\n        resultVec.push_back(val.asInt());\n    }\n\n    for (const auto& val: expected) {\n        if (!val.isInt()) return false;\n        expectedVec.push_back(val.asInt());\n    }\n\n    std::sort(resultVec.begin(), resultVec.end());\n    std::sort(expectedVec.begin(), expectedVec.end());\n\n    return resultVec == expectedVec;"
    },
    "explanation": "https://www.youtube.com/watch?v=-Lb4SvVyPCM&pp=ygUgTmVldENvZGUgQ29uc3RydWN0IHRoZSBSZWN0YW5nbGU%3D",
    "method_name": "constructRectangle"
  },
  {
    "title": "Teemo Attacking",
    "source": "https://leetcode.com/problems/teemo-attacking/",
    "description": "Solve the problem titled \"Teemo Attacking\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "[1,4], 2",
        "expected_output": "4"
      },
      {
        "input": "[1,2], 2",
        "expected_output": "3"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[1], 1",
        "expected_output": "1"
      },
      {
        "input": "[1,2,3,4,5], 1",
        "expected_output": "5"
      },
      {
        "input": "[1,3,5,7,9], 3",
        "expected_output": "11"
      },
      {
        "input": "[1,2,3,4,5], 5",
        "expected_output": "9"
      },
      {
        "input": "[1,10,20,30], 5",
        "expected_output": "20"
      },
      {
        "input": "[1,2,3,100], 2",
        "expected_output": "6"
      },
      {
        "input": "[1,1,1,1], 2",
        "expected_output": "2"
      },
      {
        "input": "[0,1,2], 1",
        "expected_output": "3"
      },
      {
        "input": "[1,5,10], 2",
        "expected_output": "6"
      },
      {
        "input": "[1,3], 3",
        "expected_output": "5"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n        ",
      "java": "class Solution {\n    public int findPoisonedDuration(int[] timeSeries, int duration) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int findPoisonedDuration(vector<int>& timeSeries, int duration) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return int(result) == int(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return std::stoi(result.asString()) == std::stoi(expected.asString());"
    },
    "explanation": "https://www.youtube.com/watch?v=NejSCTIdd5k&pp=ygUYTmVldENvZGUgVGVlbW8gQXR0YWNraW5n",
    "method_name": "findPoisonedDuration"
  },
  {
    "title": "Base 7",
    "source": "https://leetcode.com/problems/base-7/",
    "description": "Solve the problem titled \"Base 7\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "100",
        "expected_output": "'202'"
      },
      {
        "input": "-7",
        "expected_output": "'-10'"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "0",
        "expected_output": "'0'"
      },
      {
        "input": "7",
        "expected_output": "'10'"
      },
      {
        "input": "-49",
        "expected_output": "'-100'"
      },
      {
        "input": "1000000",
        "expected_output": "'11333311'"
      },
      {
        "input": "-1000000",
        "expected_output": "'-11333311'"
      },
      {
        "input": "1",
        "expected_output": "'1'"
      },
      {
        "input": "-1",
        "expected_output": "'-1'"
      },
      {
        "input": "49",
        "expected_output": "'100'"
      },
      {
        "input": "999999",
        "expected_output": "'11333310'"
      },
      {
        "input": "-999999",
        "expected_output": "'-11333310'"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def convertToBase7(self, num: int) -> str:\n        ",
      "java": "class Solution {\n    public String convertToBase7(int num) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    string convertToBase7(int num) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == eval(expected)",
      "java": "return result.equals(expected);",
      "cpp": "try {\n    return result.asString() == expected.asString();\n} catch(const std::exception &e) {\n    return false;\n}"
    },
    "explanation": "https://www.youtube.com/watch?v=sbmq-efwOsA&pp=ygUPTmVldENvZGUgQmFzZSA3",
    "method_name": "convertToBase7"
  },
  {
    "title": "Perfect Number",
    "source": "https://leetcode.com/problems/perfect-number/",
    "description": "Solve the problem titled \"Perfect Number\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "easy",
    "sample_test_cases": [
      {
        "input": "28",
        "expected_output": "true"
      },
      {
        "input": "7",
        "expected_output": "false"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "1",
        "expected_output": "false"
      },
      {
        "input": "6",
        "expected_output": "true"
      },
      {
        "input": "496",
        "expected_output": "true"
      },
      {
        "input": "8128",
        "expected_output": "true"
      },
      {
        "input": "33550336",
        "expected_output": "true"
      },
      {
        "input": "12",
        "expected_output": "false"
      },
      {
        "input": "100",
        "expected_output": "false"
      },
      {
        "input": "1000",
        "expected_output": "false"
      },
      {
        "input": "10000",
        "expected_output": "false"
      },
      {
        "input": "100000",
        "expected_output": "false"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def checkPerfectNumber(self, num: int) -> bool:\n        ",
      "java": "class Solution {\n    public boolean checkPerfectNumber(int num) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    bool checkPerfectNumber(int num) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result).lower() == expected.lower()",
      "java": "return result.equals(expected);",
      "cpp": "return result.asBool() == expected.asBool();"
    },
    "explanation": "https://www.youtube.com/watch?v=HLZLwjzIVGo&pp=ygUXTmVldENvZGUgUGVyZmVjdCBOdW1iZXI%3D",
    "method_name": "checkPerfectNumber"
  },
  {
    "title": "Zigzag Conversion",
    "source": "https://leetcode.com/problems/zigzag-conversion/",
    "description": "Given a string `s` and an integer `numRows`, arrange the characters of the string in a zigzag pattern on a given number of rows and then read the pattern row by row. Return the final string.\n\nExample: Input: s = \"PAYPALISHIRING\", numRows = 3\nZigzag Pattern:\nP   A   H   N\nA P L S I I G\nY   I   R\nOutput: \"PAHNAPLSIIGYIR\"",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "'PAYPALISHIRING', 3",
        "expected_output": "'PAHNAPLSIIGYIR'"
      },
      {
        "input": "'PAYPALISHIRING', 4",
        "expected_output": "'PINALSIGYAHRPI'"
      },
      {
        "input": "'A', 1",
        "expected_output": "'A'"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "'ABCDEF', 2",
        "expected_output": "'ACEBDF'"
      },
      {
        "input": "'HELLO', 1",
        "expected_output": "'HELLO'"
      },
      {
        "input": "'WORLD', 5",
        "expected_output": "'WORLD'"
      },
      {
        "input": "'TEST.TEST', 3",
        "expected_output": "'T.TETTSSE'"
      },
      {
        "input": "'A,B,C', 2",
        "expected_output": "'ABC,,'"
      },
      {
        "input": "'abcdefghijklmnop', 4",
        "expected_output": "'agmbfhlnceikodjp'"
      },
      {
        "input": "'ANTHROPIC', 3",
        "expected_output": "'ARCNHOITP'"
      },
      {
        "input": "'Testing123', 2",
        "expected_output": "'Tsig2etn13'"
      },
      {
        "input": "'', 1",
        "expected_output": "''"
      },
      {
        "input": "'AB', 1",
        "expected_output": "'AB'"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        ",
      "java": "class Solution {\n    public String convert(String s, int numRows) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    string convert(string s, int numRows) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == eval(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asString() == expected.asString();"
    },
    "explanation": "https://www.youtube.com/watch?v=Q2Tw6gcVEwc&pp=ygUaTmVldENvZGUgWmlnemFnIENvbnZlcnNpb24%3D",
    "method_name": "convert"
  },
  {
    "title": "Container With Most Water",
    "source": "https://leetcode.com/problems/container-with-most-water/",
    "description": "You are given an array `height` of length `n`. Each value represents the height of a vertical line at that position. Choose two lines that, together with the x-axis, form a container that can hold the most water. Return the maximum amount of water a container can store.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "[1,8,6,2,5,4,8,3,7]",
        "expected_output": "49"
      },
      {
        "input": "[1,1]",
        "expected_output": "1"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[4,3,2,1,4]",
        "expected_output": "16"
      },
      {
        "input": "[1,2,4,3]",
        "expected_output": "4"
      },
      {
        "input": "[1,2]",
        "expected_output": "1"
      },
      {
        "input": "[1,1,1]",
        "expected_output": "2"
      },
      {
        "input": "[2,3,4,5,18,17,6]",
        "expected_output": "17"
      },
      {
        "input": "[1,8,100,2,100,4,8,3,7]",
        "expected_output": "200"
      },
      {
        "input": "[1,2,3,4,5,6]",
        "expected_output": "9"
      },
      {
        "input": "[6,5,4,3,2,1]",
        "expected_output": "9"
      },
      {
        "input": "[0,0]",
        "expected_output": "0"
      },
      {
        "input": "[10000,1]",
        "expected_output": "1"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        ",
      "java": "class Solution {\n    public int maxArea(int[] height) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == int(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asInt() == expected.asInt();"
    },
    "explanation": "https://www.youtube.com/watch?v=UuiTKBwPgAo&pp=ygUiTmVldENvZGUgQ29udGFpbmVyIFdpdGggTW9zdCBXYXRlcg%3D%3D",
    "method_name": "maxArea"
  },
  {
    "title": "3Sum Closest",
    "source": "https://leetcode.com/problems/3sum-closest/",
    "description": "Given an array `nums` of `n` integers and an integer `target`, find three integers in `nums` such that the sum is closest to `target`. Return the sum of the three integers. Assume that each input would have exactly one solution.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "[-1,2,1,-4], 1",
        "expected_output": "2"
      },
      {
        "input": "[0,0,0], 1",
        "expected_output": "0"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[1,1,1,0], 100",
        "expected_output": "3"
      },
      {
        "input": "[-1,0,1,2,3], 1",
        "expected_output": "1"
      },
      {
        "input": "[0,0,0,0], 1",
        "expected_output": "0"
      },
      {
        "input": "[-5,-4,-3,-2,-1], 0",
        "expected_output": "-6"
      },
      {
        "input": "[1,2,3,4,5], 10",
        "expected_output": "10"
      },
      {
        "input": "[-1,-2,-3,1,2,3], 0",
        "expected_output": "0"
      },
      {
        "input": "[1,1,-1,-1,3], -1",
        "expected_output": "-1"
      },
      {
        "input": "[-100,-50,0,50,100], 23",
        "expected_output": "0"
      },
      {
        "input": "[-1,2,1,-4,3,-3], 0",
        "expected_output": "0"
      },
      {
        "input": "[-1000,1000,1000], 100",
        "expected_output": "1000"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        ",
      "java": "class Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == int(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asInt() == expected.asInt();"
    },
    "explanation": "https://www.youtube.com/watch?v=PXWT4wzkA6M&pp=ygUVTmVldENvZGUgM1N1bSBDbG9zZXN0",
    "method_name": "threeSumClosest"
  },
  {
    "title": "Search in Rotated Sorted Array",
    "source": "https://leetcode.com/problems/search-in-rotated-sorted-array/",
    "description": "You are given an integer array `nums` sorted in ascending order (possibly rotated) and an integer `target`. Search `nums` to find if `target` exists and return its index. If it does not exist, return -1. The array does not contain duplicates and has O(log n) time complexity.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "[4,5,6,7,0,1,2], 0",
        "expected_output": "4"
      },
      {
        "input": "[4,5,6,7,0,1,2], 3",
        "expected_output": "-1"
      },
      {
        "input": "[1], 0",
        "expected_output": "-1"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[3,1], 1",
        "expected_output": "1"
      },
      {
        "input": "[1,3,5], 3",
        "expected_output": "1"
      },
      {
        "input": "[5,1,2,3,4], 1",
        "expected_output": "1"
      },
      {
        "input": "[4,5,6,7,0,1,2], 5",
        "expected_output": "1"
      },
      {
        "input": "[1], 1",
        "expected_output": "0"
      },
      {
        "input": "[1,3], 3",
        "expected_output": "1"
      },
      {
        "input": "[3,5,1], 3",
        "expected_output": "0"
      },
      {
        "input": "[5,1,3], 5",
        "expected_output": "0"
      },
      {
        "input": "[4,5,6,7,8,1,2,3], 8",
        "expected_output": "4"
      },
      {
        "input": "[1,2,3,4,5], 6",
        "expected_output": "-1"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        ",
      "java": "class Solution {\n    public int search(int[] nums, int target) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == int(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asInt() == expected.asInt();"
    },
    "explanation": "https://www.youtube.com/watch?v=U8XENwh8Oy8&pp=ygUnTmVldENvZGUgU2VhcmNoIGluIFJvdGF0ZWQgU29ydGVkIEFycmF5",
    "method_name": "search"
  },
  {
    "title": "Find First and Last Position of Element in Sorted Array",
    "source": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/",
    "description": "Given an array of integers `nums` sorted in non-decreasing order, find the starting and ending position of a given target value. If the target is not found in the array, return [-1, -1].",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "[5,7,7,8,8,10], 8",
        "expected_output": "[3,4]"
      },
      {
        "input": "[5,7,7,8,8,10], 6",
        "expected_output": "[-1,-1]"
      },
      {
        "input": "[], 0",
        "expected_output": "[-1,-1]"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[1], 1",
        "expected_output": "[0,0]"
      },
      {
        "input": "[1,1,1,1], 1",
        "expected_output": "[0,3]"
      },
      {
        "input": "[1,2,3,4,5], 3",
        "expected_output": "[2,2]"
      },
      {
        "input": "[1,2,2,3,4,4,4], 4",
        "expected_output": "[4,6]"
      },
      {
        "input": "[1,1,2], 2",
        "expected_output": "[2,2]"
      },
      {
        "input": "[1], 2",
        "expected_output": "[-1,-1]"
      },
      {
        "input": "[1,2,3], 4",
        "expected_output": "[-1,-1]"
      },
      {
        "input": "[1,1,1,2,2,3], 2",
        "expected_output": "[3,4]"
      },
      {
        "input": "[1,2,3,3,3,4,5], 3",
        "expected_output": "[2,4]"
      },
      {
        "input": "[1,2,3,4,5,5,5,5,6], 5",
        "expected_output": "[4,7]"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        ",
      "java": "class Solution {\n    public int[] searchRange(int[] nums, int target) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == eval(expected)",
      "java": "if (result == null && expected == null) {\n            return true;\n        }\n        if (result == null || expected == null) {\n            return false;\n        }\n        if (result.getClass().isArray() && expected.getClass().isArray()) {\n            int[] arr1 = (int[]) result;\n            int[] arr2 = (int[]) expected;\n            if (arr1.length != arr2.length) {\n                return false;\n            }\n            for (int i = 0; i < arr1.length; i++) {\n                if (arr1[i] != arr2[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return result.equals(expected);",
      "cpp": "if (result.isArray() && expected.isString()) {\n    // Convert expected string to a vector of integers\n    std::string expectedStr = expected.asString();\n    std::regex re(\"\\\\((-?\\\\d+),\\\\s*(-?\\\\d+)\\\\)\");\n    std::smatch match;\n    if (std::regex_search(expectedStr, match, re)) {\n        std::vector<int> expectedVec = {std::stoi(match[1]), std::stoi(match[2])};\n        // Convert result JSON array to a vector of integers\n        std::vector<int> resultVec;\n        for (const auto& elem : result) {\n            resultVec.push_back(elem.asInt());\n        }\n        // Compare the vectors\n        return resultVec == expectedVec;\n    }\n}\nreturn false;"
    },
    "explanation": "https://www.youtube.com/watch?v=4sQL7R5ySUU&pp=ygVATmVldENvZGUgRmluZCBGaXJzdCBhbmQgTGFzdCBQb3NpdGlvbiBvZiBFbGVtZW50IGluIFNvcnRlZCBBcnJheQ%3D%3D",
    "method_name": "searchRange"
  },
  {
    "title": "Count and Say",
    "source": "https://leetcode.com/problems/count-and-say/",
    "description": "The count-and-say sequence is a sequence of digit strings defined as follows:\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\nGiven an integer `n`, return the `n`th term of the count-and-say sequence.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "4",
        "expected_output": "'1211'"
      },
      {
        "input": "1",
        "expected_output": "'1'"
      },
      {
        "input": "5",
        "expected_output": "'111221'"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "2",
        "expected_output": "'11'"
      },
      {
        "input": "3",
        "expected_output": "'21'"
      },
      {
        "input": "6",
        "expected_output": "'312211'"
      },
      {
        "input": "7",
        "expected_output": "'13112221'"
      },
      {
        "input": "8",
        "expected_output": "'1113213211'"
      },
      {
        "input": "9",
        "expected_output": "'31131211131221'"
      },
      {
        "input": "10",
        "expected_output": "'13211311123113112211'"
      },
      {
        "input": "15",
        "expected_output": "'311311222113111231131112132112311321322112111312211312111322212311322113212221'"
      },
      {
        "input": "20",
        "expected_output": "'11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211'"
      },
      {
        "input": "30",
        "expected_output": "'3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211'"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def countAndSay(self, n: int) -> str:\n        ",
      "java": "class Solution {\n    public String countAndSay(int n) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    string countAndSay(int n) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == eval(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asString() == expected.asString();"
    },
    "explanation": "https://www.youtube.com/watch?v=iP4RH2zespg&pp=ygUWTmVldENvZGUgQ291bnQgYW5kIFNheQ%3D%3D",
    "method_name": "countAndSay"
  },
  {
    "title": "Combination Sum II",
    "source": "https://leetcode.com/problems/combination-sum-ii/",
    "description": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in `candidates` where the candidate numbers sum to `target`. Each number in `candidates` may only be used once in the combination. The solution set must not contain duplicate combinations.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "[10,1,2,7,6,1,5], 8",
        "expected_output": "[[1,1,6],[1,2,5],[1,7],[2,6]]"
      },
      {
        "input": "[2,5,2,1,2], 5",
        "expected_output": "[[1,2,2],[5]]"
      },
      {
        "input": "[1,1,1,1,1,1,1], 3",
        "expected_output": "[[1,1,1]]"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[1], 1",
        "expected_output": "[[1]]"
      },
      {
        "input": "[1,2,3], 6",
        "expected_output": "[[1,2,3]]"
      },
      {
        "input": "[1,1,1,2,2], 3",
        "expected_output": "[[1,1,1],[1,2]]"
      },
      {
        "input": "[10,20,30,40,50], 60",
        "expected_output": "[[10,20,30],[10,50],[20,40]]"
      },
      {
        "input": "[2,2,2,2,2], 4",
        "expected_output": "[[2,2]]"
      },
      {
        "input": "[1,2,3,4,5], 10",
        "expected_output": "[[1,2,3,4],[1,4,5],[2,3,5]]"
      },
      {
        "input": "[1,1,1,1,1,1,1,1,1,1], 5",
        "expected_output": "[[1,1,1,1,1]]"
      },
      {
        "input": "[5,4,3,2,1], 8",
        "expected_output": "[[1,2,5],[1,3,4],[3,5]]"
      },
      {
        "input": "[10,1,2,7,6,1,5], 9",
        "expected_output": "[[1,1,2,5],[1,1,7],[1,2,6],[2,7]]"
      },
      {
        "input": "[1,2,2,2,2,2,3], 7",
        "expected_output": "[[1,2,2,2],[2,2,3]]"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        ",
      "java": "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int \ntarget) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int \ntarget) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return sorted([sorted(x) for x in result]) == eval(expected)",
      "java": "if (result == null && expected == null) {\n            return true;\n        }\n        if (result == null || expected == null) {\n            return false;\n        }\n\n        if (result instanceof List<?> && expected instanceof List<?>) {\n            List<?> list1 = (List<?>) result;\n            List<?> list2 = (List<?>) expected;\n\n            if (list1.size() != list2.size()) {\n                return false;\n            }\n\n            // More robust comparison for nested lists and different element types\n            for (int i = 0; i < list1.size(); i++) {\n                \n                System.out.println(\"Type of list1.get(i): \" + list1.get(i).getClass().getName());\n                System.out.println(\"Type of list2.get(i): \" + list2.get(i).getClass().getName());\n                if (!compare(list1.get(i), list2.get(i))) { // Recursive call\n                    return false;\n                }\n            }\n            return true; // Lists are equal if all elements are equal\n        } else if (result instanceof Integer && expected instanceof String) {\n            Integer intResult = (Integer) result;\n            String strExpected = (String) expected;\n            return intResult.toString().equals(strExpected);\n        } else if (result instanceof String && expected instanceof Integer) {\n            return compare(expected, result);\n        }\n\n        // Handle other types (including primitive wrappers) directly\n        return result.equals(expected);",
      "cpp": "if (!result.isArray() ||!expected.isArray()) {\n        return false; // Both must be arrays\n    }\n\n    if (result.size()!= expected.size()) {\n        return false;\n    }\n\n    std::vector<std::vector<int>> resultVec;\n    std::vector<std::vector<int>> expectedVec;\n\n    for (const auto& val: result) {\n        if (!val.isArray()) return false;\n        std::vector<int> innerVec;\n        for (const auto& innerVal: val) {\n            if (!innerVal.isInt()) return false;\n            innerVec.push_back(innerVal.asInt());\n        }\n        std::sort(innerVec.begin(), innerVec.end()); // Sort inner vectors\n        resultVec.push_back(innerVec);\n    }\n\n    for (const auto& val: expected) {\n        if (!val.isArray()) return false;\n        std::vector<int> innerVec;\n        for (const auto& innerVal: val) {\n            if (!innerVal.isInt()) return false;\n            innerVec.push_back(innerVal.asInt());\n        }\n        std::sort(innerVec.begin(), innerVec.end()); // Sort inner vectors\n        expectedVec.push_back(innerVec);\n    }\n\n    // Sort the outer vectors (important for comparing sets of combinations)\n    std::sort(resultVec.begin(), resultVec.end());\n    std::sort(expectedVec.begin(), expectedVec.end());\n\n    return resultVec == expectedVec;"
    },
    "explanation": "https://www.youtube.com/watch?v=FOyRpNUSFeA&pp=ygUbTmVldENvZGUgQ29tYmluYXRpb24gU3VtIElJ",
    "method_name": "combinationSum2"
  },
  {
    "title": "Multiply Strings",
    "source": "https://leetcode.com/problems/multiply-strings/",
    "description": "Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string. You must not use built-in big integer libraries or convert the inputs directly to integers.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "\"2\", \"3\"",
        "expected_output": "'6'"
      },
      {
        "input": "\"123\", \"456\"",
        "expected_output": "'56088'"
      },
      {
        "input": "\"9999\", \"9999\"",
        "expected_output": "'99980001'"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "\"0\", \"0\"",
        "expected_output": "'0'"
      },
      {
        "input": "\"1\", \"1\"",
        "expected_output": "'1'"
      },
      {
        "input": "\"999\", \"999\"",
        "expected_output": "'998001'"
      },
      {
        "input": "\"1234\", \"5678\"",
        "expected_output": "'7006652'"
      },
      {
        "input": "\"99999\", \"99999\"",
        "expected_output": "'9999800001'"
      },
      {
        "input": "\"123456789\", \"987654321\"",
        "expected_output": "'121932631112635269'"
      },
      {
        "input": "\"1000000\", \"1000000\"",
        "expected_output": "'1000000000000'"
      },
      {
        "input": "\"11111111\", \"11111111\"",
        "expected_output": "'123456787654321'"
      },
      {
        "input": "\"12345678901234567890\", \"12345678901234567890\"",
        "expected_output": "'152415787532388367501905199875019052100'"
      },
      {
        "input": "\"0\", \"1234567890\"",
        "expected_output": "'0'"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        ",
      "java": "class Solution {\n    public String multiply(String num1, String num2) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == eval(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asString() == expected.asString();"
    },
    "explanation": "https://www.youtube.com/watch?v=1vZswirL8Y8&pp=ygUZTmVldENvZGUgTXVsdGlwbHkgU3RyaW5ncw%3D%3D",
    "method_name": "multiply"
  },
  {
    "title": "Jump Game II",
    "source": "https://leetcode.com/problems/jump-game-ii/",
    "description": "Given an array of non-negative integers `nums`, where each element represents your maximum jump length at that position, return the minimum number of jumps needed to reach the last index. You can assume that you can always reach the last index.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "[2,3,1,1,4]",
        "expected_output": "2"
      },
      {
        "input": "[2,3,0,1,4]",
        "expected_output": "2"
      },
      {
        "input": "[1,2,3,4,5]",
        "expected_output": "3"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[1]",
        "expected_output": "0"
      },
      {
        "input": "[2,1]",
        "expected_output": "1"
      },
      {
        "input": "[1,1,1,1]",
        "expected_output": "3"
      },
      {
        "input": "[3,2,1]",
        "expected_output": "1"
      },
      {
        "input": "[1,2,1,1,1]",
        "expected_output": "3"
      },
      {
        "input": "[5,9,3,2,1,0,2,3,3,1,0,0]",
        "expected_output": "3"
      },
      {
        "input": "[1,2,3,4,5]",
        "expected_output": "3"
      },
      {
        "input": "[4,1,1,3,1,1,1]",
        "expected_output": "2"
      },
      {
        "input": "[1,1,1,1,1,1,1,1,1,1]",
        "expected_output": "9"
      },
      {
        "input": "[10,9,8,7,6,5,4,3,2,1]",
        "expected_output": "1"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        ",
      "java": "class Solution {\n    public int jump(int[] nums) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int jump(vector<int>& nums) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result) == expected",
      "java": "return result.equals(expected);",
      "cpp": "return std::to_string(result.asInt()) == expected.asString();"
    },
    "explanation": "https://www.youtube.com/watch?v=dJ7sWiOoK7g&pp=ygUVTmVldENvZGUgSnVtcCBHYW1lIElJ",
    "method_name": "jump"
  },
  {
    "title": "Maximum Subarray",
    "source": "https://leetcode.com/problems/maximum-subarray/",
    "description": "Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "[-2,1,-3,4,-1,2,1,-5,4]",
        "expected_output": "6"
      },
      {
        "input": "[1]",
        "expected_output": "1"
      },
      {
        "input": "[5,4,-1,7,8]",
        "expected_output": "23"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[-1]",
        "expected_output": "-1"
      },
      {
        "input": "[-2,-1]",
        "expected_output": "-1"
      },
      {
        "input": "[1,2,3,4,5]",
        "expected_output": "15"
      },
      {
        "input": "[-1,-2,-3,-4,-5]",
        "expected_output": "-1"
      },
      {
        "input": "[1,-1,1,-1,1,-1]",
        "expected_output": "1"
      },
      {
        "input": "[-2,1,-3,4,-1,2,1,-5,4]",
        "expected_output": "6"
      },
      {
        "input": "[0,0,0,0]",
        "expected_output": "0"
      },
      {
        "input": "[-1,0,-2,2]",
        "expected_output": "2"
      },
      {
        "input": "[1,-2,3,-4,5,-6,7,-8]",
        "expected_output": "7"
      },
      {
        "input": "[-1,-1,2,-1,-1]",
        "expected_output": "2"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        ",
      "java": "class Solution {\n    public int maxSubArray(int[] nums) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result) == expected",
      "java": "return result.equals(expected);",
      "cpp": "return std::to_string(result.asInt()) == expected.asString();"
    },
    "explanation": "https://www.youtube.com/watch?v=5WZl3MMT0Eg&pp=ygUZTmVldENvZGUgTWF4aW11bSBTdWJhcnJheQ%3D%3D",
    "method_name": "maxSubArray"
  },
  {
    "title": "Spiral Matrix",
    "source": "https://leetcode.com/problems/spiral-matrix/",
    "description": "Given an `m x n` matrix, return all elements of the matrix in spiral order starting from the top-left corner.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "[[1,2,3],[4,5,6],[7,8,9]]",
        "expected_output": "[1,2,3,6,9,8,7,4,5]"
      },
      {
        "input": "[[1,2,3,4],[5,6,7,8],[9,10,11,12]]",
        "expected_output": "[1,2,3,4,8,12,11,10,9,5,6,7]"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[[1]]",
        "expected_output": "[1]"
      },
      {
        "input": "[[1,2],[3,4]]",
        "expected_output": "[1,2,4,3]"
      },
      {
        "input": "[[1,2,3]]",
        "expected_output": "[1,2,3]"
      },
      {
        "input": "[[1],[2],[3]]",
        "expected_output": "[1,2,3]"
      },
      {
        "input": "[[1,2,3,4],[5,6,7,8]]",
        "expected_output": "[1,2,3,4,8,7,6,5]"
      },
      {
        "input": "[[1,2],[3,4],[5,6]]",
        "expected_output": "[1,2,4,6,5,3]"
      },
      {
        "input": "[[]]",
        "expected_output": "[]"
      },
      {
        "input": "[]",
        "expected_output": "[]"
      },
      {
        "input": "[[1,2,3],[4,5,6]]",
        "expected_output": "[1,2,3,6,5,4]"
      },
      {
        "input": "[[1,2],[3,4],[5,6],[7,8]]",
        "expected_output": "[1,2,4,6,8,7,5,3]"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        ",
      "java": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result) == expected",
      "java": "return result.equals(expected);",
      "cpp": "std::vector<int> resultVec = jsonToValue<std::vector<int>>(result);\nstd::vector<int> expectedVec = jsonToValue<std::vector<int>>(expected);\nreturn resultVec == expectedVec;"
    },
    "explanation": "https://www.youtube.com/watch?v=BJnMZNwUk1M&pp=ygUWTmVldENvZGUgU3BpcmFsIE1hdHJpeA%3D%3D",
    "method_name": "spiralOrder"
  },
  {
    "title": "Merge Intervals",
    "source": "https://leetcode.com/problems/merge-intervals/",
    "description": "Given an array of intervals where `intervals[i] = [start_i, end_i]`, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "[[1,3],[2,6],[8,10],[15,18]]",
        "expected_output": "[[1,6],[8,10],[15,18]]"
      },
      {
        "input": "[[1,4],[4,5]]",
        "expected_output": "[[1,5]]"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[[1,4],[0,4]]",
        "expected_output": "[[0,4]]"
      },
      {
        "input": "[[1,4],[2,3]]",
        "expected_output": "[[1,4]]"
      },
      {
        "input": "[[1,4],[0,0]]",
        "expected_output": "[[0,0],[1,4]]"
      },
      {
        "input": "[[1,4]]",
        "expected_output": "[[1,4]]"
      },
      {
        "input": "[[1,4],[5,6]]",
        "expected_output": "[[1,4],[5,6]]"
      },
      {
        "input": "[[1,10],[2,3],[4,5],[6,7],[8,9]]",
        "expected_output": "[[1,10]]"
      },
      {
        "input": "[[1,2],[2,3],[3,4],[4,5]]",
        "expected_output": "[[1,5]]"
      },
      {
        "input": "[[1,5],[2,3]]",
        "expected_output": "[[1,5]]"
      },
      {
        "input": "[[1,4],[1,5]]",
        "expected_output": "[[1,5]]"
      },
      {
        "input": "[[1,4],[4,6],[5,7],[6,8]]",
        "expected_output": "[[1,8]]"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        ",
      "java": "class Solution {\n    public int[][] merge(int[][] intervals) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(sorted(result)) == str(eval(expected))",
      "java": "int[][] resultArray = (int[][]) result;\nint[][] expectedArray = (int[][]) expected;\n\n// Sort both arrays of intervals\nArrays.sort(resultArray, (a, b) -> Integer.compare(a[0], b[0]));\nArrays.sort(expectedArray, (a, b) -> Integer.compare(a[0], b[0]));\n\n// Compare the sorted arrays\nreturn Arrays.deepEquals(resultArray, expectedArray);",
      "cpp": "if (!result.isArray() ||!expected.isArray() || result.size()!= expected.size()) {\n        return false;\n    }\n\n    std::vector<std::vector<int>> resultVec;\n    std::vector<std::vector<int>> expectedVec;\n\n    for (const auto& val: result) {\n        if (!val.isArray() || val.size()!= 2) return false;\n        std::vector<int> innerVec;\n        for (const auto& innerVal: val) {\n            if (!innerVal.isInt()) return false;\n            innerVec.push_back(innerVal.asInt());\n        }\n        resultVec.push_back(innerVec);\n    }\n\n    for (const auto& val: expected) {\n        if (!val.isArray() || val.size()!= 2) return false;\n        std::vector<int> innerVec;\n        for (const auto& innerVal: val) {\n            if (!innerVal.isInt()) return false;\n            innerVec.push_back(innerVal.asInt());\n        }\n        expectedVec.push_back(innerVec);\n    }\n\n    return resultVec == expectedVec;"
    },
    "explanation": "https://www.youtube.com/watch?v=44H3cEC2fFM&pp=ygUYTmVldENvZGUgTWVyZ2UgSW50ZXJ2YWxz",
    "method_name": "merge"
  },
  {
    "title": "Insert Interval",
    "source": "https://leetcode.com/problems/insert-interval/",
    "description": "You are given an array of non-overlapping intervals `intervals` where intervals[i] = [start_i, end_i] represent the start and the end of the i-th interval and `intervals` is sorted in ascending order by start_i. You are also given an interval `newInterval` = [start, end] that represents a new interval. Insert `newInterval` into `intervals` such that the result is still a valid list of non-overlapping intervals in order. Merge overlapping intervals if necessary and return the result.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "[[1,3],[6,9]], [2,5]",
        "expected_output": "[[1,5],[6,9]]"
      },
      {
        "input": "[[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8]",
        "expected_output": "[[1,2],[3,10],[12,16]]"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[], [5,7]",
        "expected_output": "[[5,7]]"
      },
      {
        "input": "[[1,5]], [2,3]",
        "expected_output": "[[1,5]]"
      },
      {
        "input": "[[1,5]], [2,7]",
        "expected_output": "[[1,7]]"
      },
      {
        "input": "[[1,5]], [6,8]",
        "expected_output": "[[1,5],[6,8]]"
      },
      {
        "input": "[[1,5]], [0,3]",
        "expected_output": "[[0,5]]"
      },
      {
        "input": "[[3,5],[12,15]], [6,6]",
        "expected_output": "[[3,5],[6,6],[12,15]]"
      },
      {
        "input": "[[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8]",
        "expected_output": "[[1,2],[3,10],[12,16]]"
      },
      {
        "input": "[[1,5]], [0,0]",
        "expected_output": "[[0,0],[1,5]]"
      },
      {
        "input": "[[3,5],[12,15]], [1,2]",
        "expected_output": "[[1,2],[3,5],[12,15]]"
      },
      {
        "input": "[[1,5],[6,7]], [0,8]",
        "expected_output": "[[0,8]]"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        ",
      "java": "class Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& \nnewInterval) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(sorted(result)) == str(eval(expected))",
      "java": "if (result == null && expected == null) {\n            return true;\n        }\n        if (result == null || expected == null) {\n            return false;\n        }\n\n        if (result instanceof int[][] && expected instanceof int[][]) {\n            int[][] arr1 = (int[][]) result;\n            int[][] arr2 = (int[][]) expected;\n\n            if (arr1.length != arr2.length) {\n                return false;\n            }\n\n            for (int i = 0; i < arr1.length; i++) {\n                if (!Arrays.equals(arr1[i], arr2[i])) { // Correct comparison for int[]\n                    return false;\n                }\n            }\n            return true;\n        }\n        return result.equals(expected);",
      "cpp": "if (!result.isArray() ||!expected.isArray() || result.size()!= expected.size()) {\n        return false;\n    }\n\n    std::vector<std::vector<int>> resultVec;\n    std::vector<std::vector<int>> expectedVec;\n\n    for (const auto& val: result) {\n        if (!val.isArray() || val.size()!= 2) return false;\n        std::vector<int> innerVec;\n        for (const auto& innerVal: val) {\n            if (!innerVal.isInt()) return false;\n            innerVec.push_back(innerVal.asInt());\n        }\n        resultVec.push_back(innerVec);\n    }\n\n    for (const auto& val: expected) {\n        if (!val.isArray() || val.size()!= 2) return false;\n        std::vector<int> innerVec;\n        for (const auto& innerVal: val) {\n            if (!innerVal.isInt()) return false;\n            innerVec.push_back(innerVal.asInt());\n        }\n        expectedVec.push_back(innerVec);\n    }\n\n    return resultVec == expectedVec;"
    },
    "explanation": "https://www.youtube.com/watch?v=A8NUOmlwOlM&pp=ygUYTmVldENvZGUgSW5zZXJ0IEludGVydmFs",
    "method_name": "insert"
  },
  {
    "title": "Unique Paths II",
    "source": "https://leetcode.com/problems/unique-paths-ii/",
    "description": "Solve the problem titled \"Unique Paths II\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "[[0,0,0],[0,1,0],[0,0,0]]",
        "expected_output": "2"
      },
      {
        "input": "[[0,1],[0,0]]",
        "expected_output": "1"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[[0]]",
        "expected_output": "1"
      },
      {
        "input": "[[1]]",
        "expected_output": "0"
      },
      {
        "input": "[[0,0],[0,1]]",
        "expected_output": "0"
      },
      {
        "input": "[[0,0],[1,0]]",
        "expected_output": "1"
      },
      {
        "input": "[[0,0,0]]",
        "expected_output": "1"
      },
      {
        "input": "[[0],[0],[0]]",
        "expected_output": "1"
      },
      {
        "input": "[[1,0]]",
        "expected_output": "0"
      },
      {
        "input": "[[0,1],[1,0]]",
        "expected_output": "0"
      },
      {
        "input": "[[0,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,0]]",
        "expected_output": "4"
      },
      {
        "input": "[[0,0,0],[0,0,0],[0,0,1]]",
        "expected_output": "0"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        ",
      "java": "class Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result) == expected",
      "java": "return result.equals(expected);",
      "cpp": "return std::to_string(result.asInt()) == expected.asString();"
    },
    "explanation": "https://www.youtube.com/watch?v=d3UOz7zdE4I&pp=ygUYTmVldENvZGUgVW5pcXVlIFBhdGhzIElJ",
    "method_name": "uniquePathsWithObstacles"
  },
  {
    "title": "Simplify Path",
    "source": "https://leetcode.com/problems/simplify-path/",
    "description": "Solve the problem titled \"Simplify Path\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "\"/home/\"",
        "expected_output": "'/home'"
      },
      {
        "input": "\"/home//foo/\"",
        "expected_output": "'/home/foo'"
      },
      {
        "input": "\"/home/user/Documents/../Pictures\"",
        "expected_output": "'/home/user/Pictures'"
      },
      {
        "input": "\"/../\"",
        "expected_output": "'/'"
      },
      {
        "input": "\"/.../a/../b/c/../d/./\"",
        "expected_output": "'/.../b/d'"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "\"/a/./b/../../c/\"",
        "expected_output": "'/c'"
      },
      {
        "input": "\"/home/\"",
        "expected_output": "'/home'"
      },
      {
        "input": "\"/...\"",
        "expected_output": "'/...'"
      },
      {
        "input": "\"/..hidden\"",
        "expected_output": "'/..hidden'"
      },
      {
        "input": "\"//\"",
        "expected_output": "'/'"
      },
      {
        "input": "\"/a//b////c/d//././/..\"",
        "expected_output": "'/a/b/c'"
      },
      {
        "input": "\"/abc/...\"",
        "expected_output": "'/abc/...'"
      },
      {
        "input": "\"/a/./b/./c/./d/\"",
        "expected_output": "'/a/b/c/d'"
      },
      {
        "input": "\"/a/../../b/../c//.//\"",
        "expected_output": "'/c'"
      },
      {
        "input": "\"/a//b//./c/d/\"",
        "expected_output": "'/a/b/c/d'"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        ",
      "java": "class Solution {\n    public String simplifyPath(String path) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    string simplifyPath(string path) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == eval(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asString() == expected.asString();"
    },
    "explanation": "https://www.youtube.com/watch?v=qYlHrAKJfyA&pp=ygUWTmVldENvZGUgU2ltcGxpZnkgUGF0aA%3D%3D",
    "method_name": "simplifyPath"
  },
  {
    "title": "Edit Distance",
    "source": "https://leetcode.com/problems/edit-distance/",
    "description": "Solve the problem titled \"Edit Distance\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "'horse', 'ros'",
        "expected_output": "3"
      },
      {
        "input": "'intention', 'execution'",
        "expected_output": "5"
      },
      {
        "input": "'', 'a'",
        "expected_output": "1"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "'', ''",
        "expected_output": "0"
      },
      {
        "input": "'a', ''",
        "expected_output": "1"
      },
      {
        "input": "'abc', 'abc'",
        "expected_output": "0"
      },
      {
        "input": "'abcde', 'ace'",
        "expected_output": "2"
      },
      {
        "input": "'sea', 'eat'",
        "expected_output": "2"
      },
      {
        "input": "'leetcode', 'practice'",
        "expected_output": "7"
      },
      {
        "input": "'hello', 'world'",
        "expected_output": "4"
      },
      {
        "input": "'pneumonoultramicroscopicsilicovolcanoconiosis', 'ultramicroscopically'",
        "expected_output": "27"
      },
      {
        "input": "'abc', 'def'",
        "expected_output": "3"
      },
      {
        "input": "'aaa', 'bbb'",
        "expected_output": "3"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        ",
      "java": "class Solution {\n    public int minDistance(String word1, String word2) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result) == expected",
      "java": "return result.equals(expected);",
      "cpp": "return std::to_string(result.asInt()) == expected.asString();"
    },
    "explanation": "https://www.youtube.com/watch?v=XYi2-LPrwm4&pp=ygUWTmVldENvZGUgRWRpdCBEaXN0YW5jZQ%3D%3D",
    "method_name": "minDistance"
  },
  {
    "title": "Search a 2D Matrix",
    "source": "https://leetcode.com/problems/search-a-2d-matrix/",
    "description": "Given a matrix, implement an algorithm to solve the problem titled \"Search a 2D Matrix\". The problem involves analyzing or transforming the structure of the matrix. Provide a clear and efficient solution.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "[[1,3,5,7],[10,11,16,20],[23,30,34,60]], 3",
        "expected_output": "true"
      },
      {
        "input": "[[1,3,5,7],[10,11,16,20],[23,30,34,60]], 13",
        "expected_output": "false"
      },
      {
        "input": "[[1]], 1",
        "expected_output": "true"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[[1]], 2",
        "expected_output": "false"
      },
      {
        "input": "[[1,2,3]], 2",
        "expected_output": "true"
      },
      {
        "input": "[[1],[2],[3]], 2",
        "expected_output": "true"
      },
      {
        "input": "[[1,2],[3,4]], 4",
        "expected_output": "true"
      },
      {
        "input": "[[-10,-8],[15,20]], -8",
        "expected_output": "true"
      },
      {
        "input": "[[1,2,3,4],[5,6,7,8]], 6",
        "expected_output": "true"
      },
      {
        "input": "[[1,2,3],[4,5,6],[7,8,9]], 9",
        "expected_output": "true"
      },
      {
        "input": "[[1]], 0",
        "expected_output": "false"
      },
      {
        "input": "[[1,3,5]], 5",
        "expected_output": "true"
      },
      {
        "input": "[[1],[3],[5]], 3",
        "expected_output": "true"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        ",
      "java": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result).lower() == expected.lower()",
      "java": "return result.equals(expected);",
      "cpp": "return result.asBool() == expected.asBool();"
    },
    "explanation": "https://www.youtube.com/watch?v=Ber2pi2C0j0&pp=ygUbTmVldENvZGUgU2VhcmNoIGEgMkQgTWF0cml4",
    "method_name": "searchMatrix"
  },
  {
    "title": "Word Search",
    "source": "https://leetcode.com/problems/word-search/",
    "description": "Solve the problem titled \"Word Search\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "[['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], 'ABCCED'",
        "expected_output": "true"
      },
      {
        "input": "[['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], 'SEE'",
        "expected_output": "true"
      },
      {
        "input": "[['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], 'ABCB'",
        "expected_output": "false"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[['A']], 'A'",
        "expected_output": "true"
      },
      {
        "input": "[['A','B'],['C','D']], 'ABDC'",
        "expected_output": "true"
      },
      {
        "input": "[['A','B']], 'BA'",
        "expected_output": "true"
      },
      {
        "input": "[['A','B','C'],['D','E','F']], 'CBA'",
        "expected_output": "true"
      },
      {
        "input": "[['A']], 'B'",
        "expected_output": "false"
      },
      {
        "input": "[['A','A']], 'AAA'",
        "expected_output": "false"
      },
      {
        "input": "[['A','B','C']], 'ABC'",
        "expected_output": "true"
      },
      {
        "input": "[['A'],['B'],['C']], 'ABC'",
        "expected_output": "true"
      },
      {
        "input": "[['A','B'],['C','D']], 'AC'",
        "expected_output": "true"
      },
      {
        "input": "[['A','B','C'],['D','E','F'],['G','H','I']], 'ABCFIHG'",
        "expected_output": "true"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        ",
      "java": "class Solution {\n    public boolean exist(char[][] board, String word) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result).lower() == expected.lower()",
      "java": "return result.equals(expected);",
      "cpp": "return result.asBool() == expected.asBool();"
    },
    "explanation": "https://www.youtube.com/watch?v=pfiQ_PS1g8E&pp=ygUUTmVldENvZGUgV29yZCBTZWFyY2g%3D",
    "method_name": "exist"
  },
  {
    "title": "Subsets II",
    "source": "https://leetcode.com/problems/subsets-ii/",
    "description": "Solve the problem titled \"Subsets II\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "[1,2,2]",
        "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]"
      },
      {
        "input": "[0]",
        "expected_output": "[[],[0]]"
      },
      {
        "input": "[1,1,1]",
        "expected_output": "[[],[1],[1,1],[1,1,1]]"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[1]",
        "expected_output": "[[],[1]]"
      },
      {
        "input": "[1,2]",
        "expected_output": "[[],[1],[1,2],[2]]"
      },
      {
        "input": "[1,2,3]",
        "expected_output": "[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]"
      },
      {
        "input": "[2,2,2,2]",
        "expected_output": "[[],[2],[2,2],[2,2,2],[2,2,2,2]]"
      },
      {
        "input": "[1,2,2,3]",
        "expected_output": "[[],[1],[1,2],[1,2,2],[1,2,2,3],[1,2,3],[1,3],[2],[2,2],[2,2,3],[2,3],[3]]"
      },
      {
        "input": "[1,1,2,2]",
        "expected_output": "[[],[1],[1,1],[1,1,2],[1,1,2,2],[1,2],[1,2,2],[2],[2,2]]"
      },
      {
        "input": "[3,2,1]",
        "expected_output": "[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]"
      },
      {
        "input": "[-1,0,1]",
        "expected_output": "[[],[-1],[-1,0],[-1,0,1],[-1,1],[0],[0,1],[1]]"
      },
      {
        "input": "[0,0,0]",
        "expected_output": "[[],[0],[0,0],[0,0,0]]"
      },
      {
        "input": "[4,4,4,1,4]",
        "expected_output": "[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        ",
      "java": "class Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return sorted([sorted(x) for x in result]) == sorted(eval(expected))",
      "java": "if ((result instanceof Integer) && (expected instanceof String)) {\n            Integer intResult = (Integer) result;\n            String strExpected = (String) expected;\n            return intResult.toString().equals(strExpected);\n        } else if ((result instanceof String) && (expected instanceof Integer)) {\n            return compare(expected, result);\n        } else if (result instanceof Integer && expected instanceof Integer) {\n            return result.equals(expected);\n        }\n\n        List<?> resultList = (List<?>) result;\n        List<?> expectedList = (List<?>) expected;\n\n        if (resultList.size()!= expectedList.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < resultList.size(); i++) {\n            Object resultItem = resultList.get(i);\n            Object expectedItem = expectedList.get(i);\n\n            if (!compare(resultItem, expectedItem)) {\n                return false;\n            }\n        }\n\n        return true;",
      "cpp": "if (!result.isArray() ||!expected.isArray() || result.size()!= expected.size()) {\n        return false; \n    }\n\n    std::vector<std::vector<int>> resultVec;\n    std::vector<std::vector<int>> expectedVec;\n\n    for (const auto& val: result) {\n        if (!val.isArray()) return false;\n        std::vector<int> innerVec;\n        for (const auto& innerVal: val) {\n            if (!innerVal.isInt()) return false;\n            innerVec.push_back(innerVal.asInt());\n        }\n        std::sort(innerVec.begin(), innerVec.end()); // Sort inner vectors\n        resultVec.push_back(innerVec);\n    }\n\n    for (const auto& val: expected) {\n        if (!val.isArray()) return false;\n        std::vector<int> innerVec;\n        for (const auto& innerVal: val) {\n            if (!innerVal.isInt()) return false;\n            innerVec.push_back(innerVal.asInt());\n        }\n        std::sort(innerVec.begin(), innerVec.end()); // Sort inner vectors\n        expectedVec.push_back(innerVec);\n    }\n\n    std::sort(resultVec.begin(), resultVec.end()); // Sort outer vectors\n    std::sort(expectedVec.begin(), expectedVec.end());\n\n    return resultVec == expectedVec;"
    },
    "explanation": "https://www.youtube.com/watch?v=Vn2v6ajA7U0&pp=ygUTTmVldENvZGUgU3Vic2V0cyBJSQ%3D%3D",
    "method_name": "subsetsWithDup"
  },
  {
    "title": "Restore IP Addresses",
    "source": "https://leetcode.com/problems/restore-ip-addresses/",
    "description": "Solve the problem titled \"Restore IP Addresses\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "'25525511135'",
        "expected_output": "['255.255.11.135','255.255.111.35']"
      },
      {
        "input": "'0000'",
        "expected_output": "['0.0.0.0']"
      },
      {
        "input": "'101023'",
        "expected_output": "['1.0.10.23','1.0.102.3','10.1.0.23','10.10.2.3','101.0.2.3']"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "'1111'",
        "expected_output": "['1.1.1.1']"
      },
      {
        "input": "'010010'",
        "expected_output": "['0.10.0.10','0.100.1.0']"
      },
      {
        "input": "'0'",
        "expected_output": "[]"
      },
      {
        "input": "'999999'",
        "expected_output": "['9.9.99.99','9.99.9.99','9.99.99.9','99.9.9.99','99.9.99.9','99.99.9.9']"
      },
      {
        "input": "'1921680'",
        "expected_output": "['1.9.216.80','1.92.16.80','1.92.168.0','19.2.16.80','19.2.168.0','19.21.6.80','19.21.68.0','19.216.8.0','192.1.6.80','192.1.68.0','192.16.8.0']"
      },
      {
        "input": "'2552551113'",
        "expected_output": "['255.25.51.113','255.255.1.113','255.255.11.13','255.255.111.3']"
      },
      {
        "input": "'00001'",
        "expected_output": "[]"
      },
      {
        "input": "'100100'",
        "expected_output": "['1.0.0.100','10.0.10.0','100.1.0.0']"
      },
      {
        "input": "'12345'",
        "expected_output": "['1.2.3.45','1.2.34.5','1.23.4.5','12.3.4.5']"
      },
      {
        "input": "'1111111'",
        "expected_output": "['1.1.11.111','1.1.111.11','1.11.1.111','1.11.11.11','1.11.111.1','1.111.1.11','1.111.11.1','11.1.1.111','11.1.11.11','11.1.111.1','11.11.1.11','11.11.11.1','11.111.1.1','111.1.1.11','111.1.11.1','111.11.1.1']"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        ",
      "java": "class Solution {\n    public List<String> restoreIpAddresses(String s) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    vector<string> restoreIpAddresses(string s) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return sorted(result) == sorted(eval(expected))",
      "java": "if (result == null && expected == null) {\n                return true;\n            }\n            if (result == null || expected == null) {\n                return false;\n            }\n\n            // Handle List comparison\n            if (result instanceof List && expected instanceof List) {\n                List<?> resultList = (List<?>) result;\n                List<?> expectedList = (List<?>) expected;\n\n                if (resultList.size() != expectedList.size()) {\n                    return false;\n                }\n\n                // Create sorted copies of both lists for comparison\n                List<String> sortedResult = new ArrayList<>();\n                List<String> sortedExpected = new ArrayList<>();\n\n                for (Object item : resultList) {\n                    sortedResult.add(item.toString());\n                }\n                for (Object item : expectedList) {\n                    sortedExpected.add(item.toString());\n                }\n\n                Collections.sort(sortedResult);\n                Collections.sort(sortedExpected);\n\n                return sortedResult.equals(sortedExpected);\n            }\n            return result.equals(expected);",
      "cpp": "if (!result.isArray() ||!expected.isArray() || result.size()!= expected.size()) {\n        return false;\n    }\n\n    std::vector<std::string> resultVec;\n    std::vector<std::string> expectedVec;\n\n    for (const auto& val: result) {\n        if (!val.isString()) return false;\n        resultVec.push_back(val.asString());\n    }\n\n    for (const auto& val: expected) {\n        if (!val.isString()) return false;\n        expectedVec.push_back(val.asString());\n    }\n\n    std::sort(resultVec.begin(), resultVec.end()); // Sort the result vector\n    std::sort(expectedVec.begin(), expectedVec.end()); // Sort the expected vector\n\n    return resultVec == expectedVec;"
    },
    "explanation": "https://www.youtube.com/watch?v=61tN4YEdiTM&pp=ygUdTmVldENvZGUgUmVzdG9yZSBJUCBBZGRyZXNzZXM%3D",
    "method_name": "restoreIpAddresses"
  },
  {
    "title": "Interleaving String",
    "source": "https://leetcode.com/problems/interleaving-string/",
    "description": "Solve the problem titled \"Interleaving String\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "'aabcc', 'dbbca', --arg3='aadbbcbcac'",
        "expected_output": "true"
      },
      {
        "input": "'aabcc', 'dbbca', --arg3='aadbbbaccc'",
        "expected_output": "false"
      },
      {
        "input": "'', '', --arg3=''",
        "expected_output": "true"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "'abc', 'def', --arg3='adbecf'",
        "expected_output": "true"
      },
      {
        "input": "'a', 'b', --arg3='ab'",
        "expected_output": "true"
      },
      {
        "input": "'a', 'b', --arg3='ba'",
        "expected_output": "true"
      },
      {
        "input": "'aa', 'ab', --arg3='aaba'",
        "expected_output": "true"
      },
      {
        "input": "'aaa', 'bbb', --arg3='ababab'",
        "expected_output": "true"
      },
      {
        "input": "'', 'abc', --arg3='abc'",
        "expected_output": "true"
      },
      {
        "input": "'abc', '', --arg3='abc'",
        "expected_output": "true"
      },
      {
        "input": "'abc', 'def', --arg3='abcdef'",
        "expected_output": "true"
      },
      {
        "input": "'aaa', 'aaa', --arg3='aaaaaa'",
        "expected_output": "true"
      },
      {
        "input": "'abc', 'def', --arg3='abcef'",
        "expected_output": "false"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        ",
      "java": "class Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result).lower() == expected.lower()",
      "java": "return result.equals(expected);",
      "cpp": "return result.asBool() == expected.asBool();"
    },
    "explanation": "https://www.youtube.com/watch?v=3Rw3p9LrgvE&pp=ygUcTmVldENvZGUgSW50ZXJsZWF2aW5nIFN0cmluZw%3D%3D",
    "method_name": "isInterleave"
  },
  {
    "title": "Triangle",
    "source": "https://leetcode.com/problems/triangle/",
    "description": "Solve the problem titled \"Triangle\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "[[2],[3,4],[6,5,7],[4,1,8,3]]",
        "expected_output": "11"
      },
      {
        "input": "[[-10]]",
        "expected_output": "-10"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[[1]]",
        "expected_output": "1"
      },
      {
        "input": "[[1],[2,3]]",
        "expected_output": "3"
      },
      {
        "input": "[[-1],[2,3],[1,-1,3]]",
        "expected_output": "0"
      },
      {
        "input": "[[1],[1,2],[1,2,3],[1,2,3,4]]",
        "expected_output": "4"
      },
      {
        "input": "[[0],[-1,2],[1,-2,3],[-3,1,-1,2]]",
        "expected_output": "-4"
      },
      {
        "input": "[[1],[-5,2],[2,-1,3],[1,2,-4,5]]",
        "expected_output": "-9"
      },
      {
        "input": "[[0],[0,0],[0,0,0]]",
        "expected_output": "0"
      },
      {
        "input": "[[1],[-1,-2],[3,-3,1],[-4,5,-6,2]]",
        "expected_output": "-10"
      },
      {
        "input": "[[10],[-2,-3],[1,2,-1]]",
        "expected_output": "6"
      },
      {
        "input": "[[1],[2,1],[3,3,1]]",
        "expected_output": "3"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n        ",
      "java": "class Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result) == expected",
      "java": "return result.equals(expected);",
      "cpp": "return result.asInt() == std::stoi(expected.asString());"
    },
    "explanation": "https://www.youtube.com/watch?v=OM1MTokvxs4&pp=ygURTmVldENvZGUgVHJpYW5nbGU%3D",
    "method_name": "minimumTotal"
  },
  {
    "title": "Longest Consecutive Sequence",
    "source": "https://leetcode.com/problems/longest-consecutive-sequence/",
    "description": "Solve the problem titled \"Longest Consecutive Sequence\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "[100,4,200,1,3,2]",
        "expected_output": "4"
      },
      {
        "input": "[0,3,7,2,5,8,4,6,0,1]",
        "expected_output": "9"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[]",
        "expected_output": "0"
      },
      {
        "input": "[1]",
        "expected_output": "1"
      },
      {
        "input": "[1,2,3,4,5]",
        "expected_output": "5"
      },
      {
        "input": "[1,3,5,7,9]",
        "expected_output": "1"
      },
      {
        "input": "[-5,-4,-3,-2,-1]",
        "expected_output": "5"
      },
      {
        "input": "[1,1,1,1,1]",
        "expected_output": "1"
      },
      {
        "input": "[1,2,0,1]",
        "expected_output": "3"
      },
      {
        "input": "[0,-1,2,-2,3,-3]",
        "expected_output": "4"
      },
      {
        "input": "[1000,1,2,3,4,999]",
        "expected_output": "4"
      },
      {
        "input": "[5,4,3,2,1,6,7,8,9]",
        "expected_output": "9"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        ",
      "java": "class Solution {\n    public int longestConsecutive(int[] nums) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result) == expected",
      "java": "return result.equals(expected);",
      "cpp": "return result.asInt() == std::stoi(expected.asString());"
    },
    "explanation": "https://www.youtube.com/watch?v=P6RZZMu_maU&pp=ygUlTmVldENvZGUgTG9uZ2VzdCBDb25zZWN1dGl2ZSBTZXF1ZW5jZQ%3D%3D",
    "method_name": "longestConsecutive"
  },
  {
    "title": "Gas Station",
    "source": "https://leetcode.com/problems/gas-station/",
    "description": "Solve the problem titled \"Gas Station\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "[1,2,3,4,5], [3,4,5,1,2]",
        "expected_output": "3"
      },
      {
        "input": "[2,3,4], [3,4,3]",
        "expected_output": "-1"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[1], [1]",
        "expected_output": "0"
      },
      {
        "input": "[2], [1]",
        "expected_output": "0"
      },
      {
        "input": "[1,2], [2,1]",
        "expected_output": "1"
      },
      {
        "input": "[5,1,2,3,4], [4,4,1,5,1]",
        "expected_output": "4"
      },
      {
        "input": "[4,5,2,6,5,3], [3,2,7,3,2,9]",
        "expected_output": "-1"
      },
      {
        "input": "[1,2,3], [2,3,1]",
        "expected_output": "2"
      },
      {
        "input": "[3,1,1], [1,2,2]",
        "expected_output": "0"
      },
      {
        "input": "[5,8,2,8], [6,5,6,6]",
        "expected_output": "3"
      },
      {
        "input": "[1,1,1], [1,1,1]",
        "expected_output": "0"
      },
      {
        "input": "[2,0,1], [1,1,1]",
        "expected_output": "0"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        ",
      "java": "class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result) == expected",
      "java": "return result.equals(expected);",
      "cpp": "return std::to_string(result.asInt()) == expected.asString();"
    },
    "explanation": "https://www.youtube.com/watch?v=lJwbPZGo05A&pp=ygUUTmVldENvZGUgR2FzIFN0YXRpb24%3D",
    "method_name": "canCompleteCircuit"
  },
  {
    "title": "Word Break",
    "source": "https://leetcode.com/problems/word-break/",
    "description": "Solve the problem titled \"Word Break\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "'leetcode', ['leet','code']",
        "expected_output": "true"
      },
      {
        "input": "'applepenapple', ['apple','pen']",
        "expected_output": "true"
      },
      {
        "input": "'catsandog', ['cats','dog','sand','and','cat']",
        "expected_output": "false"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "'a', ['a']",
        "expected_output": "true"
      },
      {
        "input": "'ab', ['a','b']",
        "expected_output": "true"
      },
      {
        "input": "'cars', ['car','ca','rs']",
        "expected_output": "true"
      },
      {
        "input": "'goalspecial', ['go','goal','goals','special']",
        "expected_output": "true"
      },
      {
        "input": "'aaaaaaa', ['aaa','aaaa']",
        "expected_output": "true"
      },
      {
        "input": "'impossible', ['imp','possible']",
        "expected_output": "false"
      },
      {
        "input": "'python', ['py','thon']",
        "expected_output": "true"
      },
      {
        "input": "'abcd', ['ab','abc','cd','abcd']",
        "expected_output": "true"
      },
      {
        "input": "'helloworld', ['hello','world','hell','or']",
        "expected_output": "true"
      },
      {
        "input": "'noway', ['no','way','now','ay']",
        "expected_output": "true"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        ",
      "java": "class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result).lower() == expected.lower()",
      "java": "return result.equals(expected);",
      "cpp": "return result.asBool() == expected.asBool();"
    },
    "explanation": "https://www.youtube.com/watch?v=Sx9NNgInc3A&pp=ygUTTmVldENvZGUgV29yZCBCcmVhaw%3D%3D",
    "method_name": "wordBreak"
  },
  {
    "title": "Evaluate Reverse Polish Notation",
    "source": "https://leetcode.com/problems/evaluate-reverse-polish-notation/",
    "description": "Solve the problem titled \"Evaluate Reverse Polish Notation\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "[\"2\",\"1\",\"+\",\"3\",\"*\"]",
        "expected_output": "9"
      },
      {
        "input": "[\"4\",\"13\",\"5\",\"/\",\"+\"]",
        "expected_output": "6"
      },
      {
        "input": "[\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]",
        "expected_output": "22"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[\"1\"]",
        "expected_output": "1"
      },
      {
        "input": "[\"2\",\"3\",\"+\"]",
        "expected_output": "5"
      },
      {
        "input": "[\"4\",\"5\",\"*\"]",
        "expected_output": "20"
      },
      {
        "input": "[\"10\",\"5\",\"/\"]",
        "expected_output": "2"
      },
      {
        "input": "[\"15\",\"7\",\"-\"]",
        "expected_output": "8"
      },
      {
        "input": "[\"2\",\"1\",\"3\",\"*\",\"+\"]",
        "expected_output": "5"
      },
      {
        "input": "[\"-2\",\"3\",\"*\",\"4\",\"+\"]",
        "expected_output": "-2"
      },
      {
        "input": "[\"10\",\"2\",\"*\",\"3\",\"4\",\"*\",\"+\"]",
        "expected_output": "32"
      },
      {
        "input": "[\"5\",\"3\",\"/\",\"2\",\"*\"]",
        "expected_output": "2"
      },
      {
        "input": "[\"100\",\"200\",\"+\",\"2\",\"/\"]",
        "expected_output": "150"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        ",
      "java": "class Solution {\n    public int evalRPN(String[] tokens) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int evalRPN(vector<string>& tokens) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return int(result) == int(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return std::stoi(result.asString()) == std::stoi(expected.asString());"
    },
    "explanation": "https://www.youtube.com/watch?v=iu0082c4HDE&pp=ygUpTmVldENvZGUgRXZhbHVhdGUgUmV2ZXJzZSBQb2xpc2ggTm90YXRpb24%3D",
    "method_name": "evalRPN"
  },
  {
    "title": "Reverse Words in a String",
    "source": "https://leetcode.com/problems/reverse-words-in-a-string/",
    "description": "Solve the problem titled \"Reverse Words in a String\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "\"the, sky, is, blue\"",
        "expected_output": "'blue is sky the'"
      },
      {
        "input": "\", hello, world, \"",
        "expected_output": "'world hello'"
      },
      {
        "input": "\"a, good, example\"",
        "expected_output": "'example good a'"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "\"hello\"",
        "expected_output": "'hello'"
      },
      {
        "input": "\", spaces, \"",
        "expected_output": "'spaces'"
      },
      {
        "input": "\"first, second, third\"",
        "expected_output": "'third second first'"
      },
      {
        "input": "\", multiple, spaces, here, \"",
        "expected_output": "'here spaces multiple'"
      },
      {
        "input": "\"1, 2, 3, 4, 5\"",
        "expected_output": "'5 4 3 2 1'"
      },
      {
        "input": "\"a\"",
        "expected_output": "'a'"
      },
      {
        "input": "\", start, end, \"",
        "expected_output": "'end start'"
      },
      {
        "input": "\"comma,, no, space\"",
        "expected_output": "'space comma,no'"
      },
      {
        "input": "\"mixed, Case, woRDs\"",
        "expected_output": "'woRDs Case mixed'"
      },
      {
        "input": "\", lots, of, spaces, \"",
        "expected_output": "'spaces of lots'"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def reverseWords(self, s: str) -> str:\n        ",
      "java": "class Solution {\n    public String reverseWords(String s) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    string reverseWords(string s) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == eval(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asString() == expected.asString();"
    },
    "explanation": "https://www.youtube.com/watch?v=7kUEwiwwnlA&pp=ygUiTmVldENvZGUgUmV2ZXJzZSBXb3JkcyBpbiBhIFN0cmluZw%3D%3D",
    "method_name": "reverseWords"
  },
  {
    "title": "Find Minimum in Rotated Sorted Array",
    "source": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/",
    "description": "Solve the problem titled \"Find Minimum in Rotated Sorted Array\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "[3,4,5,1,2]",
        "expected_output": "1"
      },
      {
        "input": "[4,5,6,7,0,1,2]",
        "expected_output": "0"
      },
      {
        "input": "[11,13,15,17]",
        "expected_output": "11"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[45,19,22,27,32,36,41]",
        "expected_output": "19"
      },
      {
        "input": "[-29]",
        "expected_output": "-29"
      },
      {
        "input": "[29,30,35,38,41,46,50,54,59,61,63,68,20,22,26]",
        "expected_output": "20"
      },
      {
        "input": "[56,16,19,23,26,31,34,35,36,37,41,44,46,49,51]",
        "expected_output": "16"
      },
      {
        "input": "[11,16,19,21,26,30,35,37,41,-3,-2,0,5,6,7]",
        "expected_output": "-3"
      },
      {
        "input": "[43,47,29,30,35,40,41]",
        "expected_output": "29"
      },
      {
        "input": "[14,19,20,25,28,29,-1,2,6,9]",
        "expected_output": "-1"
      },
      {
        "input": "[14,19,20,25,28,29,-1,2,6,9]",
        "expected_output": "-1"
      },
      {
        "input": "[31,33,29,30]",
        "expected_output": "29"
      },
      {
        "input": "[47,48,52,14,18,23,26,29,34,39,44]",
        "expected_output": "14"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        ",
      "java": "class Solution {\n    public int findMin(int[] nums) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return int(result) == int(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asInt() == expected.asInt();"
    },
    "explanation": "https://www.youtube.com/watch?v=nIVW4P8b1VA&pp=ygUtTmVldENvZGUgRmluZCBNaW5pbXVtIGluIFJvdGF0ZWQgU29ydGVkIEFycmF5",
    "method_name": "findMin"
  },
  {
    "title": "Find Peak Element",
    "source": "https://leetcode.com/problems/find-peak-element/",
    "description": "Solve the problem titled \"Find Peak Element\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "[1,2,3,1]",
        "expected_output": "2"
      },
      {
        "input": "[1,2,1,3,5,6,4]",
        "expected_output": "5"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[1]",
        "expected_output": "0"
      },
      {
        "input": "[1,2]",
        "expected_output": "1"
      },
      {
        "input": "[2,1]",
        "expected_output": "0"
      },
      {
        "input": "[1,2,3]",
        "expected_output": "2"
      },
      {
        "input": "[3,2,1]",
        "expected_output": "0"
      },
      {
        "input": "[1,3,2,4,5]",
        "expected_output": "4"
      },
      {
        "input": "[5,4,3,2,1]",
        "expected_output": "0"
      },
      {
        "input": "[1,5,3,7,4]",
        "expected_output": "3"
      },
      {
        "input": "[1,2,3,4,3]",
        "expected_output": "3"
      },
      {
        "input": "[3,1,4,5,2]",
        "expected_output": "3"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        ",
      "java": "class Solution {\n    public int findPeakElement(int[] nums) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == eval(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asInt() == std::stoi(expected.asString());"
    },
    "explanation": "https://www.youtube.com/watch?v=kMzJy9es7Hc&pp=ygUaTmVldENvZGUgRmluZCBQZWFrIEVsZW1lbnQ%3D",
    "method_name": "findPeakElement"
  },
  {
    "title": "Maximum Gap",
    "source": "https://leetcode.com/problems/maximum-gap/",
    "description": "Solve the problem titled \"Maximum Gap\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "medium",
    "sample_test_cases": [
      {
        "input": "[3,6,9,1]",
        "expected_output": "3"
      },
      {
        "input": "[10]",
        "expected_output": "0"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[1,2,3,4]",
        "expected_output": "1"
      },
      {
        "input": "[1,10]",
        "expected_output": "9"
      },
      {
        "input": "[1,1,1,1]",
        "expected_output": "0"
      },
      {
        "input": "[1,3,100]",
        "expected_output": "97"
      },
      {
        "input": "[1]",
        "expected_output": "0"
      },
      {
        "input": "[1,5,2,8,3]",
        "expected_output": "3"
      },
      {
        "input": "[87,53,100,1]",
        "expected_output": "52"
      },
      {
        "input": "[1000,1,500,2]",
        "expected_output": "500"
      },
      {
        "input": "[1,10000,1,10000]",
        "expected_output": "9999"
      },
      {
        "input": "[1,2,3,5,6,7,8,9,10,100]",
        "expected_output": "90"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        ",
      "java": "class Solution {\n    public int maximumGap(int[] nums) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int maximumGap(vector<int>& nums) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return int(result) == int(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asInt() == std::stoi(expected.asString());"
    },
    "explanation": "https://www.youtube.com/watch?v=imCKT3T2Oao&pp=ygUUTmVldENvZGUgTWF4aW11bSBHYXA%3D",
    "method_name": "maximumGap"
  },
  {
    "title": "Median of Two Sorted Arrays",
    "source": "https://leetcode.com/problems/median-of-two-sorted-arrays/",
    "description": "<p>Given two sorted arrays <code>nums1</code> and <code>nums2</code> of size <code>m</code> and <code>n</code> respectively, return <strong>the median</strong> of the two sorted arrays.</p>\n\n<p>The overall run time complexity should be <code>O(log (m+n))</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,3], nums2 = [2]\n<strong>Output:</strong> 2.00000\n<strong>Explanation:</strong> merged array = [1,2,3] and median is 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,2], nums2 = [3,4]\n<strong>Output:</strong> 2.50000\n<strong>Explanation:</strong> merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>nums1.length == m</code></li>\n\t<li><code>nums2.length == n</code></li>\n\t<li><code>0 &lt;= m &lt;= 1000</code></li>\n\t<li><code>0 &lt;= n &lt;= 1000</code></li>\n\t<li><code>1 &lt;= m + n &lt;= 2000</code></li>\n\t<li><code>-10<sup>6</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
    "difficulty": "hard",
    "sample_test_cases": [
      {
        "input": "[1,3], [2]",
        "expected_output": "2"
      },
      {
        "input": "[1,2], [3,4]",
        "expected_output": "2.5"
      },
      {
        "input": "[], [1]",
        "expected_output": "1"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[1], [1]",
        "expected_output": "1.0"
      },
      {
        "input": "[1,2,3,4,5], []",
        "expected_output": "3"
      },
      {
        "input": "[], [1,2,3,4,5]",
        "expected_output": "3"
      },
      {
        "input": "[1], [2,3,4,5,6]",
        "expected_output": "3.5"
      },
      {
        "input": "[1,2,3,4,5], [6]",
        "expected_output": "3.5"
      },
      {
        "input": "[1,3,5,7], [2,4,6,8]",
        "expected_output": "4.5"
      },
      {
        "input": "[1,1,1,1], [1,1,1,1]",
        "expected_output": "1.0"
      },
      {
        "input": "[-1,0,1], [-2,2]",
        "expected_output": "0"
      },
      {
        "input": "[10000], [-10000]",
        "expected_output": "0.0"
      },
      {
        "input": "[1,2], [1,2,3]",
        "expected_output": "2"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        ",
      "java": "class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return abs(float(result) - float(expected)) < 0.00001",
      "java": "return Math.abs((double) result - (double) expected) < 0.00001;",
      "cpp": "return std::abs(result.asDouble() - expected.asDouble()) < 0.00001;"
    },
    "explanation": "https://www.youtube.com/watch?v=q6IEA26hvXc&pp=ygUkTmVldENvZGUgTWVkaWFuIG9mIFR3byBTb3J0ZWQgQXJyYXlz",
    "method_name": "findMedianSortedArrays"
  },
  {
    "title": "First Missing Positive",
    "source": "https://leetcode.com/problems/first-missing-positive/",
    "description": "Given an unsorted integer array `nums`, return the smallest missing positive integer. You must implement an algorithm that runs in O(n) time and uses constant extra space.",
    "difficulty": "hard",
    "sample_test_cases": [
      {
        "input": "[1,2,0]",
        "expected_output": "3"
      },
      {
        "input": "[3,4,-1,1]",
        "expected_output": "2"
      },
      {
        "input": "[7,8,9,11,12]",
        "expected_output": "1"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[1]",
        "expected_output": "2"
      },
      {
        "input": "[1,1]",
        "expected_output": "2"
      },
      {
        "input": "[-1,-2,-3]",
        "expected_output": "1"
      },
      {
        "input": "[1,2,3,4,5]",
        "expected_output": "6"
      },
      {
        "input": "[2]",
        "expected_output": "1"
      },
      {
        "input": "[1,2,4]",
        "expected_output": "3"
      },
      {
        "input": "[1,1,1,1,1]",
        "expected_output": "2"
      },
      {
        "input": "[2147483647]",
        "expected_output": "1"
      },
      {
        "input": "[-2147483648]",
        "expected_output": "1"
      },
      {
        "input": "[1,2,3,3,3]",
        "expected_output": "4"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        ",
      "java": "class Solution {\n    public int firstMissingPositive(int[] nums) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result) == expected",
      "java": "return result.equals(expected);",
      "cpp": "return std::to_string(result.asInt()) == expected.asString();"
    },
    "explanation": "https://www.youtube.com/watch?v=8g78yfzMlao&pp=ygUfTmVldENvZGUgRmlyc3QgTWlzc2luZyBQb3NpdGl2ZQ%3D%3D",
    "method_name": "firstMissingPositive"
  },
  {
    "title": "Permutation Sequence",
    "source": "https://leetcode.com/problems/permutation-sequence/",
    "description": "The set `[1, 2, 3, ..., n]` contains a total of `n!` unique permutations. Given `n` and an integer `k`, return the `k`th permutation sequence of this set as a string.",
    "difficulty": "hard",
    "sample_test_cases": [
      {
        "input": "3, 3",
        "expected_output": "'213'"
      },
      {
        "input": "4, 9",
        "expected_output": "'2314'"
      },
      {
        "input": "3, 1",
        "expected_output": "'123'"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "1, 1",
        "expected_output": "'1'"
      },
      {
        "input": "2, 1",
        "expected_output": "'12'"
      },
      {
        "input": "2, 2",
        "expected_output": "'21'"
      },
      {
        "input": "3, 6",
        "expected_output": "'321'"
      },
      {
        "input": "4, 1",
        "expected_output": "'1234'"
      },
      {
        "input": "4, 24",
        "expected_output": "'4321'"
      },
      {
        "input": "5, 5",
        "expected_output": "'12534'"
      },
      {
        "input": "6, 720",
        "expected_output": "'654321'"
      },
      {
        "input": "7, 1",
        "expected_output": "'1234567'"
      },
      {
        "input": "8, 40320",
        "expected_output": "'87654321'"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        ",
      "java": "class Solution {\n    public String getPermutation(int n, int k) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    string getPermutation(int n, int k) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == eval(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result == expected;"
    },
    "explanation": "https://www.youtube.com/watch?v=W9SIlE2jhBQ&pp=ygUdTmVldENvZGUgUGVybXV0YXRpb24gU2VxdWVuY2U%3D",
    "method_name": "getPermutation"
  },
  {
    "title": "Text Justification",
    "source": "https://leetcode.com/problems/text-justification/",
    "description": "Solve the problem titled \"Text Justification\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "hard",
    "sample_test_cases": [
      {
        "input": "['This','is','an','example','of','text','justification.'], 16",
        "expected_output": "['This    is    an','example  of text','justification.  ']"
      },
      {
        "input": "['What','must','be','acknowledgment','shall','be'], 16",
        "expected_output": "['What   must   be','acknowledgment  ','shall be        ']"
      },
      {
        "input": "['Science','is','what','we','understand','well','enough','to','explain','to','a','computer.','Art','is','everything','else','we','do'], 20",
        "expected_output": "['Science  is  what we','understand      well','enough to explain to','a  computer.  Art is','everything  else  we','do                  ']"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "['a'], 1",
        "expected_output": "['a']"
      },
      {
        "input": "['a','b','c'], 1",
        "expected_output": "['a','b','c']"
      },
      {
        "input": "['hello'], 10",
        "expected_output": "['hello     ']"
      },
      {
        "input": "['a','b','c','d'], 3",
        "expected_output": "['a b','c d']"
      },
      {
        "input": "['This','is','a','test'], 4",
        "expected_output": "['This','is a','test']"
      },
      {
        "input": "['ab','cd','ef'], 10",
        "expected_output": "['ab cd ef  ']"
      },
      {
        "input": "['a','b'], 4",
        "expected_output": "['a b ']"
      },
      {
        "input": "['word'], 5",
        "expected_output": "['word ']"
      },
      {
        "input": "['a','b','c','d','e'], 3",
        "expected_output": "['a b','c d','e  ']"
      },
      {
        "input": "['Hello','World'], 12",
        "expected_output": "['Hello World ']"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        ",
      "java": "class Solution {\n    public List<String> fullJustify(String[] words, int maxWidth) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    vector<string> fullJustify(vector<string>& words, int maxWidth) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == eval(expected)",
      "java": "List<String> resultList = (List<String>) result;\nList<String> expectedList = (List<String>) expected;\nreturn resultList.equals(expectedList);",
      "cpp": "std::vector<std::string> resultList = jsonToValue<std::vector<std::string>>(result);\nstd::vector<std::string> expectedList = jsonToValue<std::vector<std::string>>(expected);\nreturn resultList == expectedList;"
    },
    "explanation": "https://www.youtube.com/watch?v=TzMl4Z7pVh8&pp=ygUbTmVldENvZGUgVGV4dCBKdXN0aWZpY2F0aW9u",
    "method_name": "fullJustify"
  },
  {
    "title": "Minimum Window Substring",
    "source": "https://leetcode.com/problems/minimum-window-substring/",
    "description": "Solve the problem titled \"Minimum Window Substring\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "hard",
    "sample_test_cases": [
      {
        "input": "'ADOBECODEBANC', 'ABC'",
        "expected_output": "'BANC'"
      },
      {
        "input": "'a', 'a'",
        "expected_output": "'a'"
      },
      {
        "input": "'a', 'aa'",
        "expected_output": "''"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "'a', 'b'",
        "expected_output": "''"
      },
      {
        "input": "'ab', 'a'",
        "expected_output": "'a'"
      },
      {
        "input": "'ABCDEFG', 'AC'",
        "expected_output": "'ABC'"
      },
      {
        "input": "'aaaaaaa', 'a'",
        "expected_output": "'a'"
      },
      {
        "input": "'ADOBECODEBANC', 'ABBC'",
        "expected_output": "'BECODEBA'"
      },
      {
        "input": "'this, is, a, test, string', 'tist'",
        "expected_output": "'t stri'"
      },
      {
        "input": "'ADOBECODEBANC', 'ABCDE'",
        "expected_output": "'ADOBEC'"
      },
      {
        "input": "'aaabbaaba', 'abb'",
        "expected_output": "'abb'"
      },
      {
        "input": "'abc', 'cba'",
        "expected_output": "'abc'"
      },
      {
        "input": "'bba', 'ab'",
        "expected_output": "'ba'"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        ",
      "java": "class Solution {\n    public String minWindow(String s, String t) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    string minWindow(string s, string t) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == eval(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result == expected;"
    },
    "explanation": "https://www.youtube.com/watch?v=jSto0O4AJbM&pp=ygUhTmVldENvZGUgTWluaW11bSBXaW5kb3cgU3Vic3RyaW5n",
    "method_name": "minWindow"
  },
  {
    "title": "Largest Rectangle in Histogram",
    "source": "https://leetcode.com/problems/largest-rectangle-in-histogram/",
    "description": "Solve the problem titled \"Largest Rectangle in Histogram\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "hard",
    "sample_test_cases": [
      {
        "input": "[2,1,5,6,2,3]",
        "expected_output": "10"
      },
      {
        "input": "[2,4]",
        "expected_output": "4"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[2,1,2]",
        "expected_output": "3"
      },
      {
        "input": "[1]",
        "expected_output": "1"
      },
      {
        "input": "[0]",
        "expected_output": "0"
      },
      {
        "input": "[1,1,1,1]",
        "expected_output": "4"
      },
      {
        "input": "[2,1,2,3,1]",
        "expected_output": "5"
      },
      {
        "input": "[5,4,3,2,1]",
        "expected_output": "9"
      },
      {
        "input": "[1,2,3,4,5]",
        "expected_output": "9"
      },
      {
        "input": "[2,2,2,2]",
        "expected_output": "8"
      },
      {
        "input": "[1,2,3,4,5,4,3,2,1]",
        "expected_output": "15"
      },
      {
        "input": "[0,0,0]",
        "expected_output": "0"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        ",
      "java": "class Solution {\n    public int largestRectangleArea(int[] heights) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return int(result) == int(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asInt() == std::stoi(expected.asString());"
    },
    "explanation": "https://www.youtube.com/watch?v=zx5Sw9130L0&pp=ygUnTmVldENvZGUgTGFyZ2VzdCBSZWN0YW5nbGUgaW4gSGlzdG9ncmFt",
    "method_name": "largestRectangleArea"
  },
  {
    "title": "Maximal Rectangle",
    "source": "https://leetcode.com/problems/maximal-rectangle/",
    "description": "Solve the problem titled \"Maximal Rectangle\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "hard",
    "sample_test_cases": [
      {
        "input": "[[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
        "expected_output": "6"
      },
      {
        "input": "[[\"0\"]]",
        "expected_output": "0"
      },
      {
        "input": "[[\"1\"]]",
        "expected_output": "1"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[[\"1\",\"1\"],[\"1\",\"1\"]]",
        "expected_output": "4"
      },
      {
        "input": "[[\"0\",\"0\"],[\"0\",\"0\"]]",
        "expected_output": "0"
      },
      {
        "input": "[[\"1\"],[\"1\"]]",
        "expected_output": "2"
      },
      {
        "input": "[[\"1\",\"0\"],[\"1\",\"0\"]]",
        "expected_output": "2"
      },
      {
        "input": "[[\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\"]]",
        "expected_output": "9"
      },
      {
        "input": "[[\"1\",\"0\",\"1\"],[\"0\",\"1\",\"0\"],[\"1\",\"0\",\"1\"]]",
        "expected_output": "1"
      },
      {
        "input": "[[\"0\",\"1\"],[\"1\",\"0\"]]",
        "expected_output": "1"
      },
      {
        "input": "[[\"1\",\"1\",\"1\"],[\"1\",\"0\",\"1\"],[\"1\",\"1\",\"1\"]]",
        "expected_output": "3"
      },
      {
        "input": "[[\"1\"],[\"1\"],[\"1\"]]",
        "expected_output": "3"
      },
      {
        "input": "[[\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\"]]",
        "expected_output": "0"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        ",
      "java": "class Solution {\n    public int maximalRectangle(char[][] matrix) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return int(result) == int(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asInt() == expected.asInt();"
    },
    "explanation": "https://www.youtube.com/watch?v=tOylVCugy9k&pp=ygUaTmVldENvZGUgTWF4aW1hbCBSZWN0YW5nbGU%3D",
    "method_name": "maximalRectangle"
  },
  {
    "title": "Scramble String",
    "source": "https://leetcode.com/problems/scramble-string/",
    "description": "Solve the problem titled \"Scramble String\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "hard",
    "sample_test_cases": [
      {
        "input": "\"great\", \"rgeat\"",
        "expected_output": "true"
      },
      {
        "input": "\"abcde\", \"caebd\"",
        "expected_output": "false"
      },
      {
        "input": "\"a\", \"a\"",
        "expected_output": "true"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "\"ab\", \"ba\"",
        "expected_output": "true"
      },
      {
        "input": "\"abc\", \"bac\"",
        "expected_output": "true"
      },
      {
        "input": "\"abc\", \"cab\"",
        "expected_output": "true"
      },
      {
        "input": "\"abb\", \"bba\"",
        "expected_output": "true"
      },
      {
        "input": "\"aaab\", \"abaa\"",
        "expected_output": "true"
      },
      {
        "input": "\"abcd\", \"bdac\"",
        "expected_output": "false"
      },
      {
        "input": "\"abcde\", \"badce\"",
        "expected_output": "true"
      },
      {
        "input": "\"abc\", \"acb\"",
        "expected_output": "true"
      },
      {
        "input": "\"abcdbdacbdac\", \"bdacabcdbdac\"",
        "expected_output": "true"
      },
      {
        "input": "\"xstjzkfpkggnhjzkpfjoguxvkbuopi\", \"xbouipkvxugojfpkzjhnggkpfzjts\"",
        "expected_output": "false"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        ",
      "java": "class Solution {\n    public boolean isScramble(String s1, String s2) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    bool isScramble(string s1, string s2) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result).lower() == expected.lower()",
      "java": "return result.equals(expected);",
      "cpp": "return result.asBool() == expected.asBool();"
    },
    "explanation": "https://www.youtube.com/watch?v=MDmZm_aVDF8&pp=ygUYTmVldENvZGUgU2NyYW1ibGUgU3RyaW5n",
    "method_name": "isScramble"
  },
  {
    "title": "Distinct Subsequences",
    "source": "https://leetcode.com/problems/distinct-subsequences/",
    "description": "Solve the problem titled \"Distinct Subsequences\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "hard",
    "sample_test_cases": [
      {
        "input": "\"rabbbit\", \"rabbit\"",
        "expected_output": "3"
      },
      {
        "input": "\"babgbag\", \"bag\"",
        "expected_output": "5"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "\"a\", \"a\"",
        "expected_output": "1"
      },
      {
        "input": "\"aa\", \"a\"",
        "expected_output": "2"
      },
      {
        "input": "\"aaa\", \"aa\"",
        "expected_output": "3"
      },
      {
        "input": "\"abc\", \"abc\"",
        "expected_output": "1"
      },
      {
        "input": "\"abcde\", \"ace\"",
        "expected_output": "1"
      },
      {
        "input": "\"aabb\", \"ab\"",
        "expected_output": "4"
      },
      {
        "input": "\"xslledayhxhadmctrliaxqpokyezcfhzaskeykchkmhpyjipxtsuljkwkovmvelvwxzwieeuqnjozrfwmzsylcwvsthnxujvrkszqwtglewkycikdaiocglwzukwovsghkhyidevhbgffoqkpabthmqihcfxxzdejletqjoxmwftlxfcxgxgvpperwbqvhxgsbbkmphyomtbjzdjhcrcsggleiczpbfjcgtpycpmrjnckslrwduqlccqmgrdhxolfjafmsrfdghnatexyanldrdpxvvgujsztuffoymrfteholgonuaqndinadtumnuhkboyzaqguwqijwxxszngextfcozpetyownmyneehdwqmtpjloztswmzzdzqhuoxrblppqvyvsqhnhryvqsqogpnlqfulurexdtovqpqkfxxnqykgscxaskmksivoazlducanrqxynxlgvwonalpsyddqmaemcrrwvrjmjjnygyebwtqxehrclwsxzylbqexnxjcgspeynlbmetlkacnnbhmaizbadynajpibepbuacggxrqavfnwpcwxbzxfymhjcslghmajrirqzjqxpgtgisfjreqrqabssobbadmtmdknmakdigjqyqcruujlwmfoagrckdwyiglviyyrekjealvvigiesnvuumxgsveadrxlpwetioxibtdjblowblqvzpbrmhupyrdophjxvhgzclidzybajuxllacyhyphssvhcffxonysahvzhzbttyeeyiefhunbokiqrpqfcoxdxvefugapeevdoakxwzykmhbdytjbhigffkmbqmqxsoaiomgmmgwapzdosorcxxhejvgajyzdmzlcntqbapbpofdjtulstuzdrffafedufqwsknumcxbschdybosxkrabyfdejgyozwillcxpcaiehlelczioskqtptzaczobvyojdlyflilvwqgyrqmjaeepydrcchfyftjighntqzoo\", \"rwmimatmhydhbujebqehjprarwfkoebcxxqfktayaaeheys\"",
        "expected_output": "1456742400"
      },
      {
        "input": "\"aaaaaaaaaa\", \"aaaaaaa\"",
        "expected_output": "120"
      },
      {
        "input": "\"abcdef\", \"xyz\"",
        "expected_output": "0"
      },
      {
        "input": "\"wbyhqihmwwux\", \"byhwu\"",
        "expected_output": "4"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        ",
      "java": "class Solution {\n    public int numDistinct(String s, String t) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int numDistinct(string s, string t) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return int(result) == int(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return std::stoi(result.asString()) == std::stoi(expected.asString());"
    },
    "explanation": "https://www.youtube.com/watch?v=-RDzMJ33nx8&pp=ygUeTmVldENvZGUgRGlzdGluY3QgU3Vic2VxdWVuY2Vz",
    "method_name": "numDistinct"
  },
  {
    "title": "Best Time to Buy and Sell Stock III",
    "source": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/",
    "description": "Solve the problem titled \"Best Time to Buy and Sell Stock III\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "hard",
    "sample_test_cases": [
      {
        "input": "[3,3,5,0,0,3,1,4]",
        "expected_output": "6"
      },
      {
        "input": "[1,2,3,4,5]",
        "expected_output": "4"
      },
      {
        "input": "[7,6,4,3,1]",
        "expected_output": "0"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[1]",
        "expected_output": "0"
      },
      {
        "input": "[1,2]",
        "expected_output": "1"
      },
      {
        "input": "[2,1]",
        "expected_output": "0"
      },
      {
        "input": "[1,2,4,2,5,7,2,4,9,0]",
        "expected_output": "13"
      },
      {
        "input": "[0,0,0,0]",
        "expected_output": "0"
      },
      {
        "input": "[1,2,3,4,5,4,3,2,1]",
        "expected_output": "4"
      },
      {
        "input": "[3,2,6,5,0,3]",
        "expected_output": "7"
      },
      {
        "input": "[1,4,5,7,6,3,2,9]",
        "expected_output": "13"
      },
      {
        "input": "[8,3,6,2,8,8,8,4,2,0,7,2,9,4,9]",
        "expected_output": "15"
      },
      {
        "input": "[1,2,4,2,5,7,2,4,9,0,9]",
        "expected_output": "17"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        ",
      "java": "class Solution {\n    public int maxProfit(int[] prices) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return int(result) == int(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return result.asInt() == expected.asInt();"
    },
    "explanation": "https://www.youtube.com/watch?v=37s1_xBiqH0&pp=ygUsTmVldENvZGUgQmVzdCBUaW1lIHRvIEJ1eSBhbmQgU2VsbCBTdG9jayBJSUk%3D",
    "method_name": "maxProfit"
  },
  {
    "title": "Word Ladder",
    "source": "https://leetcode.com/problems/word-ladder/",
    "description": "Solve the problem titled \"Word Ladder\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "hard",
    "sample_test_cases": [
      {
        "input": "'hit', 'cog', --arg3=['hot','dot','dog','lot','log','cog']",
        "expected_output": "5"
      },
      {
        "input": "'hit', 'cog', --arg3=['hot','dot','dog','lot','log']",
        "expected_output": "0"
      },
      {
        "input": "'lost', 'cost', --arg3=['most','cost','lost']",
        "expected_output": "2"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "'hit', 'dog', --arg3=['hot','dot','dog']",
        "expected_output": "4"
      },
      {
        "input": "'cat', 'rat', --arg3=['hat','rat','cat']",
        "expected_output": "2"
      },
      {
        "input": "'a', 'c', --arg3=['a','b','c']",
        "expected_output": "2"
      },
      {
        "input": "'red', 'tax', --arg3=['ted','tex','red','tax','tad']",
        "expected_output": "4"
      },
      {
        "input": "'log', 'dog', --arg3=['fog','fig','dig','dog','log']",
        "expected_output": "2"
      },
      {
        "input": "'abc', 'def', --arg3=['abf','acf','aef','def']",
        "expected_output": "4"
      },
      {
        "input": "'hot', 'dog', --arg3=['hot','dog']",
        "expected_output": "0"
      },
      {
        "input": "'hit', 'cog', --arg3=[]",
        "expected_output": "0"
      },
      {
        "input": "'cat', 'cat', --arg3=['cat']",
        "expected_output": "2"
      },
      {
        "input": "'hit', 'hat', --arg3=['hat','hot']",
        "expected_output": "2"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        ",
      "java": "class Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> \nwordList) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector<string>& \nwordList) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result) == expected",
      "java": "return result.equals(expected);",
      "cpp": "return std::to_string(result.asInt()) == expected.asString();"
    },
    "explanation": "https://www.youtube.com/watch?v=h9iTnkgv05E&pp=ygUUTmVldENvZGUgV29yZCBMYWRkZXI%3D",
    "method_name": "ladderLength"
  },
  {
    "title": "Candy",
    "source": "https://leetcode.com/problems/candy/",
    "description": "Solve the problem titled \"Candy\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "hard",
    "sample_test_cases": [
      {
        "input": "[1,0,2]",
        "expected_output": "5"
      },
      {
        "input": "[1,2,2]",
        "expected_output": "4"
      },
      {
        "input": "[1,3,2,2,1]",
        "expected_output": "7"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[1,2,3,4,5]",
        "expected_output": "15"
      },
      {
        "input": "[5,4,3,2,1]",
        "expected_output": "15"
      },
      {
        "input": "[1,1,1,1,1]",
        "expected_output": "5"
      },
      {
        "input": "[1,3,4,5,2]",
        "expected_output": "11"
      },
      {
        "input": "[1,2,87,87,87,2,1]",
        "expected_output": "13"
      },
      {
        "input": "[1,2,2,3,1,2]",
        "expected_output": "9"
      },
      {
        "input": "[0]",
        "expected_output": "1"
      },
      {
        "input": "[1,0,1,0,1]",
        "expected_output": "8"
      },
      {
        "input": "[2,0,1,0,2]",
        "expected_output": "8"
      },
      {
        "input": "[1,6,10,8,7,3,2]",
        "expected_output": "18"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        ",
      "java": "class Solution {\n    public int candy(int[] ratings) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int candy(vector<int>& ratings) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result) == expected",
      "java": "return result.equals(expected);",
      "cpp": "return std::to_string(result.asInt()) == expected.asString();"
    },
    "explanation": "https://www.youtube.com/watch?v=1IzCRCcK17A&pp=ygUOTmVldENvZGUgQ2FuZHk%3D",
    "method_name": "candy"
  },
  {
    "title": "Word Break II",
    "source": "https://leetcode.com/problems/word-break-ii/",
    "description": "Solve the problem titled \"Word Break II\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "hard",
    "sample_test_cases": [
      {
        "input": "'catsanddog', ['cat','cats','and','sand','dog']",
        "expected_output": "['cat sand dog','cats and dog']"
      },
      {
        "input": "'pineapplepenapple', ['apple','pen','applepen','pine','pineapple']",
        "expected_output": "['pine apple pen apple','pine applepen apple','pineapple pen apple']"
      },
      {
        "input": "'catsandog', ['cats','dog','sand','and','cat']",
        "expected_output": "[]"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "'leetcode', ['leet','code']",
        "expected_output": "['leet code']"
      },
      {
        "input": "'applepenapple', ['apple','pen']",
        "expected_output": "['apple pen apple']"
      },
      {
        "input": "'a', ['a']",
        "expected_output": "['a']"
      },
      {
        "input": "'aaaa', ['a','aa','aaa']",
        "expected_output": "['a a a a','a a aa','a aa a','a aaa','aa a a','aa aa','aaa a']"
      },
      {
        "input": "'cars', ['car','ca','rs']",
        "expected_output": "['ca rs']"
      },
      {
        "input": "'bb', ['a','b','bbb']",
        "expected_output": "['b b']"
      },
      {
        "input": "'catsanddogs', ['cats','cat','and','sand','dog','dogs']",
        "expected_output": "['cat sand dogs','cats and dogs']"
      },
      {
        "input": "'ab', ['a','b']",
        "expected_output": "['a b']"
      },
      {
        "input": "'impossible', ['imp','possible']",
        "expected_output": "[]"
      },
      {
        "input": "'aaa', ['a','aa']",
        "expected_output": "['a a a','a aa','aa a']"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        ",
      "java": "class Solution {\n    public List<String> wordBreak(String s, List<String> wordDict) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "def normalize(s): return sorted([x.strip() for x in eval(s)])\n    return normalize(str(result)) == normalize(expected)",
      "java": "if (result == null && expected == null) {\n            return true;\n        }\n        if (result == null || expected == null) {\n            return false;\n        }\n\n        if (result instanceof List<?> && expected instanceof List<?>) {\n            List<?> resultList = (List<?>) result;\n            List<?> expectedList = (List<?>) expected;\n\n            if (resultList.size()!= expectedList.size()) {\n                return false;\n            }\n\n            for (int i = 0; i < resultList.size(); i++) {\n                if (!Objects.deepEquals(resultList.get(i), expectedList.get(i))) {\n                    return false;\n                }\n            }\n            return true;\n        } else {\n            return Objects.deepEquals(result, expected);\n        }",
      "cpp": "std::vector<std::string> resultVec = jsonToValue<std::vector<std::string>>(result);\nstd::vector<std::string> expectedVec = jsonToValue<std::vector<std::string>>(expected);\nstd::sort(resultVec.begin(), resultVec.end());\nstd::sort(expectedVec.begin(), expectedVec.end());\nreturn resultVec == expectedVec;"
    },
    "explanation": "https://www.youtube.com/watch?v=QgLKdluDo08&pp=ygUWTmVldENvZGUgV29yZCBCcmVhayBJSQ%3D%3D",
    "method_name": "wordBreak"
  },
  {
    "title": "Find Minimum in Rotated Sorted Array II",
    "source": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/",
    "description": "Solve the problem titled \"Find Minimum in Rotated Sorted Array II\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "hard",
    "sample_test_cases": [
      {
        "input": "[1,3,5]",
        "expected_output": "1"
      },
      {
        "input": "[2,2,2,0,1]",
        "expected_output": "0"
      },
      {
        "input": "[3,1,3]",
        "expected_output": "1"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[1,1,1,1,1]",
        "expected_output": "1"
      },
      {
        "input": "[3,3,1,3]",
        "expected_output": "1"
      },
      {
        "input": "[2,2,2,0,1,2]",
        "expected_output": "0"
      },
      {
        "input": "[4,5,6,7,0,1,2]",
        "expected_output": "0"
      },
      {
        "input": "[1,1,1,0,1]",
        "expected_output": "0"
      },
      {
        "input": "[3,4,5,1,2]",
        "expected_output": "1"
      },
      {
        "input": "[5,1,2,3,4]",
        "expected_output": "1"
      },
      {
        "input": "[2,2,2,2,2,2]",
        "expected_output": "2"
      },
      {
        "input": "[3,1,1,1,1]",
        "expected_output": "1"
      },
      {
        "input": "[4,4,5,5,6,6,7,0]",
        "expected_output": "0"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        ",
      "java": "class Solution {\n    public int findMin(int[] nums) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result) == expected",
      "java": "return result.equals(expected);",
      "cpp": "return result.asInt() == std::stoi(expected.asString());"
    },
    "explanation": "https://www.youtube.com/watch?v=oUnF7o88_Xc&pp=ygUwTmVldENvZGUgRmluZCBNaW5pbXVtIGluIFJvdGF0ZWQgU29ydGVkIEFycmF5IElJ",
    "method_name": "findMin"
  },
  {
    "title": "Best Time to Buy and Sell Stock IV",
    "source": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/",
    "description": "Solve the problem titled \"Best Time to Buy and Sell Stock IV\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "hard",
    "sample_test_cases": [
      {
        "input": "2, [2,4,1]",
        "expected_output": "2"
      },
      {
        "input": "2, [3,2,6,5,0,3]",
        "expected_output": "7"
      },
      {
        "input": "1, [1,2]",
        "expected_output": "1"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "2, [1,2,4,2,5,7,2,4,9,0]",
        "expected_output": "13"
      },
      {
        "input": "1, [7,1,5,3,6,4]",
        "expected_output": "5"
      },
      {
        "input": "3, [3,3,5,0,0,3,1,4]",
        "expected_output": "8"
      },
      {
        "input": "4, [1,2,3,4,5]",
        "expected_output": "4"
      },
      {
        "input": "2, [1,4,5,7,6,3,2,1]",
        "expected_output": "6"
      },
      {
        "input": "3, [1]",
        "expected_output": "0"
      },
      {
        "input": "1, [7,6,5,4,3,2]",
        "expected_output": "0"
      },
      {
        "input": "2, [1,2,3,4,5,6]",
        "expected_output": "5"
      },
      {
        "input": "5, [3,2,6,5,0,3,1,4]",
        "expected_output": "10"
      },
      {
        "input": "2, [2,1,4,5,2,9,7]",
        "expected_output": "11"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        ",
      "java": "class Solution {\n    public int maxProfit(int k, int[] prices) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int maxProfit(int k, vector<int>& prices) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return str(result) == expected",
      "java": "return ((Integer) result).toString().equals(expected);",
      "cpp": "return result.asInt() == expected.asInt();"
    },
    "explanation": "https://www.youtube.com/watch?v=NshLjAWa03c&pp=ygUrTmVldENvZGUgQmVzdCBUaW1lIHRvIEJ1eSBhbmQgU2VsbCBTdG9jayBJVg%3D%3D",
    "method_name": "maxProfit"
  },
  {
    "title": "The Skyline Problem",
    "source": "https://leetcode.com/problems/the-skyline-problem/",
    "description": "Solve the problem titled \"The Skyline Problem\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "hard",
    "sample_test_cases": [
      {
        "input": "[[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]",
        "expected_output": "[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]"
      },
      {
        "input": "[[0,2,3],[2,5,3]]",
        "expected_output": "[[0,3],[5,0]]"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[[1,5,11],[2,7,6],[3,9,13],[12,16,7],[14,25,3],[19,22,18],[23,29,13],[24,28,4]]",
        "expected_output": "[[1,11],[3,13],[9,0],[12,7],[16,3],[19,18],[22,3],[23,13],[29,0]]"
      },
      {
        "input": "[[1,2,1],[1,2,2],[1,2,3]]",
        "expected_output": "[[1,3],[2,0]]"
      },
      {
        "input": "[[1,10,10]]",
        "expected_output": "[[1,10],[10,0]]"
      },
      {
        "input": "[[1,5,3],[2,4,4]]",
        "expected_output": "[[1,3],[2,4],[4,3],[5,0]]"
      },
      {
        "input": "[[1,5,11],[2,3,13]]",
        "expected_output": "[[1,11],[2,13],[3,11],[5,0]]"
      },
      {
        "input": "[[0,3,3],[1,5,3],[2,4,3]]",
        "expected_output": "[[0,3],[5,0]]"
      },
      {
        "input": "[[2,4,70],[3,8,30],[6,100,41],[7,15,70],[10,30,102],[15,25,76],[60,80,91],[70,90,72],[85,120,59]]",
        "expected_output": "[[2,70],[4,30],[6,41],[7,70],[10,102],[30,41],[60,91],[80,72],[90,59],[120,0]]"
      },
      {
        "input": "[[1,20,1],[1,21,2],[1,22,3]]",
        "expected_output": "[[1,3],[22,0]]"
      },
      {
        "input": "[[0,5,7],[5,10,7],[5,10,12],[10,15,7],[15,20,7],[15,20,12],[20,25,7]]",
        "expected_output": "[[0,7],[5,12],[10,7],[15,12],[20,7],[25,0]]"
      },
      {
        "input": "[[1,2,1]]",
        "expected_output": "[[1,1],[2,0]]"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        ",
      "java": "class Solution {\n    public List<List<Integer>> getSkyline(int[][] buildings) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == eval(expected)",
      "java": "if (result == null && expected == null) return true;\n    if (result == null || expected == null) return false;\n    \n    if (result instanceof List && expected instanceof List) {\n        List<?> resList = (List<?>) result;\n        List<?> expList = (List<?>) expected;\n        if (resList.size() != expList.size()) return false;\n        for (int i = 0; i < resList.size(); i++) {\n            if (!compare(resList.get(i), expList.get(i))) return false;\n        }\n        return true;\n    } else if (expected instanceof Unknown) {\n        try {\n            Object parsed = parseValue(((Unknown) expected).get(), result.getClass());\n            return compare(result, parsed);\n        } catch (Exception e) {\n            return false;\n        }\n    }\n    return result.equals(expected);",
      "cpp": "if (!result.isArray() || !expected.isArray() || result.size() != expected.size()) {\n        return false;\n    }\n\n    for (Json::Value::const_iterator it_result = result.begin(), it_expected = expected.begin();\n         it_result != result.end() && it_expected != expected.end();\n         ++it_result, ++it_expected) {\n        const Json::Value& result_element = *it_result;\n        const Json::Value& expected_element = *it_expected;\n\n        if (!result_element.isArray() || !expected_element.isArray() || result_element.size() != expected_element.size()) {\n            return false;\n        }\n\n        for (Json::Value::const_iterator inner_it_result = result_element.begin(), inner_it_expected = expected_element.begin();\n             inner_it_result != result_element.end() && inner_it_expected != expected_element.end();\n             ++inner_it_result, ++inner_it_expected) {\n            if (*inner_it_result != *inner_it_expected) {\n                return false;\n            }\n        }\n    }\n    return true;"
    },
    "explanation": "https://www.youtube.com/watch?v=XhzHXj7wrwo&pp=ygUcTmVldENvZGUgVGhlIFNreWxpbmUgUHJvYmxlbQ%3D%3D",
    "method_name": "getSkyline"
  },
  {
    "title": "Basic Calculator",
    "source": "https://leetcode.com/problems/basic-calculator/",
    "description": "Implement a calculator that supports the logic described in \"Basic Calculator\". The calculator may need to parse expressions and compute results.",
    "difficulty": "hard",
    "sample_test_cases": [
      {
        "input": "\"1, +, 1\"",
        "expected_output": "2"
      },
      {
        "input": "\", 2-1, +, 2, \"",
        "expected_output": "3"
      },
      {
        "input": "\"(1+(4+5+2)-3)+(6+8)\"",
        "expected_output": "23"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "\"2147483647\"",
        "expected_output": "2147483647"
      },
      {
        "input": "\"1, +, (2, +, 3)\"",
        "expected_output": "6"
      },
      {
        "input": "\"-(2, +, 3)\"",
        "expected_output": "-5"
      },
      {
        "input": "\"(1+(4+5+2)-3)+(6+8)\"",
        "expected_output": "23"
      },
      {
        "input": "\"2-4-(8+2-6+(8+4-(1)+8-10))\"",
        "expected_output": "-15"
      },
      {
        "input": "\"(5-(1+(5)))\"",
        "expected_output": "-1"
      },
      {
        "input": "\"(-2)+3\"",
        "expected_output": "1"
      },
      {
        "input": "\"1-(-2)\"",
        "expected_output": "3"
      },
      {
        "input": "\"1+2-3+(4+5-6)\"",
        "expected_output": "3"
      },
      {
        "input": "\"(7)-(0)+(4)\"",
        "expected_output": "11"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def calculate(self, s: str) -> int:\n        ",
      "java": "class Solution {\n    public int calculate(String s) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    int calculate(string s) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return int(result) == int(expected)",
      "java": "return result.equals(expected);",
      "cpp": "return std::stoi(result.asString()) == std::stoi(expected.asString());"
    },
    "explanation": "https://www.youtube.com/watch?v=zsJ-J08Qgdk&pp=ygUZTmVldENvZGUgQmFzaWMgQ2FsY3VsYXRvcg%3D%3D",
    "method_name": "calculate"
  },
  {
    "title": "Sliding Window Maximum",
    "source": "https://leetcode.com/problems/sliding-window-maximum/",
    "description": "Solve the problem titled \"Sliding Window Maximum\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "hard",
    "sample_test_cases": [
      {
        "input": "[1,3,-1,-3,5,3,6,7], 3",
        "expected_output": "[3,3,5,5,6,7]"
      },
      {
        "input": "[1], 1",
        "expected_output": "[1]"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "[1,3,1,2,0,5], 3",
        "expected_output": "[3,3,2,5]"
      },
      {
        "input": "[7,2,4], 2",
        "expected_output": "[7,4]"
      },
      {
        "input": "[1,-1], 1",
        "expected_output": "[1,-1]"
      },
      {
        "input": "[1,2,3,4,5], 5",
        "expected_output": "[5]"
      },
      {
        "input": "[1,2,3,4,5,6], 1",
        "expected_output": "[1,2,3,4,5,6]"
      },
      {
        "input": "[-7,-8,7,5,7,1,6,0], 4",
        "expected_output": "[7,7,7,7,7]"
      },
      {
        "input": "[1,1,1,1], 2",
        "expected_output": "[1,1,1]"
      },
      {
        "input": "[4,2,0,-1,3,5], 3",
        "expected_output": "[4,2,3,5]"
      },
      {
        "input": "[-1,-2,-3,-4], 2",
        "expected_output": "[-1,-2,-3]"
      },
      {
        "input": "[1,2,3,2,1], 3",
        "expected_output": "[3,3,3]"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        ",
      "java": "class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return result == eval(expected)",
      "java": "if (result instanceof int[] && expected instanceof String) {\n    // Parse the expected string as a JSON array\n    Gson gson = new Gson();\n    int[] expectedArray = gson.fromJson((String) expected, int[].class);\n    // Compare the arrays\n    return Arrays.equals((int[]) result, expectedArray);\n}\nreturn false;",
      "cpp": "if (result.isArray() && expected.isArray()) {\n    std::vector<int> resultVec;\n    std::vector<int> expectedVec;\n    for (const auto& val : result) {\n        resultVec.push_back(val.asInt());\n    }\n    for (const auto& val : expected) {\n        expectedVec.push_back(val.asInt());\n    }\n    return resultVec == expectedVec;\n}\nreturn false;"
    },
    "explanation": "https://www.youtube.com/watch?v=DfljaUwZsOk&pp=ygUfTmVldENvZGUgU2xpZGluZyBXaW5kb3cgTWF4aW11bQ%3D%3D",
    "method_name": "maxSlidingWindow"
  },
  {
    "title": "Expression Add Operators",
    "source": "https://leetcode.com/problems/expression-add-operators/",
    "description": "Given a string representing a boolean expression, return the minimum cost or number of operations needed as required by the problem \"Expression Add Operators\".",
    "difficulty": "hard",
    "sample_test_cases": [
      {
        "input": "\"123\", 6",
        "expected_output": "['1+2+3','1*2*3']"
      },
      {
        "input": "\"232\", 8",
        "expected_output": "['2+3*2','2*3+2']"
      },
      {
        "input": "\"3456237490\", 9191",
        "expected_output": "[]"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "\"123\", 6",
        "expected_output": "['1+2+3','1*2*3']"
      },
      {
        "input": "\"232\", 8",
        "expected_output": "['2+3*2','2*3+2']"
      },
      {
        "input": "\"105\", 5",
        "expected_output": "['1*0+5','10-5']"
      },
      {
        "input": "\"00\", 0",
        "expected_output": "['0+0','0-0','0*0']"
      },
      {
        "input": "\"3456237490\", 9191",
        "expected_output": "[]"
      },
      {
        "input": "\"1000000009\", 9",
        "expected_output": "['1*0+0+0+0+0+0+0+0+9','1*0+0+0+0+0+0+0-0+9','1*0+0+0+0+0+0+0*0+9','1*0+0+0+0+0+0-0+0+9','1*0+0+0+0+0+0-0-0+9','1*0+0+0+0+0+0-0*0+9','1*0+0+0+0+0+0*0+0+9','1*0+0+0+0+0+0*0-0+9','1*0+0+0+0+0+0*0*0+9','1*0+0+0+0+0-0+0+0+9','1*0+0+0+0+0-0+0-0+9','1*0+0+0+0+0-0+0*0+9','1*0+0+0+0+0-0-0+0+9','1*0+0+0+0+0-0-0-0+9','1*0+0+0+0+0-0-0*0+9','1*0+0+0+0+0-0*0+0+9','1*0+0+0+0+0-0*0-0+9','1*0+0+0+0+0-0*0*0+9','1*0+0+0+0+0*0+0+0+9','1*0+0+0+0+0*0+0-0+9','1*0+0+0+0+0*0+0*0+9','1*0+0+0+0+0*0-0+0+9','1*0+0+0+0+0*0-0-0+9','1*0+0+0+0+0*0-0*0+9','1*0+0+0+0+0*0*0+0+9','1*0+0+0+0+0*0*0-0+9','1*0+0+0+0+0*0*0*0+9','1*0+0+0+0-0+0+0+0+9','1*0+0+0+0-0+0+0-0+9','1*0+0+0+0-0+0+0*0+9','1*0+0+0+0-0+0-0+0+9','1*0+0+0+0-0+0-0-0+9','1*0+0+0+0-0+0-0*0+9','1*0+0+0+0-0+0*0+0+9','1*0+0+0+0-0+0*0-0+9','1*0+0+0+0-0+0*0*0+9','1*0+0+0+0-0-0+0+0+9','1*0+0+0+0-0-0+0-0+9','1*0+0+0+0-0-0+0*0+9','1*0+0+0+0-0-0-0+0+9','1*0+0+0+0-0-0-0-0+9','1*0+0+0+0-0-0-0*0+9','1*0+0+0+0-0-0*0+0+9','1*0+0+0+0-0-0*0-0+9','1*0+0+0+0-0-0*0*0+9','1*0+0+0+0-0*0+0+0+9','1*0+0+0+0-0*0+0-0+9','1*0+0+0+0-0*0+0*0+9','1*0+0+0+0-0*0-0+0+9','1*0+0+0+0-0*0-0-0+9','1*0+0+0+0-0*0-0*0+9','1*0+0+0+0-0*0*0+0+9','1*0+0+0+0-0*0*0-0+9','1*0+0+0+0-0*0*0*0+9','1*0+0+0+0*0+0+0+0+9','1*0+0+0+0*0+0+0-0+9','1*0+0+0+0*0+0+0*0+9','1*0+0+0+0*0+0-0+0+9','1*0+0+0+0*0+0-0-0+9','1*0+0+0+0*0+0-0*0+9','1*0+0+0+0*0+0*0+0+9','1*0+0+0+0*0+0*0-0+9','1*0+0+0+0*0+0*0*0+9','1*0+0+0+0*0-0+0+0+9','1*0+0+0+0*0-0+0-0+9','1*0+0+0+0*0-0+0*0+9','1*0+0+0+0*0-0-0+0+9','1*0+0+0+0*0-0-0-0+9','1*0+0+0+0*0-0-0*0+9','1*0+0+0+0*0-0*0+0+9','1*0+0+0+0*0-0*0-0+9','1*0+0+0+0*0-0*0*0+9','1*0+0+0+0*0*0+0+0+9','1*0+0+0+0*0*0+0-0+9','1*0+0+0+0*0*0+0*0+9','1*0+0+0+0*0*0-0+0+9','1*0+0+0+0*0*0-0-0+9','1*0+0+0+0*0*0-0*0+9','1*0+0+0+0*0*0*0+0+9','1*0+0+0+0*0*0*0-0+9','1*0+0+0+0*0*0*0*0+9','1*0+0+0-0+0+0+0+0+9','1*0+0+0-0+0+0+0-0+9','1*0+0+0-0+0+0+0*0+9','1*0+0+0-0+0+0-0+0+9','1*0+0+0-0+0+0-0-0+9','1*0+0+0-0+0+0-0*0+9','1*0+0+0-0+0+0*0+0+9','1*0+0+0-0+0+0*0-0+9','1*0+0+0-0+0+0*0*0+9','1*0+0+0-0+0-0+0+0+9','1*0+0+0-0+0-0+0-0+9','1*0+0+0-0+0-0+0*0+9','1*0+0+0-0+0-0-0+0+9','1*0+0+0-0+0-0-0-0+9','1*0+0+0-0+0-0-0*0+9','1*0+0+0-0+0-0*0+0+9','1*0+0+0-0+0-0*0-0+9','1*0+0+0-0+0-0*0*0+9','1*0+0+0-0+0*0+0+0+9','1*0+0+0-0+0*0+0-0+9','1*0+0+0-0+0*0+0*0+9','1*0+0+0-0+0*0-0+0+9','1*0+0+0-0+0*0-0-0+9','1*0+0+0-0+0*0-0*0+9','1*0+0+0-0+0*0*0+0+9','1*0+0+0-0+0*0*0-0+9','1*0+0+0-0+0*0*0*0+9','1*0+0+0-0-0+0+0+0+9','1*0+0+0-0-0+0+0-0+9','1*0+0+0-0-0+0+0*0+9','1*0+0+0-0-0+0-0+0+9','1*0+0+0-0-0+0-0-0+9','1*0+0+0-0-0+0-0*0+9','1*0+0+0-0-0+0*0+0+9','1*0+0+0-0-0+0*0-0+9','1*0+0+0-0-0+0*0*0+9','1*0+0+0-0-0-0+0+0+9','1*0+0+0-0-0-0+0-0+9','1*0+0+0-0-0-0+0*0+9','1*0+0+0-0-0-0-0+0+9','1*0+0+0-0-0-0-0-0+9','1*0+0+0-0-0-0-0*0+9','1*0+0+0-0-0-0*0+0+9','1*0+0+0-0-0-0*0-0+9','1*0+0+0-0-0-0*0*0+9','1*0+0+0-0-0*0+0+0+9','1*0+0+0-0-0*0+0-0+9','1*0+0+0-0-0*0+0*0+9','1*0+0+0-0-0*0-0+0+9','1*0+0+0-0-0*0-0-0+9','1*0+0+0-0-0*0-0*0+9','1*0+0+0-0-0*0*0+0+9','1*0+0+0-0-0*0*0-0+9','1*0+0+0-0-0*0*0*0+9','1*0+0+0-0*0+0+0+0+9','1*0+0+0-0*0+0+0-0+9','1*0+0+0-0*0+0+0*0+9','1*0+0+0-0*0+0-0+0+9','1*0+0+0-0*0+0-0-0+9','1*0+0+0-0*0+0-0*0+9','1*0+0+0-0*0+0*0+0+9','1*0+0+0-0*0+0*0-0+9','1*0+0+0-0*0+0*0*0+9','1*0+0+0-0*0-0+0+0+9','1*0+0+0-0*0-0+0-0+9','1*0+0+0-0*0-0+0*0+9','1*0+0+0-0*0-0-0+0+9','1*0+0+0-0*0-0-0-0+9','1*0+0+0-0*0-0-0*0+9','1*0+0+0-0*0-0*0+0+9','1*0+0+0-0*0-0*0-0+9','1*0+0+0-0*0-0*0*0+9','1*0+0+0-0*0*0+0+0+9','1*0+0+0-0*0*0+0-0+9','1*0+0+0-0*0*0+0*0+9','1*0+0+0-0*0*0-0+0+9','1*0+0+0-0*0*0-0-0+9','1*0+0+0-0*0*0-0*0+9','1*0+0+0-0*0*0*0+0+9','1*0+0+0-0*0*0*0-0+9','1*0+0+0-0*0*0*0*0+9','1*0+0+0*0+0+0+0+0+9','1*0+0+0*0+0+0+0-0+9','1*0+0+0*0+0+0+0*0+9','1*0+0+0*0+0+0-0+0+9','1*0+0+0*0+0+0-0-0+9','1*0+0+0*0+0+0-0*0+9','1*0+0+0*0+0+0*0+0+9','1*0+0+0*0+0+0*0-0+9','1*0+0+0*0+0+0*0*0+9','1*0+0+0*0+0-0+0+0+9','1*0+0+0*0+0-0+0-0+9','1*0+0+0*0+0-0+0*0+9','1*0+0+0*0+0-0-0+0+9','1*0+0+0*0+0-0-0-0+9','1*0+0+0*0+0-0-0*0+9','1*0+0+0*0+0-0*0+0+9','1*0+0+0*0+0-0*0-0+9','1*0+0+0*0+0-0*0*0+9','1*0+0+0*0+0*0+0+0+9','1*0+0+0*0+0*0+0-0+9','1*0+0+0*0+0*0+0*0+9','1*0+0+0*0+0*0-0+0+9','1*0+0+0*0+0*0-0-0+9','1*0+0+0*0+0*0-0*0+9','1*0+0+0*0+0*0*0+0+9','1*0+0+0*0+0*0*0-0+9','1*0+0+0*0+0*0*0*0+9','1*0+0+0*0-0+0+0+0+9','1*0+0+0*0-0+0+0-0+9','1*0+0+0*0-0+0+0*0+9','1*0+0+0*0-0+0-0+0+9','1*0+0+0*0-0+0-0-0+9','1*0+0+0*0-0+0-0*0+9','1*0+0+0*0-0+0*0+0+9','1*0+0+0*0-0+0*0-0+9','1*0+0+0*0-0+0*0*0+9','1*0+0+0*0-0-0+0+0+9','1*0+0+0*0-0-0+0-0+9','1*0+0+0*0-0-0+0*0+9','1*0+0+0*0-0-0-0+0+9','1*0+0+0*0-0-0-0-0+9','1*0+0+0*0-0-0-0*0+9','1*0+0+0*0-0-0*0+0+9','1*0+0+0*0-0-0*0-0+9','1*0+0+0*0-0-0*0*0+9','1*0+0+0*0-0*0+0+0+9','1*0+0+0*0-0*0+0-0+9','1*0+0+0*0-0*0+0*0+9','1*0+0+0*0-0*0-0+0+9','1*0+0+0*0-0*0-0-0+9','1*0+0+0*0-0*0-0*0+9','1*0+0+0*0-0*0*0+0+9','1*0+0+0*0-0*0*0-0+9','1*0+0+0*0-0*0*0*0+9','1*0+0+0*0*0+0+0+0+9','1*0+0+0*0*0+0+0-0+9','1*0+0+0*0*0+0+0*0+9','1*0+0+0*0*0+0-0+0+9','1*0+0+0*0*0+0-0-0+9','1*0+0+0*0*0+0-0*0+9','1*0+0+0*0*0+0*0+0+9','1*0+0+0*0*0+0*0-0+9','1*0+0+0*0*0+0*0*0+9','1*0+0+0*0*0-0+0+0+9','1*0+0+0*0*0-0+0-0+9','1*0+0+0*0*0-0+0*0+9','1*0+0+0*0*0-0-0+0+9','1*0+0+0*0*0-0-0-0+9','1*0+0+0*0*0-0-0*0+9','1*0+0+0*0*0-0*0+0+9','1*0+0+0*0*0-0*0-0+9','1*0+0+0*0*0-0*0*0+9','1*0+0+0*0*0*0+0+0+9','1*0+0+0*0*0*0+0-0+9','1*0+0+0*0*0*0+0*0+9','1*0+0+0*0*0*0-0+0+9','1*0+0+0*0*0*0-0-0+9','1*0+0+0*0*0*0-0*0+9','1*0+0+0*0*0*0*0+0+9','1*0+0+0*0*0*0*0-0+9','1*0+0+0*0*0*0*0*0+9','1*0+0-0+0+0+0+0+0+9','1*0+0-0+0+0+0+0-0+9','1*0+0-0+0+0+0+0*0+9','1*0+0-0+0+0+0-0+0+9','1*0+0-0+0+0+0-0-0+9','1*0+0-0+0+0+0-0*0+9','1*0+0-0+0+0+0*0+0+9','1*0+0-0+0+0+0*0-0+9','1*0+0-0+0+0+0*0*0+9','1*0+0-0+0+0-0+0+0+9','1*0+0-0+0+0-0+0-0+9','1*0+0-0+0+0-0+0*0+9','1*0+0-0+0+0-0-0+0+9','1*0+0-0+0+0-0-0-0+9','1*0+0-0+0+0-0-0*0+9','1*0+0-0+0+0-0*0+0+9','1*0+0-0+0+0-0*0-0+9','1*0+0-0+0+0-0*0*0+9','1*0+0-0+0+0*0+0+0+9','1*0+0-0+0+0*0+0-0+9','1*0+0-0+0+0*0+0*0+9','1*0+0-0+0+0*0-0+0+9','1*0+0-0+0+0*0-0-0+9','1*0+0-0+0+0*0-0*0+9','1*0+0-0+0+0*0*0+0+9','1*0+0-0+0+0*0*0-0+9','1*0+0-0+0+0*0*0*0+9','1*0+0-0+0-0+0+0+0+9','1*0+0-0+0-0+0+0-0+9','1*0+0-0+0-0+0+0*0+9','1*0+0-0+0-0+0-0+0+9','1*0+0-0+0-0+0-0-0+9','1*0+0-0+0-0+0-0*0+9','1*0+0-0+0-0+0*0+0+9','1*0+0-0+0-0+0*0-0+9','1*0+0-0+0-0+0*0*0+9','1*0+0-0+0-0-0+0+0+9','1*0+0-0+0-0-0+0-0+9','1*0+0-0+0-0-0+0*0+9','1*0+0-0+0-0-0-0+0+9','1*0+0-0+0-0-0-0-0+9','1*0+0-0+0-0-0-0*0+9','1*0+0-0+0-0-0*0+0+9','1*0+0-0+0-0-0*0-0+9','1*0+0-0+0-0-0*0*0+9','1*0+0-0+0-0*0+0+0+9','1*0+0-0+0-0*0+0-0+9','1*0+0-0+0-0*0+0*0+9','1*0+0-0+0-0*0-0+0+9','1*0+0-0+0-0*0-0-0+9','1*0+0-0+0-0*0-0*0+9','1*0+0-0+0-0*0*0+0+9','1*0+0-0+0-0*0*0-0+9','1*0+0-0+0-0*0*0*0+9','1*0+0-0+0*0+0+0+0+9','1*0+0-0+0*0+0+0-0+9','1*0+0-0+0*0+0+0*0+9','1*0+0-0+0*0+0-0+0+9','1*0+0-0+0*0+0-0-0+9','1*0+0-0+0*0+0-0*0+9','1*0+0-0+0*0+0*0+0+9','1*0+0-0+0*0+0*0-0+9','1*0+0-0+0*0+0*0*0+9','1*0+0-0+0*0-0+0+0+9','1*0+0-0+0*0-0+0-0+9','1*0+0-0+0*0-0+0*0+9','1*0+0-0+0*0-0-0+0+9','1*0+0-0+0*0-0-0-0+9','1*0+0-0+0*0-0-0*0+9','1*0+0-0+0*0-0*0+0+9','1*0+0-0+0*0-0*0-0+9','1*0+0-0+0*0-0*0*0+9','1*0+0-0+0*0*0+0+0+9','1*0+0-0+0*0*0+0-0+9','1*0+0-0+0*0*0+0*0+9','1*0+0-0+0*0*0-0+0+9','1*0+0-0+0*0*0-0-0+9','1*0+0-0+0*0*0-0*0+9','1*0+0-0+0*0*0*0+0+9','1*0+0-0+0*0*0*0-0+9','1*0+0-0+0*0*0*0*0+9','1*0+0-0-0+0+0+0+0+9','1*0+0-0-0+0+0+0-0+9','1*0+0-0-0+0+0+0*0+9','1*0+0-0-0+0+0-0+0+9','1*0+0-0-0+0+0-0-0+9','1*0+0-0-0+0+0-0*0+9','1*0+0-0-0+0+0*0+0+9','1*0+0-0-0+0+0*0-0+9','1*0+0-0-0+0+0*0*0+9','1*0+0-0-0+0-0+0+0+9','1*0+0-0-0+0-0+0-0+9','1*0+0-0-0+0-0+0*0+9','1*0+0-0-0+0-0-0+0+9','1*0+0-0-0+0-0-0-0+9','1*0+0-0-0+0-0-0*0+9','1*0+0-0-0+0-0*0+0+9','1*0+0-0-0+0-0*0-0+9','1*0+0-0-0+0-0*0*0+9','1*0+0-0-0+0*0+0+0+9','1*0+0-0-0+0*0+0-0+9','1*0+0-0-0+0*0+0*0+9','1*0+0-0-0+0*0-0+0+9','1*0+0-0-0+0*0-0-0+9','1*0+0-0-0+0*0-0*0+9','1*0+0-0-0+0*0*0+0+9','1*0+0-0-0+0*0*0-0+9','1*0+0-0-0+0*0*0*0+9','1*0+0-0-0-0+0+0+0+9','1*0+0-0-0-0+0+0-0+9','1*0+0-0-0-0+0+0*0+9','1*0+0-0-0-0+0-0+0+9','1*0+0-0-0-0+0-0-0+9','1*0+0-0-0-0+0-0*0+9','1*0+0-0-0-0+0*0+0+9','1*0+0-0-0-0+0*0-0+9','1*0+0-0-0-0+0*0*0+9','1*0+0-0-0-0-0+0+0+9','1*0+0-0-0-0-0+0-0+9','1*0+0-0-0-0-0+0*0+9','1*0+0-0-0-0-0-0+0+9','1*0+0-0-0-0-0-0-0+9','1*0+0-0-0-0-0-0*0+9','1*0+0-0-0-0-0*0+0+9','1*0+0-0-0-0-0*0-0+9','1*0+0-0-0-0-0*0*0+9','1*0+0-0-0-0*0+0+0+9','1*0+0-0-0-0*0+0-0+9','1*0+0-0-0-0*0+0*0+9','1*0+0-0-0-0*0-0+0+9','1*0+0-0-0-0*0-0-0+9','1*0+0-0-0-0*0-0*0+9','1*0+0-0-0-0*0*0+0+9','1*0+0-0-0-0*0*0-0+9','1*0+0-0-0-0*0*0*0+9','1*0+0-0-0*0+0+0+0+9','1*0+0-0-0*0+0+0-0+9','1*0+0-0-0*0+0+0*0+9','1*0+0-0-0*0+0-0+0+9','1*0+0-0-0*0+0-0-0+9','1*0+0-0-0*0+0-0*0+9','1*0+0-0-0*0+0*0+0+9','1*0+0-0-0*0+0*0-0+9','1*0+0-0-0*0+0*0*0+9','1*0+0-0-0*0-0+0+0+9','1*0+0-0-0*0-0+0-0+9','1*0+0-0-0*0-0+0*0+9','1*0+0-0-0*0-0-0+0+9','1*0+0-0-0*0-0-0-0+9','1*0+0-0-0*0-0-0*0+9','1*0+0-0-0*0-0*0+0+9','1*0+0-0-0*0-0*0-0+9','1*0+0-0-0*0-0*0*0+9','1*0+0-0-0*0*0+0+0+9','1*0+0-0-0*0*0+0-0+9','1*0+0-0-0*0*0+0*0+9','1*0+0-0-0*0*0-0+0+9','1*0+0-0-0*0*0-0-0+9','1*0+0-0-0*0*0-0*0+9','1*0+0-0-0*0*0*0+0+9','1*0+0-0-0*0*0*0-0+9','1*0+0-0-0*0*0*0*0+9','1*0+0-0*0+0+0+0+0+9','1*0+0-0*0+0+0+0-0+9','1*0+0-0*0+0+0+0*0+9','1*0+0-0*0+0+0-0+0+9','1*0+0-0*0+0+0-0-0+9','1*0+0-0*0+0+0-0*0+9','1*0+0-0*0+0+0*0+0+9','1*0+0-0*0+0+0*0-0+9','1*0+0-0*0+0+0*0*0+9','1*0+0-0*0+0-0+0+0+9','1*0+0-0*0+0-0+0-0+9','1*0+0-0*0+0-0+0*0+9','1*0+0-0*0+0-0-0+0+9','1*0+0-0*0+0-0-0-0+9','1*0+0-0*0+0-0-0*0+9','1*0+0-0*0+0-0*0+0+9','1*0+0-0*0+0-0*0-0+9','1*0+0-0*0+0-0*0*0+9','1*0+0-0*0+0*0+0+0+9','1*0+0-0*0+0*0+0-0+9','1*0+0-0*0+0*0+0*0+9','1*0+0-0*0+0*0-0+0+9','1*0+0-0*0+0*0-0-0+9','1*0+0-0*0+0*0-0*0+9','1*0+0-0*0+0*0*0+0+9','1*0+0-0*0+0*0*0-0+9','1*0+0-0*0+0*0*0*0+9','1*0+0-0*0-0+0+0+0+9','1*0+0-0*0-0+0+0-0+9','1*0+0-0*0-0+0+0*0+9','1*0+0-0*0-0+0-0+0+9','1*0+0-0*0-0+0-0-0+9','1*0+0-0*0-0+0-0*0+9','1*0+0-0*0-0+0*0+0+9','1*0+0-0*0-0+0*0-0+9','1*0+0-0*0-0+0*0*0+9','1*0+0-0*0-0-0+0+0+9','1*0+0-0*0-0-0+0-0+9','1*0+0-0*0-0-0+0*0+9','1*0+0-0*0-0-0-0+0+9','1*0+0-0*0-0-0-0-0+9','1*0+0-0*0-0-0-0*0+9','1*0+0-0*0-0-0*0+0+9','1*0+0-0*0-0-0*0-0+9','1*0+0-0*0-0-0*0*0+9','1*0+0-0*0-0*0+0+0+9','1*0+0-0*0-0*0+0-0+9','1*0+0-0*0-0*0+0*0+9','1*0+0-0*0-0*0-0+0+9','1*0+0-0*0-0*0-0-0+9','1*0+0-0*0-0*0-0*0+9','1*0+0-0*0-0*0*0+0+9','1*0+0-0*0-0*0*0-0+9','1*0+0-0*0-0*0*0*0+9','1*0+0-0*0*0+0+0+0+9','1*0+0-0*0*0+0+0-0+9','1*0+0-0*0*0+0+0*0+9','1*0+0-0*0*0+0-0+0+9','1*0+0-0*0*0+0-0-0+9','1*0+0-0*0*0+0-0*0+9','1*0+0-0*0*0+0*0+0+9','1*0+0-0*0*0+0*0-0+9','1*0+0-0*0*0+0*0*0+9','1*0+0-0*0*0-0+0+0+9','1*0+0-0*0*0-0+0-0+9','1*0+0-0*0*0-0+0*0+9','1*0+0-0*0*0-0-0+0+9','1*0+0-0*0*0-0-0-0+9','1*0+0-0*0*0-0-0*0+9','1*0+0-0*0*0-0*0+0+9','1*0+0-0*0*0-0*0-0+9','1*0+0-0*0*0-0*0*0+9','1*0+0-0*0*0*0+0+0+9','1*0+0-0*0*0*0+0-0+9','1*0+0-0*0*0*0+0*0+9','1*0+0-0*0*0*0-0+0+9','1*0+0-0*0*0*0-0-0+9','1*0+0-0*0*0*0-0*0+9','1*0+0-0*0*0*0*0+0+9','1*0+0-0*0*0*0*0-0+9','1*0+0-0*0*0*0*0*0+9','1*0+0*0+0+0+0+0+0+9','1*0+0*0+0+0+0+0-0+9','1*0+0*0+0+0+0+0*0+9','1*0+0*0+0+0+0-0+0+9','1*0+0*0+0+0+0-0-0+9','1*0+0*0+0+0+0-0*0+9','1*0+0*0+0+0+0*0+0+9','1*0+0*0+0+0+0*0-0+9','1*0+0*0+0+0+0*0*0+9','1*0+0*0+0+0-0+0+0+9','1*0+0*0+0+0-0+0-0+9','1*0+0*0+0+0-0+0*0+9','1*0+0*0+0+0-0-0+0+9','1*0+0*0+0+0-0-0-0+9','1*0+0*0+0+0-0-0*0+9','1*0+0*0+0+0-0*0+0+9','1*0+0*0+0+0-0*0-0+9','1*0+0*0+0+0-0*0*0+9','1*0+0*0+0+0*0+0+0+9','1*0+0*0+0+0*0+0-0+9','1*0+0*0+0+0*0+0*0+9','1*0+0*0+0+0*0-0+0+9','1*0+0*0+0+0*0-0-0+9','1*0+0*0+0+0*0-0*0+9','1*0+0*0+0+0*0*0+0+9','1*0+0*0+0+0*0*0-0+9','1*0+0*0+0+0*0*0*0+9','1*0+0*0+0-0+0+0+0+9','1*0+0*0+0-0+0+0-0+9','1*0+0*0+0-0+0+0*0+9','1*0+0*0+0-0+0-0+0+9','1*0+0*0+0-0+0-0-0+9','1*0+0*0+0-0+0-0*0+9','1*0+0*0+0-0+0*0+0+9','1*0+0*0+0-0+0*0-0+9','1*0+0*0+0-0+0*0*0+9','1*0+0*0+0-0-0+0+0+9','1*0+0*0+0-0-0+0-0+9','1*0+0*0+0-0-0+0*0+9','1*0+0*0+0-0-0-0+0+9','1*0+0*0+0-0-0-0-0+9','1*0+0*0+0-0-0-0*0+9','1*0+0*0+0-0-0*0+0+9','1*0+0*0+0-0-0*0-0+9','1*0+0*0+0-0-0*0*0+9','1*0+0*0+0-0*0+0+0+9','1*0+0*0+0-0*0+0-0+9','1*0+0*0+0-0*0+0*0+9','1*0+0*0+0-0*0-0+0+9','1*0+0*0+0-0*0-0-0+9','1*0+0*0+0-0*0-0*0+9','1*0+0*0+0-0*0*0+0+9','1*0+0*0+0-0*0*0-0+9','1*0+0*0+0-0*0*0*0+9','1*0+0*0+0*0+0+0+0+9','1*0+0*0+0*0+0+0-0+9','1*0+0*0+0*0+0+0*0+9','1*0+0*0+0*0+0-0+0+9','1*0+0*0+0*0+0-0-0+9','1*0+0*0+0*0+0-0*0+9','1*0+0*0+0*0+0*0+0+9','1*0+0*0+0*0+0*0-0+9','1*0+0*0+0*0+0*0*0+9','1*0+0*0+0*0-0+0+0+9','1*0+0*0+0*0-0+0-0+9','1*0+0*0+0*0-0+0*0+9','1*0+0*0+0*0-0-0+0+9','1*0+0*0+0*0-0-0-0+9','1*0+0*0+0*0-0-0*0+9','1*0+0*0+0*0-0*0+0+9','1*0+0*0+0*0-0*0-0+9','1*0+0*0+0*0-0*0*0+9','1*0+0*0+0*0*0+0+0+9','1*0+0*0+0*0*0+0-0+9','1*0+0*0+0*0*0+0*0+9','1*0+0*0+0*0*0-0+0+9','1*0+0*0+0*0*0-0-0+9','1*0+0*0+0*0*0-0*0+9','1*0+0*0+0*0*0*0+0+9','1*0+0*0+0*0*0*0-0+9','1*0+0*0+0*0*0*0*0+9','1*0+0*0-0+0+0+0+0+9','1*0+0*0-0+0+0+0-0+9','1*0+0*0-0+0+0+0*0+9','1*0+0*0-0+0+0-0+0+9','1*0+0*0-0+0+0-0-0+9','1*0+0*0-0+0+0-0*0+9','1*0+0*0-0+0+0*0+0+9','1*0+0*0-0+0+0*0-0+9','1*0+0*0-0+0+0*0*0+9','1*0+0*0-0+0-0+0+0+9','1*0+0*0-0+0-0+0-0+9','1*0+0*0-0+0-0+0*0+9','1*0+0*0-0+0-0-0+0+9','1*0+0*0-0+0-0-0-0+9','1*0+0*0-0+0-0-0*0+9','1*0+0*0-0+0-0*0+0+9','1*0+0*0-0+0-0*0-0+9','1*0+0*0-0+0-0*0*0+9','1*0+0*0-0+0*0+0+0+9','1*0+0*0-0+0*0+0-0+9','1*0+0*0-0+0*0+0*0+9','1*0+0*0-0+0*0-0+0+9','1*0+0*0-0+0*0-0-0+9','1*0+0*0-0+0*0-0*0+9','1*0+0*0-0+0*0*0+0+9','1*0+0*0-0+0*0*0-0+9','1*0+0*0-0+0*0*0*0+9','1*0+0*0-0-0+0+0+0+9','1*0+0*0-0-0+0+0-0+9','1*0+0*0-0-0+0+0*0+9','1*0+0*0-0-0+0-0+0+9','1*0+0*0-0-0+0-0-0+9','1*0+0*0-0-0+0-0*0+9','1*0+0*0-0-0+0*0+0+9','1*0+0*0-0-0+0*0-0+9','1*0+0*0-0-0+0*0*0+9','1*0+0*0-0-0-0+0+0+9','1*0+0*0-0-0-0+0-0+9','1*0+0*0-0-0-0+0*0+9','1*0+0*0-0-0-0-0+0+9','1*0+0*0-0-0-0-0-0+9','1*0+0*0-0-0-0-0*0+9','1*0+0*0-0-0-0*0+0+9','1*0+0*0-0-0-0*0-0+9','1*0+0*0-0-0-0*0*0+9','1*0+0*0-0-0*0+0+0+9','1*0+0*0-0-0*0+0-0+9','1*0+0*0-0-0*0+0*0+9','1*0+0*0-0-0*0-0+0+9','1*0+0*0-0-0*0-0-0+9','1*0+0*0-0-0*0-0*0+9','1*0+0*0-0-0*0*0+0+9','1*0+0*0-0-0*0*0-0+9','1*0+0*0-0-0*0*0*0+9','1*0+0*0-0*0+0+0+0+9','1*0+0*0-0*0+0+0-0+9','1*0+0*0-0*0+0+0*0+9','1*0+0*0-0*0+0-0+0+9','1*0+0*0-0*0+0-0-0+9','1*0+0*0-0*0+0-0*0+9','1*0+0*0-0*0+0*0+0+9','1*0+0*0-0*0+0*0-0+9','1*0+0*0-0*0+0*0*0+9','1*0+0*0-0*0-0+0+0+9','1*0+0*0-0*0-0+0-0+9','1*0+0*0-0*0-0+0*0+9','1*0+0*0-0*0-0-0+0+9','1*0+0*0-0*0-0-0-0+9','1*0+0*0-0*0-0-0*0+9','1*0+0*0-0*0-0*0+0+9','1*0+0*0-0*0-0*0-0+9','1*0+0*0-0*0-0*0*0+9','1*0+0*0-0*0*0+0+0+9','1*0+0*0-0*0*0+0-0+9','1*0+0*0-0*0*0+0*0+9','1*0+0*0-0*0*0-0+0+9','1*0+0*0-0*0*0-0-0+9','1*0+0*0-0*0*0-0*0+9','1*0+0*0-0*0*0*0+0+9','1*0+0*0-0*0*0*0-0+9','1*0+0*0-0*0*0*0*0+9','1*0+0*0*0+0+0+0+0+9','1*0+0*0*0+0+0+0-0+9','1*0+0*0*0+0+0+0*0+9','1*0+0*0*0+0+0-0+0+9','1*0+0*0*0+0+0-0-0+9','1*0+0*0*0+0+0-0*0+9','1*0+0*0*0+0+0*0+0+9','1*0+0*0*0+0+0*0-0+9','1*0+0*0*0+0+0*0*0+9','1*0+0*0*0+0-0+0+0+9','1*0+0*0*0+0-0+0-0+9','1*0+0*0*0+0-0+0*0+9','1*0+0*0*0+0-0-0+0+9','1*0+0*0*0+0-0-0-0+9','1*0+0*0*0+0-0-0*0+9','1*0+0*0*0+0-0*0+0+9','1*0+0*0*0+0-0*0-0+9','1*0+0*0*0+0-0*0*0+9','1*0+0*0*0+0*0+0+0+9','1*0+0*0*0+0*0+0-0+9','1*0+0*0*0+0*0+0*0+9','1*0+0*0*0+0*0-0+0+9','1*0+0*0*0+0*0-0-0+9','1*0+0*0*0+0*0-0*0+9','1*0+0*0*0+0*0*0+0+9','1*0+0*0*0+0*0*0-0+9','1*0+0*0*0+0*0*0*0+9','1*0+0*0*0-0+0+0+0+9','1*0+0*0*0-0+0+0-0+9','1*0+0*0*0-0+0+0*0+9','1*0+0*0*0-0+0-0+0+9','1*0+0*0*0-0+0-0-0+9','1*0+0*0*0-0+0-0*0+9','1*0+0*0*0-0+0*0+0+9','1*0+0*0*0-0+0*0-0+9','1*0+0*0*0-0+0*0*0+9','1*0+0*0*0-0-0+0+0+9','1*0+0*0*0-0-0+0-0+9','1*0+0*0*0-0-0+0*0+9','1*0+0*0*0-0-0-0+0+9','1*0+0*0*0-0-0-0-0+9','1*0+0*0*0-0-0-0*0+9','1*0+0*0*0-0-0*0+0+9','1*0+0*0*0-0-0*0-0+9','1*0+0*0*0-0-0*0*0+9','1*0+0*0*0-0*0+0+0+9','1*0+0*0*0-0*0+0-0+9','1*0+0*0*0-0*0+0*0+9','1*0+0*0*0-0*0-0+0+9','1*0+0*0*0-0*0-0-0+9','1*0+0*0*0-0*0-0*0+9','1*0+0*0*0-0*0*0+0+9','1*0+0*0*0-0*0*0-0+9','1*0+0*0*0-0*0*0*0+9','1*0+0*0*0*0+0+0+0+9','1*0+0*0*0*0+0+0-0+9','1*0+0*0*0*0+0+0*0+9','1*0+0*0*0*0+0-0+0+9','1*0+0*0*0*0+0-0-0+9','1*0+0*0*0*0+0-0*0+9','1*0+0*0*0*0+0*0+0+9','1*0+0*0*0*0+0*0-0+9','1*0+0*0*0*0+0*0*0+9','1*0+0*0*0*0-0+0+0+9','1*0+0*0*0*0-0+0-0+9','1*0+0*0*0*0-0+0*0+9','1*0+0*0*0*0-0-0+0+9','1*0+0*0*0*0-0-0-0+9','1*0+0*0*0*0-0-0*0+9','1*0+0*0*0*0-0*0+0+9','1*0+0*0*0*0-0*0-0+9','1*0+0*0*0*0-0*0*0+9','1*0+0*0*0*0*0+0+0+9','1*0+0*0*0*0*0+0-0+9','1*0+0*0*0*0*0+0*0+9','1*0+0*0*0*0*0-0+0+9','1*0+0*0*0*0*0-0-0+9','1*0+0*0*0*0*0-0*0+9','1*0+0*0*0*0*0*0+0+9','1*0+0*0*0*0*0*0-0+9','1*0+0*0*0*0*0*0*0+9','1*0-0+0+0+0+0+0+0+9','1*0-0+0+0+0+0+0-0+9','1*0-0+0+0+0+0+0*0+9','1*0-0+0+0+0+0-0+0+9','1*0-0+0+0+0+0-0-0+9','1*0-0+0+0+0+0-0*0+9','1*0-0+0+0+0+0*0+0+9','1*0-0+0+0+0+0*0-0+9','1*0-0+0+0+0+0*0*0+9','1*0-0+0+0+0-0+0+0+9','1*0-0+0+0+0-0+0-0+9','1*0-0+0+0+0-0+0*0+9','1*0-0+0+0+0-0-0+0+9','1*0-0+0+0+0-0-0-0+9','1*0-0+0+0+0-0-0*0+9','1*0-0+0+0+0-0*0+0+9','1*0-0+0+0+0-0*0-0+9','1*0-0+0+0+0-0*0*0+9','1*0-0+0+0+0*0+0+0+9','1*0-0+0+0+0*0+0-0+9','1*0-0+0+0+0*0+0*0+9','1*0-0+0+0+0*0-0+0+9','1*0-0+0+0+0*0-0-0+9','1*0-0+0+0+0*0-0*0+9','1*0-0+0+0+0*0*0+0+9','1*0-0+0+0+0*0*0-0+9','1*0-0+0+0+0*0*0*0+9','1*0-0+0+0-0+0+0+0+9','1*0-0+0+0-0+0+0-0+9','1*0-0+0+0-0+0+0*0+9','1*0-0+0+0-0+0-0+0+9','1*0-0+0+0-0+0-0-0+9','1*0-0+0+0-0+0-0*0+9','1*0-0+0+0-0+0*0+0+9','1*0-0+0+0-0+0*0-0+9','1*0-0+0+0-0+0*0*0+9','1*0-0+0+0-0-0+0+0+9','1*0-0+0+0-0-0+0-0+9','1*0-0+0+0-0-0+0*0+9','1*0-0+0+0-0-0-0+0+9','1*0-0+0+0-0-0-0-0+9','1*0-0+0+0-0-0-0*0+9','1*0-0+0+0-0-0*0+0+9','1*0-0+0+0-0-0*0-0+9','1*0-0+0+0-0-0*0*0+9','1*0-0+0+0-0*0+0+0+9','1*0-0+0+0-0*0+0-0+9','1*0-0+0+0-0*0+0*0+9','1*0-0+0+0-0*0-0+0+9','1*0-0+0+0-0*0-0-0+9','1*0-0+0+0-0*0-0*0+9','1*0-0+0+0-0*0*0+0+9','1*0-0+0+0-0*0*0-0+9','1*0-0+0+0-0*0*0*0+9','1*0-0+0+0*0+0+0+0+9','1*0-0+0+0*0+0+0-0+9','1*0-0+0+0*0+0+0*0+9','1*0-0+0+0*0+0-0+0+9','1*0-0+0+0*0+0-0-0+9','1*0-0+0+0*0+0-0*0+9','1*0-0+0+0*0+0*0+0+9','1*0-0+0+0*0+0*0-0+9','1*0-0+0+0*0+0*0*0+9','1*0-0+0+0*0-0+0+0+9','1*0-0+0+0*0-0+0-0+9','1*0-0+0+0*0-0+0*0+9','1*0-0+0+0*0-0-0+0+9','1*0-0+0+0*0-0-0-0+9','1*0-0+0+0*0-0-0*0+9','1*0-0+0+0*0-0*0+0+9','1*0-0+0+0*0-0*0-0+9','1*0-0+0+0*0-0*0*0+9','1*0-0+0+0*0*0+0+0+9','1*0-0+0+0*0*0+0-0+9','1*0-0+0+0*0*0+0*0+9','1*0-0+0+0*0*0-0+0+9','1*0-0+0+0*0*0-0-0+9','1*0-0+0+0*0*0-0*0+9','1*0-0+0+0*0*0*0+0+9','1*0-0+0+0*0*0*0-0+9','1*0-0+0+0*0*0*0*0+9','1*0-0+0-0+0+0+0+0+9','1*0-0+0-0+0+0+0-0+9','1*0-0+0-0+0+0+0*0+9','1*0-0+0-0+0+0-0+0+9','1*0-0+0-0+0+0-0-0+9','1*0-0+0-0+0+0-0*0+9','1*0-0+0-0+0+0*0+0+9','1*0-0+0-0+0+0*0-0+9','1*0-0+0-0+0+0*0*0+9','1*0-0+0-0+0-0+0+0+9','1*0-0+0-0+0-0+0-0+9','1*0-0+0-0+0-0+0*0+9','1*0-0+0-0+0-0-0+0+9','1*0-0+0-0+0-0-0-0+9','1*0-0+0-0+0-0-0*0+9','1*0-0+0-0+0-0*0+0+9','1*0-0+0-0+0-0*0-0+9','1*0-0+0-0+0-0*0*0+9','1*0-0+0-0+0*0+0+0+9','1*0-0+0-0+0*0+0-0+9','1*0-0+0-0+0*0+0*0+9','1*0-0+0-0+0*0-0+0+9','1*0-0+0-0+0*0-0-0+9','1*0-0+0-0+0*0-0*0+9','1*0-0+0-0+0*0*0+0+9','1*0-0+0-0+0*0*0-0+9','1*0-0+0-0+0*0*0*0+9','1*0-0+0-0-0+0+0+0+9','1*0-0+0-0-0+0+0-0+9','1*0-0+0-0-0+0+0*0+9','1*0-0+0-0-0+0-0+0+9','1*0-0+0-0-0+0-0-0+9','1*0-0+0-0-0+0-0*0+9','1*0-0+0-0-0+0*0+0+9','1*0-0+0-0-0+0*0-0+9','1*0-0+0-0-0+0*0*0+9','1*0-0+0-0-0-0+0+0+9','1*0-0+0-0-0-0+0-0+9','1*0-0+0-0-0-0+0*0+9','1*0-0+0-0-0-0-0+0+9','1*0-0+0-0-0-0-0-0+9','1*0-0+0-0-0-0-0*0+9','1*0-0+0-0-0-0*0+0+9','1*0-0+0-0-0-0*0-0+9','1*0-0+0-0-0-0*0*0+9','1*0-0+0-0-0*0+0+0+9','1*0-0+0-0-0*0+0-0+9','1*0-0+0-0-0*0+0*0+9','1*0-0+0-0-0*0-0+0+9','1*0-0+0-0-0*0-0-0+9','1*0-0+0-0-0*0-0*0+9','1*0-0+0-0-0*0*0+0+9','1*0-0+0-0-0*0*0-0+9','1*0-0+0-0-0*0*0*0+9','1*0-0+0-0*0+0+0+0+9','1*0-0+0-0*0+0+0-0+9','1*0-0+0-0*0+0+0*0+9','1*0-0+0-0*0+0-0+0+9','1*0-0+0-0*0+0-0-0+9','1*0-0+0-0*0+0-0*0+9','1*0-0+0-0*0+0*0+0+9','1*0-0+0-0*0+0*0-0+9','1*0-0+0-0*0+0*0*0+9','1*0-0+0-0*0-0+0+0+9','1*0-0+0-0*0-0+0-0+9','1*0-0+0-0*0-0+0*0+9','1*0-0+0-0*0-0-0+0+9','1*0-0+0-0*0-0-0-0+9','1*0-0+0-0*0-0-0*0+9','1*0-0+0-0*0-0*0+0+9','1*0-0+0-0*0-0*0-0+9','1*0-0+0-0*0-0*0*0+9','1*0-0+0-0*0*0+0+0+9','1*0-0+0-0*0*0+0-0+9','1*0-0+0-0*0*0+0*0+9','1*0-0+0-0*0*0-0+0+9','1*0-0+0-0*0*0-0-0+9','1*0-0+0-0*0*0-0*0+9','1*0-0+0-0*0*0*0+0+9','1*0-0+0-0*0*0*0-0+9','1*0-0+0-0*0*0*0*0+9','1*0-0+0*0+0+0+0+0+9','1*0-0+0*0+0+0+0-0+9','1*0-0+0*0+0+0+0*0+9','1*0-0+0*0+0+0-0+0+9','1*0-0+0*0+0+0-0-0+9','1*0-0+0*0+0+0-0*0+9','1*0-0+0*0+0+0*0+0+9','1*0-0+0*0+0+0*0-0+9','1*0-0+0*0+0+0*0*0+9','1*0-0+0*0+0-0+0+0+9','1*0-0+0*0+0-0+0-0+9','1*0-0+0*0+0-0+0*0+9','1*0-0+0*0+0-0-0+0+9','1*0-0+0*0+0-0-0-0+9','1*0-0+0*0+0-0-0*0+9','1*0-0+0*0+0-0*0+0+9','1*0-0+0*0+0-0*0-0+9','1*0-0+0*0+0-0*0*0+9','1*0-0+0*0+0*0+0+0+9','1*0-0+0*0+0*0+0-0+9','1*0-0+0*0+0*0+0*0+9','1*0-0+0*0+0*0-0+0+9','1*0-0+0*0+0*0-0-0+9','1*0-0+0*0+0*0-0*0+9','1*0-0+0*0+0*0*0+0+9','1*0-0+0*0+0*0*0-0+9','1*0-0+0*0+0*0*0*0+9','1*0-0+0*0-0+0+0+0+9','1*0-0+0*0-0+0+0-0+9','1*0-0+0*0-0+0+0*0+9','1*0-0+0*0-0+0-0+0+9','1*0-0+0*0-0+0-0-0+9','1*0-0+0*0-0+0-0*0+9','1*0-0+0*0-0+0*0+0+9','1*0-0+0*0-0+0*0-0+9','1*0-0+0*0-0+0*0*0+9','1*0-0+0*0-0-0+0+0+9','1*0-0+0*0-0-0+0-0+9','1*0-0+0*0-0-0+0*0+9','1*0-0+0*0-0-0-0+0+9','1*0-0+0*0-0-0-0-0+9','1*0-0+0*0-0-0-0*0+9','1*0-0+0*0-0-0*0+0+9','1*0-0+0*0-0-0*0-0+9','1*0-0+0*0-0-0*0*0+9','1*0-0+0*0-0*0+0+0+9','1*0-0+0*0-0*0+0-0+9','1*0-0+0*0-0*0+0*0+9','1*0-0+0*0-0*0-0+0+9','1*0-0+0*0-0*0-0-0+9','1*0-0+0*0-0*0-0*0+9','1*0-0+0*0-0*0*0+0+9','1*0-0+0*0-0*0*0-0+9','1*0-0+0*0-0*0*0*0+9','1*0-0+0*0*0+0+0+0+9','1*0-0+0*0*0+0+0-0+9','1*0-0+0*0*0+0+0*0+9','1*0-0+0*0*0+0-0+0+9','1*0-0+0*0*0+0-0-0+9','1*0-0+0*0*0+0-0*0+9','1*0-0+0*0*0+0*0+0+9','1*0-0+0*0*0+0*0-0+9','1*0-0+0*0*0+0*0*0+9','1*0-0+0*0*0-0+0+0+9','1*0-0+0*0*0-0+0-0+9','1*0-0+0*0*0-0+0*0+9','1*0-0+0*0*0-0-0+0+9','1*0-0+0*0*0-0-0-0+9','1*0-0+0*0*0-0-0*0+9','1*0-0+0*0*0-0*0+0+9','1*0-0+0*0*0-0*0-0+9','1*0-0+0*0*0-0*0*0+9','1*0-0+0*0*0*0+0+0+9','1*0-0+0*0*0*0+0-0+9','1*0-0+0*0*0*0+0*0+9','1*0-0+0*0*0*0-0+0+9','1*0-0+0*0*0*0-0-0+9','1*0-0+0*0*0*0-0*0+9','1*0-0+0*0*0*0*0+0+9','1*0-0+0*0*0*0*0-0+9','1*0-0+0*0*0*0*0*0+9','1*0-0-0+0+0+0+0+0+9','1*0-0-0+0+0+0+0-0+9','1*0-0-0+0+0+0+0*0+9','1*0-0-0+0+0+0-0+0+9','1*0-0-0+0+0+0-0-0+9','1*0-0-0+0+0+0-0*0+9','1*0-0-0+0+0+0*0+0+9','1*0-0-0+0+0+0*0-0+9','1*0-0-0+0+0+0*0*0+9','1*0-0-0+0+0-0+0+0+9','1*0-0-0+0+0-0+0-0+9','1*0-0-0+0+0-0+0*0+9','1*0-0-0+0+0-0-0+0+9','1*0-0-0+0+0-0-0-0+9','1*0-0-0+0+0-0-0*0+9','1*0-0-0+0+0-0*0+0+9','1*0-0-0+0+0-0*0-0+9','1*0-0-0+0+0-0*0*0+9','1*0-0-0+0+0*0+0+0+9','1*0-0-0+0+0*0+0-0+9','1*0-0-0+0+0*0+0*0+9','1*0-0-0+0+0*0-0+0+9','1*0-0-0+0+0*0-0-0+9','1*0-0-0+0+0*0-0*0+9','1*0-0-0+0+0*0*0+0+9','1*0-0-0+0+0*0*0-0+9','1*0-0-0+0+0*0*0*0+9','1*0-0-0+0-0+0+0+0+9','1*0-0-0+0-0+0+0-0+9','1*0-0-0+0-0+0+0*0+9','1*0-0-0+0-0+0-0+0+9','1*0-0-0+0-0+0-0-0+9','1*0-0-0+0-0+0-0*0+9','1*0-0-0+0-0+0*0+0+9','1*0-0-0+0-0+0*0-0+9','1*0-0-0+0-0+0*0*0+9','1*0-0-0+0-0-0+0+0+9','1*0-0-0+0-0-0+0-0+9','1*0-0-0+0-0-0+0*0+9','1*0-0-0+0-0-0-0+0+9','1*0-0-0+0-0-0-0-0+9','1*0-0-0+0-0-0-0*0+9','1*0-0-0+0-0-0*0+0+9','1*0-0-0+0-0-0*0-0+9','1*0-0-0+0-0-0*0*0+9','1*0-0-0+0-0*0+0+0+9','1*0-0-0+0-0*0+0-0+9','1*0-0-0+0-0*0+0*0+9','1*0-0-0+0-0*0-0+0+9','1*0-0-0+0-0*0-0-0+9','1*0-0-0+0-0*0-0*0+9','1*0-0-0+0-0*0*0+0+9','1*0-0-0+0-0*0*0-0+9','1*0-0-0+0-0*0*0*0+9','1*0-0-0+0*0+0+0+0+9','1*0-0-0+0*0+0+0-0+9','1*0-0-0+0*0+0+0*0+9','1*0-0-0+0*0+0-0+0+9','1*0-0-0+0*0+0-0-0+9','1*0-0-0+0*0+0-0*0+9','1*0-0-0+0*0+0*0+0+9','1*0-0-0+0*0+0*0-0+9','1*0-0-0+0*0+0*0*0+9','1*0-0-0+0*0-0+0+0+9','1*0-0-0+0*0-0+0-0+9','1*0-0-0+0*0-0+0*0+9','1*0-0-0+0*0-0-0+0+9','1*0-0-0+0*0-0-0-0+9','1*0-0-0+0*0-0-0*0+9','1*0-0-0+0*0-0*0+0+9','1*0-0-0+0*0-0*0-0+9','1*0-0-0+0*0-0*0*0+9','1*0-0-0+0*0*0+0+0+9','1*0-0-0+0*0*0+0-0+9','1*0-0-0+0*0*0+0*0+9','1*0-0-0+0*0*0-0+0+9','1*0-0-0+0*0*0-0-0+9','1*0-0-0+0*0*0-0*0+9','1*0-0-0+0*0*0*0+0+9','1*0-0-0+0*0*0*0-0+9','1*0-0-0+0*0*0*0*0+9','1*0-0-0-0+0+0+0+0+9','1*0-0-0-0+0+0+0-0+9','1*0-0-0-0+0+0+0*0+9','1*0-0-0-0+0+0-0+0+9','1*0-0-0-0+0+0-0-0+9','1*0-0-0-0+0+0-0*0+9','1*0-0-0-0+0+0*0+0+9','1*0-0-0-0+0+0*0-0+9','1*0-0-0-0+0+0*0*0+9','1*0-0-0-0+0-0+0+0+9','1*0-0-0-0+0-0+0-0+9','1*0-0-0-0+0-0+0*0+9','1*0-0-0-0+0-0-0+0+9','1*0-0-0-0+0-0-0-0+9','1*0-0-0-0+0-0-0*0+9','1*0-0-0-0+0-0*0+0+9','1*0-0-0-0+0-0*0-0+9','1*0-0-0-0+0-0*0*0+9','1*0-0-0-0+0*0+0+0+9','1*0-0-0-0+0*0+0-0+9','1*0-0-0-0+0*0+0*0+9','1*0-0-0-0+0*0-0+0+9','1*0-0-0-0+0*0-0-0+9','1*0-0-0-0+0*0-0*0+9','1*0-0-0-0+0*0*0+0+9','1*0-0-0-0+0*0*0-0+9','1*0-0-0-0+0*0*0*0+9','1*0-0-0-0-0+0+0+0+9','1*0-0-0-0-0+0+0-0+9','1*0-0-0-0-0+0+0*0+9','1*0-0-0-0-0+0-0+0+9','1*0-0-0-0-0+0-0-0+9','1*0-0-0-0-0+0-0*0+9','1*0-0-0-0-0+0*0+0+9','1*0-0-0-0-0+0*0-0+9','1*0-0-0-0-0+0*0*0+9','1*0-0-0-0-0-0+0+0+9','1*0-0-0-0-0-0+0-0+9','1*0-0-0-0-0-0+0*0+9','1*0-0-0-0-0-0-0+0+9','1*0-0-0-0-0-0-0-0+9','1*0-0-0-0-0-0-0*0+9','1*0-0-0-0-0-0*0+0+9','1*0-0-0-0-0-0*0-0+9','1*0-0-0-0-0-0*0*0+9','1*0-0-0-0-0*0+0+0+9','1*0-0-0-0-0*0+0-0+9','1*0-0-0-0-0*0+0*0+9','1*0-0-0-0-0*0-0+0+9','1*0-0-0-0-0*0-0-0+9','1*0-0-0-0-0*0-0*0+9','1*0-0-0-0-0*0*0+0+9','1*0-0-0-0-0*0*0-0+9','1*0-0-0-0-0*0*0*0+9','1*0-0-0-0*0+0+0+0+9','1*0-0-0-0*0+0+0-0+9','1*0-0-0-0*0+0+0*0+9','1*0-0-0-0*0+0-0+0+9','1*0-0-0-0*0+0-0-0+9','1*0-0-0-0*0+0-0*0+9','1*0-0-0-0*0+0*0+0+9','1*0-0-0-0*0+0*0-0+9','1*0-0-0-0*0+0*0*0+9','1*0-0-0-0*0-0+0+0+9','1*0-0-0-0*0-0+0-0+9','1*0-0-0-0*0-0+0*0+9','1*0-0-0-0*0-0-0+0+9','1*0-0-0-0*0-0-0-0+9','1*0-0-0-0*0-0-0*0+9','1*0-0-0-0*0-0*0+0+9','1*0-0-0-0*0-0*0-0+9','1*0-0-0-0*0-0*0*0+9','1*0-0-0-0*0*0+0+0+9','1*0-0-0-0*0*0+0-0+9','1*0-0-0-0*0*0+0*0+9','1*0-0-0-0*0*0-0+0+9','1*0-0-0-0*0*0-0-0+9','1*0-0-0-0*0*0-0*0+9','1*0-0-0-0*0*0*0+0+9','1*0-0-0-0*0*0*0-0+9','1*0-0-0-0*0*0*0*0+9','1*0-0-0*0+0+0+0+0+9','1*0-0-0*0+0+0+0-0+9','1*0-0-0*0+0+0+0*0+9','1*0-0-0*0+0+0-0+0+9','1*0-0-0*0+0+0-0-0+9','1*0-0-0*0+0+0-0*0+9','1*0-0-0*0+0+0*0+0+9','1*0-0-0*0+0+0*0-0+9','1*0-0-0*0+0+0*0*0+9','1*0-0-0*0+0-0+0+0+9','1*0-0-0*0+0-0+0-0+9','1*0-0-0*0+0-0+0*0+9','1*0-0-0*0+0-0-0+0+9','1*0-0-0*0+0-0-0-0+9','1*0-0-0*0+0-0-0*0+9','1*0-0-0*0+0-0*0+0+9','1*0-0-0*0+0-0*0-0+9','1*0-0-0*0+0-0*0*0+9','1*0-0-0*0+0*0+0+0+9','1*0-0-0*0+0*0+0-0+9','1*0-0-0*0+0*0+0*0+9','1*0-0-0*0+0*0-0+0+9','1*0-0-0*0+0*0-0-0+9','1*0-0-0*0+0*0-0*0+9','1*0-0-0*0+0*0*0+0+9','1*0-0-0*0+0*0*0-0+9','1*0-0-0*0+0*0*0*0+9','1*0-0-0*0-0+0+0+0+9','1*0-0-0*0-0+0+0-0+9','1*0-0-0*0-0+0+0*0+9','1*0-0-0*0-0+0-0+0+9','1*0-0-0*0-0+0-0-0+9','1*0-0-0*0-0+0-0*0+9','1*0-0-0*0-0+0*0+0+9','1*0-0-0*0-0+0*0-0+9','1*0-0-0*0-0+0*0*0+9','1*0-0-0*0-0-0+0+0+9','1*0-0-0*0-0-0+0-0+9','1*0-0-0*0-0-0+0*0+9','1*0-0-0*0-0-0-0+0+9','1*0-0-0*0-0-0-0-0+9','1*0-0-0*0-0-0-0*0+9','1*0-0-0*0-0-0*0+0+9','1*0-0-0*0-0-0*0-0+9','1*0-0-0*0-0-0*0*0+9','1*0-0-0*0-0*0+0+0+9','1*0-0-0*0-0*0+0-0+9','1*0-0-0*0-0*0+0*0+9','1*0-0-0*0-0*0-0+0+9','1*0-0-0*0-0*0-0-0+9','1*0-0-0*0-0*0-0*0+9','1*0-0-0*0-0*0*0+0+9','1*0-0-0*0-0*0*0-0+9','1*0-0-0*0-0*0*0*0+9','1*0-0-0*0*0+0+0+0+9','1*0-0-0*0*0+0+0-0+9','1*0-0-0*0*0+0+0*0+9','1*0-0-0*0*0+0-0+0+9','1*0-0-0*0*0+0-0-0+9','1*0-0-0*0*0+0-0*0+9','1*0-0-0*0*0+0*0+0+9','1*0-0-0*0*0+0*0-0+9','1*0-0-0*0*0+0*0*0+9','1*0-0-0*0*0-0+0+0+9','1*0-0-0*0*0-0+0-0+9','1*0-0-0*0*0-0+0*0+9','1*0-0-0*0*0-0-0+0+9','1*0-0-0*0*0-0-0-0+9','1*0-0-0*0*0-0-0*0+9','1*0-0-0*0*0-0*0+0+9','1*0-0-0*0*0-0*0-0+9','1*0-0-0*0*0-0*0*0+9','1*0-0-0*0*0*0+0+0+9','1*0-0-0*0*0*0+0-0+9','1*0-0-0*0*0*0+0*0+9','1*0-0-0*0*0*0-0+0+9','1*0-0-0*0*0*0-0-0+9','1*0-0-0*0*0*0-0*0+9','1*0-0-0*0*0*0*0+0+9','1*0-0-0*0*0*0*0-0+9','1*0-0-0*0*0*0*0*0+9','1*0-0*0+0+0+0+0+0+9','1*0-0*0+0+0+0+0-0+9','1*0-0*0+0+0+0+0*0+9','1*0-0*0+0+0+0-0+0+9','1*0-0*0+0+0+0-0-0+9','1*0-0*0+0+0+0-0*0+9','1*0-0*0+0+0+0*0+0+9','1*0-0*0+0+0+0*0-0+9','1*0-0*0+0+0+0*0*0+9','1*0-0*0+0+0-0+0+0+9','1*0-0*0+0+0-0+0-0+9','1*0-0*0+0+0-0+0*0+9','1*0-0*0+0+0-0-0+0+9','1*0-0*0+0+0-0-0-0+9','1*0-0*0+0+0-0-0*0+9','1*0-0*0+0+0-0*0+0+9','1*0-0*0+0+0-0*0-0+9','1*0-0*0+0+0-0*0*0+9','1*0-0*0+0+0*0+0+0+9','1*0-0*0+0+0*0+0-0+9','1*0-0*0+0+0*0+0*0+9','1*0-0*0+0+0*0-0+0+9','1*0-0*0+0+0*0-0-0+9','1*0-0*0+0+0*0-0*0+9','1*0-0*0+0+0*0*0+0+9','1*0-0*0+0+0*0*0-0+9','1*0-0*0+0+0*0*0*0+9','1*0-0*0+0-0+0+0+0+9','1*0-0*0+0-0+0+0-0+9','1*0-0*0+0-0+0+0*0+9','1*0-0*0+0-0+0-0+0+9','1*0-0*0+0-0+0-0-0+9','1*0-0*0+0-0+0-0*0+9','1*0-0*0+0-0+0*0+0+9','1*0-0*0+0-0+0*0-0+9','1*0-0*0+0-0+0*0*0+9','1*0-0*0+0-0-0+0+0+9','1*0-0*0+0-0-0+0-0+9','1*0-0*0+0-0-0+0*0+9','1*0-0*0+0-0-0-0+0+9','1*0-0*0+0-0-0-0-0+9','1*0-0*0+0-0-0-0*0+9','1*0-0*0+0-0-0*0+0+9','1*0-0*0+0-0-0*0-0+9','1*0-0*0+0-0-0*0*0+9','1*0-0*0+0-0*0+0+0+9','1*0-0*0+0-0*0+0-0+9','1*0-0*0+0-0*0+0*0+9','1*0-0*0+0-0*0-0+0+9','1*0-0*0+0-0*0-0-0+9','1*0-0*0+0-0*0-0*0+9','1*0-0*0+0-0*0*0+0+9','1*0-0*0+0-0*0*0-0+9','1*0-0*0+0-0*0*0*0+9','1*0-0*0+0*0+0+0+0+9','1*0-0*0+0*0+0+0-0+9','1*0-0*0+0*0+0+0*0+9','1*0-0*0+0*0+0-0+0+9','1*0-0*0+0*0+0-0-0+9','1*0-0*0+0*0+0-0*0+9','1*0-0*0+0*0+0*0+0+9','1*0-0*0+0*0+0*0-0+9','1*0-0*0+0*0+0*0*0+9','1*0-0*0+0*0-0+0+0+9','1*0-0*0+0*0-0+0-0+9','1*0-0*0+0*0-0+0*0+9','1*0-0*0+0*0-0-0+0+9','1*0-0*0+0*0-0-0-0+9','1*0-0*0+0*0-0-0*0+9','1*0-0*0+0*0-0*0+0+9','1*0-0*0+0*0-0*0-0+9','1*0-0*0+0*0-0*0*0+9','1*0-0*0+0*0*0+0+0+9','1*0-0*0+0*0*0+0-0+9','1*0-0*0+0*0*0+0*0+9','1*0-0*0+0*0*0-0+0+9','1*0-0*0+0*0*0-0-0+9','1*0-0*0+0*0*0-0*0+9','1*0-0*0+0*0*0*0+0+9','1*0-0*0+0*0*0*0-0+9','1*0-0*0+0*0*0*0*0+9','1*0-0*0-0+0+0+0+0+9','1*0-0*0-0+0+0+0-0+9','1*0-0*0-0+0+0+0*0+9','1*0-0*0-0+0+0-0+0+9','1*0-0*0-0+0+0-0-0+9','1*0-0*0-0+0+0-0*0+9','1*0-0*0-0+0+0*0+0+9','1*0-0*0-0+0+0*0-0+9','1*0-0*0-0+0+0*0*0+9','1*0-0*0-0+0-0+0+0+9','1*0-0*0-0+0-0+0-0+9','1*0-0*0-0+0-0+0*0+9','1*0-0*0-0+0-0-0+0+9','1*0-0*0-0+0-0-0-0+9','1*0-0*0-0+0-0-0*0+9','1*0-0*0-0+0-0*0+0+9','1*0-0*0-0+0-0*0-0+9','1*0-0*0-0+0-0*0*0+9','1*0-0*0-0+0*0+0+0+9','1*0-0*0-0+0*0+0-0+9','1*0-0*0-0+0*0+0*0+9','1*0-0*0-0+0*0-0+0+9','1*0-0*0-0+0*0-0-0+9','1*0-0*0-0+0*0-0*0+9','1*0-0*0-0+0*0*0+0+9','1*0-0*0-0+0*0*0-0+9','1*0-0*0-0+0*0*0*0+9','1*0-0*0-0-0+0+0+0+9','1*0-0*0-0-0+0+0-0+9','1*0-0*0-0-0+0+0*0+9','1*0-0*0-0-0+0-0+0+9','1*0-0*0-0-0+0-0-0+9','1*0-0*0-0-0+0-0*0+9','1*0-0*0-0-0+0*0+0+9','1*0-0*0-0-0+0*0-0+9','1*0-0*0-0-0+0*0*0+9','1*0-0*0-0-0-0+0+0+9','1*0-0*0-0-0-0+0-0+9','1*0-0*0-0-0-0+0*0+9','1*0-0*0-0-0-0-0+0+9','1*0-0*0-0-0-0-0-0+9','1*0-0*0-0-0-0-0*0+9','1*0-0*0-0-0-0*0+0+9','1*0-0*0-0-0-0*0-0+9','1*0-0*0-0-0-0*0*0+9','1*0-0*0-0-0*0+0+0+9','1*0-0*0-0-0*0+0-0+9','1*0-0*0-0-0*0+0*0+9','1*0-0*0-0-0*0-0+0+9','1*0-0*0-0-0*0-0-0+9','1*0-0*0-0-0*0-0*0+9','1*0-0*0-0-0*0*0+0+9','1*0-0*0-0-0*0*0-0+9','1*0-0*0-0-0*0*0*0+9','1*0-0*0-0*0+0+0+0+9','1*0-0*0-0*0+0+0-0+9','1*0-0*0-0*0+0+0*0+9','1*0-0*0-0*0+0-0+0+9','1*0-0*0-0*0+0-0-0+9','1*0-0*0-0*0+0-0*0+9','1*0-0*0-0*0+0*0+0+9','1*0-0*0-0*0+0*0-0+9','1*0-0*0-0*0+0*0*0+9','1*0-0*0-0*0-0+0+0+9','1*0-0*0-0*0-0+0-0+9','1*0-0*0-0*0-0+0*0+9','1*0-0*0-0*0-0-0+0+9','1*0-0*0-0*0-0-0-0+9','1*0-0*0-0*0-0-0*0+9','1*0-0*0-0*0-0*0+0+9','1*0-0*0-0*0-0*0-0+9','1*0-0*0-0*0-0*0*0+9','1*0-0*0-0*0*0+0+0+9','1*0-0*0-0*0*0+0-0+9','1*0-0*0-0*0*0+0*0+9','1*0-0*0-0*0*0-0+0+9','1*0-0*0-0*0*0-0-0+9','1*0-0*0-0*0*0-0*0+9','1*0-0*0-0*0*0*0+0+9','1*0-0*0-0*0*0*0-0+9','1*0-0*0-0*0*0*0*0+9','1*0-0*0*0+0+0+0+0+9','1*0-0*0*0+0+0+0-0+9','1*0-0*0*0+0+0+0*0+9','1*0-0*0*0+0+0-0+0+9','1*0-0*0*0+0+0-0-0+9','1*0-0*0*0+0+0-0*0+9','1*0-0*0*0+0+0*0+0+9','1*0-0*0*0+0+0*0-0+9','1*0-0*0*0+0+0*0*0+9','1*0-0*0*0+0-0+0+0+9','1*0-0*0*0+0-0+0-0+9','1*0-0*0*0+0-0+0*0+9','1*0-0*0*0+0-0-0+0+9','1*0-0*0*0+0-0-0-0+9','1*0-0*0*0+0-0-0*0+9','1*0-0*0*0+0-0*0+0+9','1*0-0*0*0+0-0*0-0+9','1*0-0*0*0+0-0*0*0+9','1*0-0*0*0+0*0+0+0+9','1*0-0*0*0+0*0+0-0+9','1*0-0*0*0+0*0+0*0+9','1*0-0*0*0+0*0-0+0+9','1*0-0*0*0+0*0-0-0+9','1*0-0*0*0+0*0-0*0+9','1*0-0*0*0+0*0*0+0+9','1*0-0*0*0+0*0*0-0+9','1*0-0*0*0+0*0*0*0+9','1*0-0*0*0-0+0+0+0+9','1*0-0*0*0-0+0+0-0+9','1*0-0*0*0-0+0+0*0+9','1*0-0*0*0-0+0-0+0+9','1*0-0*0*0-0+0-0-0+9','1*0-0*0*0-0+0-0*0+9','1*0-0*0*0-0+0*0+0+9','1*0-0*0*0-0+0*0-0+9','1*0-0*0*0-0+0*0*0+9','1*0-0*0*0-0-0+0+0+9','1*0-0*0*0-0-0+0-0+9','1*0-0*0*0-0-0+0*0+9','1*0-0*0*0-0-0-0+0+9','1*0-0*0*0-0-0-0-0+9','1*0-0*0*0-0-0-0*0+9','1*0-0*0*0-0-0*0+0+9','1*0-0*0*0-0-0*0-0+9','1*0-0*0*0-0-0*0*0+9','1*0-0*0*0-0*0+0+0+9','1*0-0*0*0-0*0+0-0+9','1*0-0*0*0-0*0+0*0+9','1*0-0*0*0-0*0-0+0+9','1*0-0*0*0-0*0-0-0+9','1*0-0*0*0-0*0-0*0+9','1*0-0*0*0-0*0*0+0+9','1*0-0*0*0-0*0*0-0+9','1*0-0*0*0-0*0*0*0+9','1*0-0*0*0*0+0+0+0+9','1*0-0*0*0*0+0+0-0+9','1*0-0*0*0*0+0+0*0+9','1*0-0*0*0*0+0-0+0+9','1*0-0*0*0*0+0-0-0+9','1*0-0*0*0*0+0-0*0+9','1*0-0*0*0*0+0*0+0+9','1*0-0*0*0*0+0*0-0+9','1*0-0*0*0*0+0*0*0+9','1*0-0*0*0*0-0+0+0+9','1*0-0*0*0*0-0+0-0+9','1*0-0*0*0*0-0+0*0+9','1*0-0*0*0*0-0-0+0+9','1*0-0*0*0*0-0-0-0+9','1*0-0*0*0*0-0-0*0+9','1*0-0*0*0*0-0*0+0+9','1*0-0*0*0*0-0*0-0+9','1*0-0*0*0*0-0*0*0+9','1*0-0*0*0*0*0+0+0+9','1*0-0*0*0*0*0+0-0+9','1*0-0*0*0*0*0+0*0+9','1*0-0*0*0*0*0-0+0+9','1*0-0*0*0*0*0-0-0+9','1*0-0*0*0*0*0-0*0+9','1*0-0*0*0*0*0*0+0+9','1*0-0*0*0*0*0*0-0+9','1*0-0*0*0*0*0*0*0+9','1*0*0+0+0+0+0+0+0+9','1*0*0+0+0+0+0+0-0+9','1*0*0+0+0+0+0+0*0+9','1*0*0+0+0+0+0-0+0+9','1*0*0+0+0+0+0-0-0+9','1*0*0+0+0+0+0-0*0+9','1*0*0+0+0+0+0*0+0+9','1*0*0+0+0+0+0*0-0+9','1*0*0+0+0+0+0*0*0+9','1*0*0+0+0+0-0+0+0+9','1*0*0+0+0+0-0+0-0+9','1*0*0+0+0+0-0+0*0+9','1*0*0+0+0+0-0-0+0+9','1*0*0+0+0+0-0-0-0+9','1*0*0+0+0+0-0-0*0+9','1*0*0+0+0+0-0*0+0+9','1*0*0+0+0+0-0*0-0+9','1*0*0+0+0+0-0*0*0+9','1*0*0+0+0+0*0+0+0+9','1*0*0+0+0+0*0+0-0+9','1*0*0+0+0+0*0+0*0+9','1*0*0+0+0+0*0-0+0+9','1*0*0+0+0+0*0-0-0+9','1*0*0+0+0+0*0-0*0+9','1*0*0+0+0+0*0*0+0+9','1*0*0+0+0+0*0*0-0+9','1*0*0+0+0+0*0*0*0+9','1*0*0+0+0-0+0+0+0+9','1*0*0+0+0-0+0+0-0+9','1*0*0+0+0-0+0+0*0+9','1*0*0+0+0-0+0-0+0+9','1*0*0+0+0-0+0-0-0+9','1*0*0+0+0-0+0-0*0+9','1*0*0+0+0-0+0*0+0+9','1*0*0+0+0-0+0*0-0+9','1*0*0+0+0-0+0*0*0+9','1*0*0+0+0-0-0+0+0+9','1*0*0+0+0-0-0+0-0+9','1*0*0+0+0-0-0+0*0+9','1*0*0+0+0-0-0-0+0+9','1*0*0+0+0-0-0-0-0+9','1*0*0+0+0-0-0-0*0+9','1*0*0+0+0-0-0*0+0+9','1*0*0+0+0-0-0*0-0+9','1*0*0+0+0-0-0*0*0+9','1*0*0+0+0-0*0+0+0+9','1*0*0+0+0-0*0+0-0+9','1*0*0+0+0-0*0+0*0+9','1*0*0+0+0-0*0-0+0+9','1*0*0+0+0-0*0-0-0+9','1*0*0+0+0-0*0-0*0+9','1*0*0+0+0-0*0*0+0+9','1*0*0+0+0-0*0*0-0+9','1*0*0+0+0-0*0*0*0+9','1*0*0+0+0*0+0+0+0+9','1*0*0+0+0*0+0+0-0+9','1*0*0+0+0*0+0+0*0+9','1*0*0+0+0*0+0-0+0+9','1*0*0+0+0*0+0-0-0+9','1*0*0+0+0*0+0-0*0+9','1*0*0+0+0*0+0*0+0+9','1*0*0+0+0*0+0*0-0+9','1*0*0+0+0*0+0*0*0+9','1*0*0+0+0*0-0+0+0+9','1*0*0+0+0*0-0+0-0+9','1*0*0+0+0*0-0+0*0+9','1*0*0+0+0*0-0-0+0+9','1*0*0+0+0*0-0-0-0+9','1*0*0+0+0*0-0-0*0+9','1*0*0+0+0*0-0*0+0+9','1*0*0+0+0*0-0*0-0+9','1*0*0+0+0*0-0*0*0+9','1*0*0+0+0*0*0+0+0+9','1*0*0+0+0*0*0+0-0+9','1*0*0+0+0*0*0+0*0+9','1*0*0+0+0*0*0-0+0+9','1*0*0+0+0*0*0-0-0+9','1*0*0+0+0*0*0-0*0+9','1*0*0+0+0*0*0*0+0+9','1*0*0+0+0*0*0*0-0+9','1*0*0+0+0*0*0*0*0+9','1*0*0+0-0+0+0+0+0+9','1*0*0+0-0+0+0+0-0+9','1*0*0+0-0+0+0+0*0+9','1*0*0+0-0+0+0-0+0+9','1*0*0+0-0+0+0-0-0+9','1*0*0+0-0+0+0-0*0+9','1*0*0+0-0+0+0*0+0+9','1*0*0+0-0+0+0*0-0+9','1*0*0+0-0+0+0*0*0+9','1*0*0+0-0+0-0+0+0+9','1*0*0+0-0+0-0+0-0+9','1*0*0+0-0+0-0+0*0+9','1*0*0+0-0+0-0-0+0+9','1*0*0+0-0+0-0-0-0+9','1*0*0+0-0+0-0-0*0+9','1*0*0+0-0+0-0*0+0+9','1*0*0+0-0+0-0*0-0+9','1*0*0+0-0+0-0*0*0+9','1*0*0+0-0+0*0+0+0+9','1*0*0+0-0+0*0+0-0+9','1*0*0+0-0+0*0+0*0+9','1*0*0+0-0+0*0-0+0+9','1*0*0+0-0+0*0-0-0+9','1*0*0+0-0+0*0-0*0+9','1*0*0+0-0+0*0*0+0+9','1*0*0+0-0+0*0*0-0+9','1*0*0+0-0+0*0*0*0+9','1*0*0+0-0-0+0+0+0+9','1*0*0+0-0-0+0+0-0+9','1*0*0+0-0-0+0+0*0+9','1*0*0+0-0-0+0-0+0+9','1*0*0+0-0-0+0-0-0+9','1*0*0+0-0-0+0-0*0+9','1*0*0+0-0-0+0*0+0+9','1*0*0+0-0-0+0*0-0+9','1*0*0+0-0-0+0*0*0+9','1*0*0+0-0-0-0+0+0+9','1*0*0+0-0-0-0+0-0+9','1*0*0+0-0-0-0+0*0+9','1*0*0+0-0-0-0-0+0+9','1*0*0+0-0-0-0-0-0+9','1*0*0+0-0-0-0-0*0+9','1*0*0+0-0-0-0*0+0+9','1*0*0+0-0-0-0*0-0+9','1*0*0+0-0-0-0*0*0+9','1*0*0+0-0-0*0+0+0+9','1*0*0+0-0-0*0+0-0+9','1*0*0+0-0-0*0+0*0+9','1*0*0+0-0-0*0-0+0+9','1*0*0+0-0-0*0-0-0+9','1*0*0+0-0-0*0-0*0+9','1*0*0+0-0-0*0*0+0+9','1*0*0+0-0-0*0*0-0+9','1*0*0+0-0-0*0*0*0+9','1*0*0+0-0*0+0+0+0+9','1*0*0+0-0*0+0+0-0+9','1*0*0+0-0*0+0+0*0+9','1*0*0+0-0*0+0-0+0+9','1*0*0+0-0*0+0-0-0+9','1*0*0+0-0*0+0-0*0+9','1*0*0+0-0*0+0*0+0+9','1*0*0+0-0*0+0*0-0+9','1*0*0+0-0*0+0*0*0+9','1*0*0+0-0*0-0+0+0+9','1*0*0+0-0*0-0+0-0+9','1*0*0+0-0*0-0+0*0+9','1*0*0+0-0*0-0-0+0+9','1*0*0+0-0*0-0-0-0+9','1*0*0+0-0*0-0-0*0+9','1*0*0+0-0*0-0*0+0+9','1*0*0+0-0*0-0*0-0+9','1*0*0+0-0*0-0*0*0+9','1*0*0+0-0*0*0+0+0+9','1*0*0+0-0*0*0+0-0+9','1*0*0+0-0*0*0+0*0+9','1*0*0+0-0*0*0-0+0+9','1*0*0+0-0*0*0-0-0+9','1*0*0+0-0*0*0-0*0+9','1*0*0+0-0*0*0*0+0+9','1*0*0+0-0*0*0*0-0+9','1*0*0+0-0*0*0*0*0+9','1*0*0+0*0+0+0+0+0+9','1*0*0+0*0+0+0+0-0+9','1*0*0+0*0+0+0+0*0+9','1*0*0+0*0+0+0-0+0+9','1*0*0+0*0+0+0-0-0+9','1*0*0+0*0+0+0-0*0+9','1*0*0+0*0+0+0*0+0+9','1*0*0+0*0+0+0*0-0+9','1*0*0+0*0+0+0*0*0+9','1*0*0+0*0+0-0+0+0+9','1*0*0+0*0+0-0+0-0+9','1*0*0+0*0+0-0+0*0+9','1*0*0+0*0+0-0-0+0+9','1*0*0+0*0+0-0-0-0+9','1*0*0+0*0+0-0-0*0+9','1*0*0+0*0+0-0*0+0+9','1*0*0+0*0+0-0*0-0+9','1*0*0+0*0+0-0*0*0+9','1*0*0+0*0+0*0+0+0+9','1*0*0+0*0+0*0+0-0+9','1*0*0+0*0+0*0+0*0+9','1*0*0+0*0+0*0-0+0+9','1*0*0+0*0+0*0-0-0+9','1*0*0+0*0+0*0-0*0+9','1*0*0+0*0+0*0*0+0+9','1*0*0+0*0+0*0*0-0+9','1*0*0+0*0+0*0*0*0+9','1*0*0+0*0-0+0+0+0+9','1*0*0+0*0-0+0+0-0+9','1*0*0+0*0-0+0+0*0+9','1*0*0+0*0-0+0-0+0+9','1*0*0+0*0-0+0-0-0+9','1*0*0+0*0-0+0-0*0+9','1*0*0+0*0-0+0*0+0+9','1*0*0+0*0-0+0*0-0+9','1*0*0+0*0-0+0*0*0+9','1*0*0+0*0-0-0+0+0+9','1*0*0+0*0-0-0+0-0+9','1*0*0+0*0-0-0+0*0+9','1*0*0+0*0-0-0-0+0+9','1*0*0+0*0-0-0-0-0+9','1*0*0+0*0-0-0-0*0+9','1*0*0+0*0-0-0*0+0+9','1*0*0+0*0-0-0*0-0+9','1*0*0+0*0-0-0*0*0+9','1*0*0+0*0-0*0+0+0+9','1*0*0+0*0-0*0+0-0+9','1*0*0+0*0-0*0+0*0+9','1*0*0+0*0-0*0-0+0+9','1*0*0+0*0-0*0-0-0+9','1*0*0+0*0-0*0-0*0+9','1*0*0+0*0-0*0*0+0+9','1*0*0+0*0-0*0*0-0+9','1*0*0+0*0-0*0*0*0+9','1*0*0+0*0*0+0+0+0+9','1*0*0+0*0*0+0+0-0+9','1*0*0+0*0*0+0+0*0+9','1*0*0+0*0*0+0-0+0+9','1*0*0+0*0*0+0-0-0+9','1*0*0+0*0*0+0-0*0+9','1*0*0+0*0*0+0*0+0+9','1*0*0+0*0*0+0*0-0+9','1*0*0+0*0*0+0*0*0+9','1*0*0+0*0*0-0+0+0+9','1*0*0+0*0*0-0+0-0+9','1*0*0+0*0*0-0+0*0+9','1*0*0+0*0*0-0-0+0+9','1*0*0+0*0*0-0-0-0+9','1*0*0+0*0*0-0-0*0+9','1*0*0+0*0*0-0*0+0+9','1*0*0+0*0*0-0*0-0+9','1*0*0+0*0*0-0*0*0+9','1*0*0+0*0*0*0+0+0+9','1*0*0+0*0*0*0+0-0+9','1*0*0+0*0*0*0+0*0+9','1*0*0+0*0*0*0-0+0+9','1*0*0+0*0*0*0-0-0+9','1*0*0+0*0*0*0-0*0+9','1*0*0+0*0*0*0*0+0+9','1*0*0+0*0*0*0*0-0+9','1*0*0+0*0*0*0*0*0+9','1*0*0-0+0+0+0+0+0+9','1*0*0-0+0+0+0+0-0+9','1*0*0-0+0+0+0+0*0+9','1*0*0-0+0+0+0-0+0+9','1*0*0-0+0+0+0-0-0+9','1*0*0-0+0+0+0-0*0+9','1*0*0-0+0+0+0*0+0+9','1*0*0-0+0+0+0*0-0+9','1*0*0-0+0+0+0*0*0+9','1*0*0-0+0+0-0+0+0+9','1*0*0-0+0+0-0+0-0+9','1*0*0-0+0+0-0+0*0+9','1*0*0-0+0+0-0-0+0+9','1*0*0-0+0+0-0-0-0+9','1*0*0-0+0+0-0-0*0+9','1*0*0-0+0+0-0*0+0+9','1*0*0-0+0+0-0*0-0+9','1*0*0-0+0+0-0*0*0+9','1*0*0-0+0+0*0+0+0+9','1*0*0-0+0+0*0+0-0+9','1*0*0-0+0+0*0+0*0+9','1*0*0-0+0+0*0-0+0+9','1*0*0-0+0+0*0-0-0+9','1*0*0-0+0+0*0-0*0+9','1*0*0-0+0+0*0*0+0+9','1*0*0-0+0+0*0*0-0+9','1*0*0-0+0+0*0*0*0+9','1*0*0-0+0-0+0+0+0+9','1*0*0-0+0-0+0+0-0+9','1*0*0-0+0-0+0+0*0+9','1*0*0-0+0-0+0-0+0+9','1*0*0-0+0-0+0-0-0+9','1*0*0-0+0-0+0-0*0+9','1*0*0-0+0-0+0*0+0+9','1*0*0-0+0-0+0*0-0+9','1*0*0-0+0-0+0*0*0+9','1*0*0-0+0-0-0+0+0+9','1*0*0-0+0-0-0+0-0+9','1*0*0-0+0-0-0+0*0+9','1*0*0-0+0-0-0-0+0+9','1*0*0-0+0-0-0-0-0+9','1*0*0-0+0-0-0-0*0+9','1*0*0-0+0-0-0*0+0+9','1*0*0-0+0-0-0*0-0+9','1*0*0-0+0-0-0*0*0+9','1*0*0-0+0-0*0+0+0+9','1*0*0-0+0-0*0+0-0+9','1*0*0-0+0-0*0+0*0+9','1*0*0-0+0-0*0-0+0+9','1*0*0-0+0-0*0-0-0+9','1*0*0-0+0-0*0-0*0+9','1*0*0-0+0-0*0*0+0+9','1*0*0-0+0-0*0*0-0+9','1*0*0-0+0-0*0*0*0+9','1*0*0-0+0*0+0+0+0+9','1*0*0-0+0*0+0+0-0+9','1*0*0-0+0*0+0+0*0+9','1*0*0-0+0*0+0-0+0+9','1*0*0-0+0*0+0-0-0+9','1*0*0-0+0*0+0-0*0+9','1*0*0-0+0*0+0*0+0+9','1*0*0-0+0*0+0*0-0+9','1*0*0-0+0*0+0*0*0+9','1*0*0-0+0*0-0+0+0+9','1*0*0-0+0*0-0+0-0+9','1*0*0-0+0*0-0+0*0+9','1*0*0-0+0*0-0-0+0+9','1*0*0-0+0*0-0-0-0+9','1*0*0-0+0*0-0-0*0+9','1*0*0-0+0*0-0*0+0+9','1*0*0-0+0*0-0*0-0+9','1*0*0-0+0*0-0*0*0+9','1*0*0-0+0*0*0+0+0+9','1*0*0-0+0*0*0+0-0+9','1*0*0-0+0*0*0+0*0+9','1*0*0-0+0*0*0-0+0+9','1*0*0-0+0*0*0-0-0+9','1*0*0-0+0*0*0-0*0+9','1*0*0-0+0*0*0*0+0+9','1*0*0-0+0*0*0*0-0+9','1*0*0-0+0*0*0*0*0+9','1*0*0-0-0+0+0+0+0+9','1*0*0-0-0+0+0+0-0+9','1*0*0-0-0+0+0+0*0+9','1*0*0-0-0+0+0-0+0+9','1*0*0-0-0+0+0-0-0+9','1*0*0-0-0+0+0-0*0+9','1*0*0-0-0+0+0*0+0+9','1*0*0-0-0+0+0*0-0+9','1*0*0-0-0+0+0*0*0+9','1*0*0-0-0+0-0+0+0+9','1*0*0-0-0+0-0+0-0+9','1*0*0-0-0+0-0+0*0+9','1*0*0-0-0+0-0-0+0+9','1*0*0-0-0+0-0-0-0+9','1*0*0-0-0+0-0-0*0+9','1*0*0-0-0+0-0*0+0+9','1*0*0-0-0+0-0*0-0+9','1*0*0-0-0+0-0*0*0+9','1*0*0-0-0+0*0+0+0+9','1*0*0-0-0+0*0+0-0+9','1*0*0-0-0+0*0+0*0+9','1*0*0-0-0+0*0-0+0+9','1*0*0-0-0+0*0-0-0+9','1*0*0-0-0+0*0-0*0+9','1*0*0-0-0+0*0*0+0+9','1*0*0-0-0+0*0*0-0+9','1*0*0-0-0+0*0*0*0+9','1*0*0-0-0-0+0+0+0+9','1*0*0-0-0-0+0+0-0+9','1*0*0-0-0-0+0+0*0+9','1*0*0-0-0-0+0-0+0+9','1*0*0-0-0-0+0-0-0+9','1*0*0-0-0-0+0-0*0+9','1*0*0-0-0-0+0*0+0+9','1*0*0-0-0-0+0*0-0+9','1*0*0-0-0-0+0*0*0+9','1*0*0-0-0-0-0+0+0+9','1*0*0-0-0-0-0+0-0+9','1*0*0-0-0-0-0+0*0+9','1*0*0-0-0-0-0-0+0+9','1*0*0-0-0-0-0-0-0+9','1*0*0-0-0-0-0-0*0+9','1*0*0-0-0-0-0*0+0+9','1*0*0-0-0-0-0*0-0+9','1*0*0-0-0-0-0*0*0+9','1*0*0-0-0-0*0+0+0+9','1*0*0-0-0-0*0+0-0+9','1*0*0-0-0-0*0+0*0+9','1*0*0-0-0-0*0-0+0+9','1*0*0-0-0-0*0-0-0+9','1*0*0-0-0-0*0-0*0+9','1*0*0-0-0-0*0*0+0+9','1*0*0-0-0-0*0*0-0+9','1*0*0-0-0-0*0*0*0+9','1*0*0-0-0*0+0+0+0+9','1*0*0-0-0*0+0+0-0+9','1*0*0-0-0*0+0+0*0+9','1*0*0-0-0*0+0-0+0+9','1*0*0-0-0*0+0-0-0+9','1*0*0-0-0*0+0-0*0+9','1*0*0-0-0*0+0*0+0+9','1*0*0-0-0*0+0*0-0+9','1*0*0-0-0*0+0*0*0+9','1*0*0-0-0*0-0+0+0+9','1*0*0-0-0*0-0+0-0+9','1*0*0-0-0*0-0+0*0+9','1*0*0-0-0*0-0-0+0+9','1*0*0-0-0*0-0-0-0+9','1*0*0-0-0*0-0-0*0+9','1*0*0-0-0*0-0*0+0+9','1*0*0-0-0*0-0*0-0+9','1*0*0-0-0*0-0*0*0+9','1*0*0-0-0*0*0+0+0+9','1*0*0-0-0*0*0+0-0+9','1*0*0-0-0*0*0+0*0+9','1*0*0-0-0*0*0-0+0+9','1*0*0-0-0*0*0-0-0+9','1*0*0-0-0*0*0-0*0+9','1*0*0-0-0*0*0*0+0+9','1*0*0-0-0*0*0*0-0+9','1*0*0-0-0*0*0*0*0+9','1*0*0-0*0+0+0+0+0+9','1*0*0-0*0+0+0+0-0+9','1*0*0-0*0+0+0+0*0+9','1*0*0-0*0+0+0-0+0+9','1*0*0-0*0+0+0-0-0+9','1*0*0-0*0+0+0-0*0+9','1*0*0-0*0+0+0*0+0+9','1*0*0-0*0+0+0*0-0+9','1*0*0-0*0+0+0*0*0+9','1*0*0-0*0+0-0+0+0+9','1*0*0-0*0+0-0+0-0+9','1*0*0-0*0+0-0+0*0+9','1*0*0-0*0+0-0-0+0+9','1*0*0-0*0+0-0-0-0+9','1*0*0-0*0+0-0-0*0+9','1*0*0-0*0+0-0*0+0+9','1*0*0-0*0+0-0*0-0+9','1*0*0-0*0+0-0*0*0+9','1*0*0-0*0+0*0+0+0+9','1*0*0-0*0+0*0+0-0+9','1*0*0-0*0+0*0+0*0+9','1*0*0-0*0+0*0-0+0+9','1*0*0-0*0+0*0-0-0+9','1*0*0-0*0+0*0-0*0+9','1*0*0-0*0+0*0*0+0+9','1*0*0-0*0+0*0*0-0+9','1*0*0-0*0+0*0*0*0+9','1*0*0-0*0-0+0+0+0+9','1*0*0-0*0-0+0+0-0+9','1*0*0-0*0-0+0+0*0+9','1*0*0-0*0-0+0-0+0+9','1*0*0-0*0-0+0-0-0+9','1*0*0-0*0-0+0-0*0+9','1*0*0-0*0-0+0*0+0+9','1*0*0-0*0-0+0*0-0+9','1*0*0-0*0-0+0*0*0+9','1*0*0-0*0-0-0+0+0+9','1*0*0-0*0-0-0+0-0+9','1*0*0-0*0-0-0+0*0+9','1*0*0-0*0-0-0-0+0+9','1*0*0-0*0-0-0-0-0+9','1*0*0-0*0-0-0-0*0+9','1*0*0-0*0-0-0*0+0+9','1*0*0-0*0-0-0*0-0+9','1*0*0-0*0-0-0*0*0+9','1*0*0-0*0-0*0+0+0+9','1*0*0-0*0-0*0+0-0+9','1*0*0-0*0-0*0+0*0+9','1*0*0-0*0-0*0-0+0+9','1*0*0-0*0-0*0-0-0+9','1*0*0-0*0-0*0-0*0+9','1*0*0-0*0-0*0*0+0+9','1*0*0-0*0-0*0*0-0+9','1*0*0-0*0-0*0*0*0+9','1*0*0-0*0*0+0+0+0+9','1*0*0-0*0*0+0+0-0+9','1*0*0-0*0*0+0+0*0+9','1*0*0-0*0*0+0-0+0+9','1*0*0-0*0*0+0-0-0+9','1*0*0-0*0*0+0-0*0+9','1*0*0-0*0*0+0*0+0+9','1*0*0-0*0*0+0*0-0+9','1*0*0-0*0*0+0*0*0+9','1*0*0-0*0*0-0+0+0+9','1*0*0-0*0*0-0+0-0+9','1*0*0-0*0*0-0+0*0+9','1*0*0-0*0*0-0-0+0+9','1*0*0-0*0*0-0-0-0+9','1*0*0-0*0*0-0-0*0+9','1*0*0-0*0*0-0*0+0+9','1*0*0-0*0*0-0*0-0+9','1*0*0-0*0*0-0*0*0+9','1*0*0-0*0*0*0+0+0+9','1*0*0-0*0*0*0+0-0+9','1*0*0-0*0*0*0+0*0+9','1*0*0-0*0*0*0-0+0+9','1*0*0-0*0*0*0-0-0+9','1*0*0-0*0*0*0-0*0+9','1*0*0-0*0*0*0*0+0+9','1*0*0-0*0*0*0*0-0+9','1*0*0-0*0*0*0*0*0+9','1*0*0*0+0+0+0+0+0+9','1*0*0*0+0+0+0+0-0+9','1*0*0*0+0+0+0+0*0+9','1*0*0*0+0+0+0-0+0+9','1*0*0*0+0+0+0-0-0+9','1*0*0*0+0+0+0-0*0+9','1*0*0*0+0+0+0*0+0+9','1*0*0*0+0+0+0*0-0+9','1*0*0*0+0+0+0*0*0+9','1*0*0*0+0+0-0+0+0+9','1*0*0*0+0+0-0+0-0+9','1*0*0*0+0+0-0+0*0+9','1*0*0*0+0+0-0-0+0+9','1*0*0*0+0+0-0-0-0+9','1*0*0*0+0+0-0-0*0+9','1*0*0*0+0+0-0*0+0+9','1*0*0*0+0+0-0*0-0+9','1*0*0*0+0+0-0*0*0+9','1*0*0*0+0+0*0+0+0+9','1*0*0*0+0+0*0+0-0+9','1*0*0*0+0+0*0+0*0+9','1*0*0*0+0+0*0-0+0+9','1*0*0*0+0+0*0-0-0+9','1*0*0*0+0+0*0-0*0+9','1*0*0*0+0+0*0*0+0+9','1*0*0*0+0+0*0*0-0+9','1*0*0*0+0+0*0*0*0+9','1*0*0*0+0-0+0+0+0+9','1*0*0*0+0-0+0+0-0+9','1*0*0*0+0-0+0+0*0+9','1*0*0*0+0-0+0-0+0+9','1*0*0*0+0-0+0-0-0+9','1*0*0*0+0-0+0-0*0+9','1*0*0*0+0-0+0*0+0+9','1*0*0*0+0-0+0*0-0+9','1*0*0*0+0-0+0*0*0+9','1*0*0*0+0-0-0+0+0+9','1*0*0*0+0-0-0+0-0+9','1*0*0*0+0-0-0+0*0+9','1*0*0*0+0-0-0-0+0+9','1*0*0*0+0-0-0-0-0+9','1*0*0*0+0-0-0-0*0+9','1*0*0*0+0-0-0*0+0+9','1*0*0*0+0-0-0*0-0+9','1*0*0*0+0-0-0*0*0+9','1*0*0*0+0-0*0+0+0+9','1*0*0*0+0-0*0+0-0+9','1*0*0*0+0-0*0+0*0+9','1*0*0*0+0-0*0-0+0+9','1*0*0*0+0-0*0-0-0+9','1*0*0*0+0-0*0-0*0+9','1*0*0*0+0-0*0*0+0+9','1*0*0*0+0-0*0*0-0+9','1*0*0*0+0-0*0*0*0+9','1*0*0*0+0*0+0+0+0+9','1*0*0*0+0*0+0+0-0+9','1*0*0*0+0*0+0+0*0+9','1*0*0*0+0*0+0-0+0+9','1*0*0*0+0*0+0-0-0+9','1*0*0*0+0*0+0-0*0+9','1*0*0*0+0*0+0*0+0+9','1*0*0*0+0*0+0*0-0+9','1*0*0*0+0*0+0*0*0+9','1*0*0*0+0*0-0+0+0+9','1*0*0*0+0*0-0+0-0+9','1*0*0*0+0*0-0+0*0+9','1*0*0*0+0*0-0-0+0+9','1*0*0*0+0*0-0-0-0+9','1*0*0*0+0*0-0-0*0+9','1*0*0*0+0*0-0*0+0+9','1*0*0*0+0*0-0*0-0+9','1*0*0*0+0*0-0*0*0+9','1*0*0*0+0*0*0+0+0+9','1*0*0*0+0*0*0+0-0+9','1*0*0*0+0*0*0+0*0+9','1*0*0*0+0*0*0-0+0+9','1*0*0*0+0*0*0-0-0+9','1*0*0*0+0*0*0-0*0+9','1*0*0*0+0*0*0*0+0+9','1*0*0*0+0*0*0*0-0+9','1*0*0*0+0*0*0*0*0+9','1*0*0*0-0+0+0+0+0+9','1*0*0*0-0+0+0+0-0+9','1*0*0*0-0+0+0+0*0+9','1*0*0*0-0+0+0-0+0+9','1*0*0*0-0+0+0-0-0+9','1*0*0*0-0+0+0-0*0+9','1*0*0*0-0+0+0*0+0+9','1*0*0*0-0+0+0*0-0+9','1*0*0*0-0+0+0*0*0+9','1*0*0*0-0+0-0+0+0+9','1*0*0*0-0+0-0+0-0+9','1*0*0*0-0+0-0+0*0+9','1*0*0*0-0+0-0-0+0+9','1*0*0*0-0+0-0-0-0+9','1*0*0*0-0+0-0-0*0+9','1*0*0*0-0+0-0*0+0+9','1*0*0*0-0+0-0*0-0+9','1*0*0*0-0+0-0*0*0+9','1*0*0*0-0+0*0+0+0+9','1*0*0*0-0+0*0+0-0+9','1*0*0*0-0+0*0+0*0+9','1*0*0*0-0+0*0-0+0+9','1*0*0*0-0+0*0-0-0+9','1*0*0*0-0+0*0-0*0+9','1*0*0*0-0+0*0*0+0+9','1*0*0*0-0+0*0*0-0+9','1*0*0*0-0+0*0*0*0+9','1*0*0*0-0-0+0+0+0+9','1*0*0*0-0-0+0+0-0+9','1*0*0*0-0-0+0+0*0+9','1*0*0*0-0-0+0-0+0+9','1*0*0*0-0-0+0-0-0+9','1*0*0*0-0-0+0-0*0+9','1*0*0*0-0-0+0*0+0+9','1*0*0*0-0-0+0*0-0+9','1*0*0*0-0-0+0*0*0+9','1*0*0*0-0-0-0+0+0+9','1*0*0*0-0-0-0+0-0+9','1*0*0*0-0-0-0+0*0+9','1*0*0*0-0-0-0-0+0+9','1*0*0*0-0-0-0-0-0+9','1*0*0*0-0-0-0-0*0+9','1*0*0*0-0-0-0*0+0+9','1*0*0*0-0-0-0*0-0+9','1*0*0*0-0-0-0*0*0+9','1*0*0*0-0-0*0+0+0+9','1*0*0*0-0-0*0+0-0+9','1*0*0*0-0-0*0+0*0+9','1*0*0*0-0-0*0-0+0+9','1*0*0*0-0-0*0-0-0+9','1*0*0*0-0-0*0-0*0+9','1*0*0*0-0-0*0*0+0+9','1*0*0*0-0-0*0*0-0+9','1*0*0*0-0-0*0*0*0+9','1*0*0*0-0*0+0+0+0+9','1*0*0*0-0*0+0+0-0+9','1*0*0*0-0*0+0+0*0+9','1*0*0*0-0*0+0-0+0+9','1*0*0*0-0*0+0-0-0+9','1*0*0*0-0*0+0-0*0+9','1*0*0*0-0*0+0*0+0+9','1*0*0*0-0*0+0*0-0+9','1*0*0*0-0*0+0*0*0+9','1*0*0*0-0*0-0+0+0+9','1*0*0*0-0*0-0+0-0+9','1*0*0*0-0*0-0+0*0+9','1*0*0*0-0*0-0-0+0+9','1*0*0*0-0*0-0-0-0+9','1*0*0*0-0*0-0-0*0+9','1*0*0*0-0*0-0*0+0+9','1*0*0*0-0*0-0*0-0+9','1*0*0*0-0*0-0*0*0+9','1*0*0*0-0*0*0+0+0+9','1*0*0*0-0*0*0+0-0+9','1*0*0*0-0*0*0+0*0+9','1*0*0*0-0*0*0-0+0+9','1*0*0*0-0*0*0-0-0+9','1*0*0*0-0*0*0-0*0+9','1*0*0*0-0*0*0*0+0+9','1*0*0*0-0*0*0*0-0+9','1*0*0*0-0*0*0*0*0+9','1*0*0*0*0+0+0+0+0+9','1*0*0*0*0+0+0+0-0+9','1*0*0*0*0+0+0+0*0+9','1*0*0*0*0+0+0-0+0+9','1*0*0*0*0+0+0-0-0+9','1*0*0*0*0+0+0-0*0+9','1*0*0*0*0+0+0*0+0+9','1*0*0*0*0+0+0*0-0+9','1*0*0*0*0+0+0*0*0+9','1*0*0*0*0+0-0+0+0+9','1*0*0*0*0+0-0+0-0+9','1*0*0*0*0+0-0+0*0+9','1*0*0*0*0+0-0-0+0+9','1*0*0*0*0+0-0-0-0+9','1*0*0*0*0+0-0-0*0+9','1*0*0*0*0+0-0*0+0+9','1*0*0*0*0+0-0*0-0+9','1*0*0*0*0+0-0*0*0+9','1*0*0*0*0+0*0+0+0+9','1*0*0*0*0+0*0+0-0+9','1*0*0*0*0+0*0+0*0+9','1*0*0*0*0+0*0-0+0+9','1*0*0*0*0+0*0-0-0+9','1*0*0*0*0+0*0-0*0+9','1*0*0*0*0+0*0*0+0+9','1*0*0*0*0+0*0*0-0+9','1*0*0*0*0+0*0*0*0+9','1*0*0*0*0-0+0+0+0+9','1*0*0*0*0-0+0+0-0+9','1*0*0*0*0-0+0+0*0+9','1*0*0*0*0-0+0-0+0+9','1*0*0*0*0-0+0-0-0+9','1*0*0*0*0-0+0-0*0+9','1*0*0*0*0-0+0*0+0+9','1*0*0*0*0-0+0*0-0+9','1*0*0*0*0-0+0*0*0+9','1*0*0*0*0-0-0+0+0+9','1*0*0*0*0-0-0+0-0+9','1*0*0*0*0-0-0+0*0+9','1*0*0*0*0-0-0-0+0+9','1*0*0*0*0-0-0-0-0+9','1*0*0*0*0-0-0-0*0+9','1*0*0*0*0-0-0*0+0+9','1*0*0*0*0-0-0*0-0+9','1*0*0*0*0-0-0*0*0+9','1*0*0*0*0-0*0+0+0+9','1*0*0*0*0-0*0+0-0+9','1*0*0*0*0-0*0+0*0+9','1*0*0*0*0-0*0-0+0+9','1*0*0*0*0-0*0-0-0+9','1*0*0*0*0-0*0-0*0+9','1*0*0*0*0-0*0*0+0+9','1*0*0*0*0-0*0*0-0+9','1*0*0*0*0-0*0*0*0+9','1*0*0*0*0*0+0+0+0+9','1*0*0*0*0*0+0+0-0+9','1*0*0*0*0*0+0+0*0+9','1*0*0*0*0*0+0-0+0+9','1*0*0*0*0*0+0-0-0+9','1*0*0*0*0*0+0-0*0+9','1*0*0*0*0*0+0*0+0+9','1*0*0*0*0*0+0*0-0+9','1*0*0*0*0*0+0*0*0+9','1*0*0*0*0*0-0+0+0+9','1*0*0*0*0*0-0+0-0+9','1*0*0*0*0*0-0+0*0+9','1*0*0*0*0*0-0-0+0+9','1*0*0*0*0*0-0-0-0+9','1*0*0*0*0*0-0-0*0+9','1*0*0*0*0*0-0*0+0+9','1*0*0*0*0*0-0*0-0+9','1*0*0*0*0*0-0*0*0+9','1*0*0*0*0*0*0+0+0+9','1*0*0*0*0*0*0+0-0+9','1*0*0*0*0*0*0+0*0+9','1*0*0*0*0*0*0-0+0+9','1*0*0*0*0*0*0-0-0+9','1*0*0*0*0*0*0-0*0+9','1*0*0*0*0*0*0*0+0+9','1*0*0*0*0*0*0*0-0+9','1*0*0*0*0*0*0*0*0+9','10*0+0+0+0+0+0+0+9','10*0+0+0+0+0+0-0+9','10*0+0+0+0+0+0*0+9','10*0+0+0+0+0-0+0+9','10*0+0+0+0+0-0-0+9','10*0+0+0+0+0-0*0+9','10*0+0+0+0+0*0+0+9','10*0+0+0+0+0*0-0+9','10*0+0+0+0+0*0*0+9','10*0+0+0+0-0+0+0+9','10*0+0+0+0-0+0-0+9','10*0+0+0+0-0+0*0+9','10*0+0+0+0-0-0+0+9','10*0+0+0+0-0-0-0+9','10*0+0+0+0-0-0*0+9','10*0+0+0+0-0*0+0+9','10*0+0+0+0-0*0-0+9','10*0+0+0+0-0*0*0+9','10*0+0+0+0*0+0+0+9','10*0+0+0+0*0+0-0+9','10*0+0+0+0*0+0*0+9','10*0+0+0+0*0-0+0+9','10*0+0+0+0*0-0-0+9','10*0+0+0+0*0-0*0+9','10*0+0+0+0*0*0+0+9','10*0+0+0+0*0*0-0+9','10*0+0+0+0*0*0*0+9','10*0+0+0-0+0+0+0+9','10*0+0+0-0+0+0-0+9','10*0+0+0-0+0+0*0+9','10*0+0+0-0+0-0+0+9','10*0+0+0-0+0-0-0+9','10*0+0+0-0+0-0*0+9','10*0+0+0-0+0*0+0+9','10*0+0+0-0+0*0-0+9','10*0+0+0-0+0*0*0+9','10*0+0+0-0-0+0+0+9','10*0+0+0-0-0+0-0+9','10*0+0+0-0-0+0*0+9','10*0+0+0-0-0-0+0+9','10*0+0+0-0-0-0-0+9','10*0+0+0-0-0-0*0+9','10*0+0+0-0-0*0+0+9','10*0+0+0-0-0*0-0+9','10*0+0+0-0-0*0*0+9','10*0+0+0-0*0+0+0+9','10*0+0+0-0*0+0-0+9','10*0+0+0-0*0+0*0+9','10*0+0+0-0*0-0+0+9','10*0+0+0-0*0-0-0+9','10*0+0+0-0*0-0*0+9','10*0+0+0-0*0*0+0+9','10*0+0+0-0*0*0-0+9','10*0+0+0-0*0*0*0+9','10*0+0+0*0+0+0+0+9','10*0+0+0*0+0+0-0+9','10*0+0+0*0+0+0*0+9','10*0+0+0*0+0-0+0+9','10*0+0+0*0+0-0-0+9','10*0+0+0*0+0-0*0+9','10*0+0+0*0+0*0+0+9','10*0+0+0*0+0*0-0+9','10*0+0+0*0+0*0*0+9','10*0+0+0*0-0+0+0+9','10*0+0+0*0-0+0-0+9','10*0+0+0*0-0+0*0+9','10*0+0+0*0-0-0+0+9','10*0+0+0*0-0-0-0+9','10*0+0+0*0-0-0*0+9','10*0+0+0*0-0*0+0+9','10*0+0+0*0-0*0-0+9','10*0+0+0*0-0*0*0+9','10*0+0+0*0*0+0+0+9','10*0+0+0*0*0+0-0+9','10*0+0+0*0*0+0*0+9','10*0+0+0*0*0-0+0+9','10*0+0+0*0*0-0-0+9','10*0+0+0*0*0-0*0+9','10*0+0+0*0*0*0+0+9','10*0+0+0*0*0*0-0+9','10*0+0+0*0*0*0*0+9','10*0+0-0+0+0+0+0+9','10*0+0-0+0+0+0-0+9','10*0+0-0+0+0+0*0+9','10*0+0-0+0+0-0+0+9','10*0+0-0+0+0-0-0+9','10*0+0-0+0+0-0*0+9','10*0+0-0+0+0*0+0+9','10*0+0-0+0+0*0-0+9','10*0+0-0+0+0*0*0+9','10*0+0-0+0-0+0+0+9','10*0+0-0+0-0+0-0+9','10*0+0-0+0-0+0*0+9','10*0+0-0+0-0-0+0+9','10*0+0-0+0-0-0-0+9','10*0+0-0+0-0-0*0+9','10*0+0-0+0-0*0+0+9','10*0+0-0+0-0*0-0+9','10*0+0-0+0-0*0*0+9','10*0+0-0+0*0+0+0+9','10*0+0-0+0*0+0-0+9','10*0+0-0+0*0+0*0+9','10*0+0-0+0*0-0+0+9','10*0+0-0+0*0-0-0+9','10*0+0-0+0*0-0*0+9','10*0+0-0+0*0*0+0+9','10*0+0-0+0*0*0-0+9','10*0+0-0+0*0*0*0+9','10*0+0-0-0+0+0+0+9','10*0+0-0-0+0+0-0+9','10*0+0-0-0+0+0*0+9','10*0+0-0-0+0-0+0+9','10*0+0-0-0+0-0-0+9','10*0+0-0-0+0-0*0+9','10*0+0-0-0+0*0+0+9','10*0+0-0-0+0*0-0+9','10*0+0-0-0+0*0*0+9','10*0+0-0-0-0+0+0+9','10*0+0-0-0-0+0-0+9','10*0+0-0-0-0+0*0+9','10*0+0-0-0-0-0+0+9','10*0+0-0-0-0-0-0+9','10*0+0-0-0-0-0*0+9','10*0+0-0-0-0*0+0+9','10*0+0-0-0-0*0-0+9','10*0+0-0-0-0*0*0+9','10*0+0-0-0*0+0+0+9','10*0+0-0-0*0+0-0+9','10*0+0-0-0*0+0*0+9','10*0+0-0-0*0-0+0+9','10*0+0-0-0*0-0-0+9','10*0+0-0-0*0-0*0+9','10*0+0-0-0*0*0+0+9','10*0+0-0-0*0*0-0+9','10*0+0-0-0*0*0*0+9','10*0+0-0*0+0+0+0+9','10*0+0-0*0+0+0-0+9','10*0+0-0*0+0+0*0+9','10*0+0-0*0+0-0+0+9','10*0+0-0*0+0-0-0+9','10*0+0-0*0+0-0*0+9','10*0+0-0*0+0*0+0+9','10*0+0-0*0+0*0-0+9','10*0+0-0*0+0*0*0+9','10*0+0-0*0-0+0+0+9','10*0+0-0*0-0+0-0+9','10*0+0-0*0-0+0*0+9','10*0+0-0*0-0-0+0+9','10*0+0-0*0-0-0-0+9','10*0+0-0*0-0-0*0+9','10*0+0-0*0-0*0+0+9','10*0+0-0*0-0*0-0+9','10*0+0-0*0-0*0*0+9','10*0+0-0*0*0+0+0+9','10*0+0-0*0*0+0-0+9','10*0+0-0*0*0+0*0+9','10*0+0-0*0*0-0+0+9','10*0+0-0*0*0-0-0+9','10*0+0-0*0*0-0*0+9','10*0+0-0*0*0*0+0+9','10*0+0-0*0*0*0-0+9','10*0+0-0*0*0*0*0+9','10*0+0*0+0+0+0+0+9','10*0+0*0+0+0+0-0+9','10*0+0*0+0+0+0*0+9','10*0+0*0+0+0-0+0+9','10*0+0*0+0+0-0-0+9','10*0+0*0+0+0-0*0+9','10*0+0*0+0+0*0+0+9','10*0+0*0+0+0*0-0+9','10*0+0*0+0+0*0*0+9','10*0+0*0+0-0+0+0+9','10*0+0*0+0-0+0-0+9','10*0+0*0+0-0+0*0+9','10*0+0*0+0-0-0+0+9','10*0+0*0+0-0-0-0+9','10*0+0*0+0-0-0*0+9','10*0+0*0+0-0*0+0+9','10*0+0*0+0-0*0-0+9','10*0+0*0+0-0*0*0+9','10*0+0*0+0*0+0+0+9','10*0+0*0+0*0+0-0+9','10*0+0*0+0*0+0*0+9','10*0+0*0+0*0-0+0+9','10*0+0*0+0*0-0-0+9','10*0+0*0+0*0-0*0+9','10*0+0*0+0*0*0+0+9','10*0+0*0+0*0*0-0+9','10*0+0*0+0*0*0*0+9','10*0+0*0-0+0+0+0+9','10*0+0*0-0+0+0-0+9','10*0+0*0-0+0+0*0+9','10*0+0*0-0+0-0+0+9','10*0+0*0-0+0-0-0+9','10*0+0*0-0+0-0*0+9','10*0+0*0-0+0*0+0+9','10*0+0*0-0+0*0-0+9','10*0+0*0-0+0*0*0+9','10*0+0*0-0-0+0+0+9','10*0+0*0-0-0+0-0+9','10*0+0*0-0-0+0*0+9','10*0+0*0-0-0-0+0+9','10*0+0*0-0-0-0-0+9','10*0+0*0-0-0-0*0+9','10*0+0*0-0-0*0+0+9','10*0+0*0-0-0*0-0+9','10*0+0*0-0-0*0*0+9','10*0+0*0-0*0+0+0+9','10*0+0*0-0*0+0-0+9','10*0+0*0-0*0+0*0+9','10*0+0*0-0*0-0+0+9','10*0+0*0-0*0-0-0+9','10*0+0*0-0*0-0*0+9','10*0+0*0-0*0*0+0+9','10*0+0*0-0*0*0-0+9','10*0+0*0-0*0*0*0+9','10*0+0*0*0+0+0+0+9','10*0+0*0*0+0+0-0+9','10*0+0*0*0+0+0*0+9','10*0+0*0*0+0-0+0+9','10*0+0*0*0+0-0-0+9','10*0+0*0*0+0-0*0+9','10*0+0*0*0+0*0+0+9','10*0+0*0*0+0*0-0+9','10*0+0*0*0+0*0*0+9','10*0+0*0*0-0+0+0+9','10*0+0*0*0-0+0-0+9','10*0+0*0*0-0+0*0+9','10*0+0*0*0-0-0+0+9','10*0+0*0*0-0-0-0+9','10*0+0*0*0-0-0*0+9','10*0+0*0*0-0*0+0+9','10*0+0*0*0-0*0-0+9','10*0+0*0*0-0*0*0+9','10*0+0*0*0*0+0+0+9','10*0+0*0*0*0+0-0+9','10*0+0*0*0*0+0*0+9','10*0+0*0*0*0-0+0+9','10*0+0*0*0*0-0-0+9','10*0+0*0*0*0-0*0+9','10*0+0*0*0*0*0+0+9','10*0+0*0*0*0*0-0+9','10*0+0*0*0*0*0*0+9','10*0-0+0+0+0+0+0+9','10*0-0+0+0+0+0-0+9','10*0-0+0+0+0+0*0+9','10*0-0+0+0+0-0+0+9','10*0-0+0+0+0-0-0+9','10*0-0+0+0+0-0*0+9','10*0-0+0+0+0*0+0+9','10*0-0+0+0+0*0-0+9','10*0-0+0+0+0*0*0+9','10*0-0+0+0-0+0+0+9','10*0-0+0+0-0+0-0+9','10*0-0+0+0-0+0*0+9','10*0-0+0+0-0-0+0+9','10*0-0+0+0-0-0-0+9','10*0-0+0+0-0-0*0+9','10*0-0+0+0-0*0+0+9','10*0-0+0+0-0*0-0+9','10*0-0+0+0-0*0*0+9','10*0-0+0+0*0+0+0+9','10*0-0+0+0*0+0-0+9','10*0-0+0+0*0+0*0+9','10*0-0+0+0*0-0+0+9','10*0-0+0+0*0-0-0+9','10*0-0+0+0*0-0*0+9','10*0-0+0+0*0*0+0+9','10*0-0+0+0*0*0-0+9','10*0-0+0+0*0*0*0+9','10*0-0+0-0+0+0+0+9','10*0-0+0-0+0+0-0+9','10*0-0+0-0+0+0*0+9','10*0-0+0-0+0-0+0+9','10*0-0+0-0+0-0-0+9','10*0-0+0-0+0-0*0+9','10*0-0+0-0+0*0+0+9','10*0-0+0-0+0*0-0+9','10*0-0+0-0+0*0*0+9','10*0-0+0-0-0+0+0+9','10*0-0+0-0-0+0-0+9','10*0-0+0-0-0+0*0+9','10*0-0+0-0-0-0+0+9','10*0-0+0-0-0-0-0+9','10*0-0+0-0-0-0*0+9','10*0-0+0-0-0*0+0+9','10*0-0+0-0-0*0-0+9','10*0-0+0-0-0*0*0+9','10*0-0+0-0*0+0+0+9','10*0-0+0-0*0+0-0+9','10*0-0+0-0*0+0*0+9','10*0-0+0-0*0-0+0+9','10*0-0+0-0*0-0-0+9','10*0-0+0-0*0-0*0+9','10*0-0+0-0*0*0+0+9','10*0-0+0-0*0*0-0+9','10*0-0+0-0*0*0*0+9','10*0-0+0*0+0+0+0+9','10*0-0+0*0+0+0-0+9','10*0-0+0*0+0+0*0+9','10*0-0+0*0+0-0+0+9','10*0-0+0*0+0-0-0+9','10*0-0+0*0+0-0*0+9','10*0-0+0*0+0*0+0+9','10*0-0+0*0+0*0-0+9','10*0-0+0*0+0*0*0+9','10*0-0+0*0-0+0+0+9','10*0-0+0*0-0+0-0+9','10*0-0+0*0-0+0*0+9','10*0-0+0*0-0-0+0+9','10*0-0+0*0-0-0-0+9','10*0-0+0*0-0-0*0+9','10*0-0+0*0-0*0+0+9','10*0-0+0*0-0*0-0+9','10*0-0+0*0-0*0*0+9','10*0-0+0*0*0+0+0+9','10*0-0+0*0*0+0-0+9','10*0-0+0*0*0+0*0+9','10*0-0+0*0*0-0+0+9','10*0-0+0*0*0-0-0+9','10*0-0+0*0*0-0*0+9','10*0-0+0*0*0*0+0+9','10*0-0+0*0*0*0-0+9','10*0-0+0*0*0*0*0+9','10*0-0-0+0+0+0+0+9','10*0-0-0+0+0+0-0+9','10*0-0-0+0+0+0*0+9','10*0-0-0+0+0-0+0+9','10*0-0-0+0+0-0-0+9','10*0-0-0+0+0-0*0+9','10*0-0-0+0+0*0+0+9','10*0-0-0+0+0*0-0+9','10*0-0-0+0+0*0*0+9','10*0-0-0+0-0+0+0+9','10*0-0-0+0-0+0-0+9','10*0-0-0+0-0+0*0+9','10*0-0-0+0-0-0+0+9','10*0-0-0+0-0-0-0+9','10*0-0-0+0-0-0*0+9','10*0-0-0+0-0*0+0+9','10*0-0-0+0-0*0-0+9','10*0-0-0+0-0*0*0+9','10*0-0-0+0*0+0+0+9','10*0-0-0+0*0+0-0+9','10*0-0-0+0*0+0*0+9','10*0-0-0+0*0-0+0+9','10*0-0-0+0*0-0-0+9','10*0-0-0+0*0-0*0+9','10*0-0-0+0*0*0+0+9','10*0-0-0+0*0*0-0+9','10*0-0-0+0*0*0*0+9','10*0-0-0-0+0+0+0+9','10*0-0-0-0+0+0-0+9','10*0-0-0-0+0+0*0+9','10*0-0-0-0+0-0+0+9','10*0-0-0-0+0-0-0+9','10*0-0-0-0+0-0*0+9','10*0-0-0-0+0*0+0+9','10*0-0-0-0+0*0-0+9','10*0-0-0-0+0*0*0+9','10*0-0-0-0-0+0+0+9','10*0-0-0-0-0+0-0+9','10*0-0-0-0-0+0*0+9','10*0-0-0-0-0-0+0+9','10*0-0-0-0-0-0-0+9','10*0-0-0-0-0-0*0+9','10*0-0-0-0-0*0+0+9','10*0-0-0-0-0*0-0+9','10*0-0-0-0-0*0*0+9','10*0-0-0-0*0+0+0+9','10*0-0-0-0*0+0-0+9','10*0-0-0-0*0+0*0+9','10*0-0-0-0*0-0+0+9','10*0-0-0-0*0-0-0+9','10*0-0-0-0*0-0*0+9','10*0-0-0-0*0*0+0+9','10*0-0-0-0*0*0-0+9','10*0-0-0-0*0*0*0+9','10*0-0-0*0+0+0+0+9','10*0-0-0*0+0+0-0+9','10*0-0-0*0+0+0*0+9','10*0-0-0*0+0-0+0+9','10*0-0-0*0+0-0-0+9','10*0-0-0*0+0-0*0+9','10*0-0-0*0+0*0+0+9','10*0-0-0*0+0*0-0+9','10*0-0-0*0+0*0*0+9','10*0-0-0*0-0+0+0+9','10*0-0-0*0-0+0-0+9','10*0-0-0*0-0+0*0+9','10*0-0-0*0-0-0+0+9','10*0-0-0*0-0-0-0+9','10*0-0-0*0-0-0*0+9','10*0-0-0*0-0*0+0+9','10*0-0-0*0-0*0-0+9','10*0-0-0*0-0*0*0+9','10*0-0-0*0*0+0+0+9','10*0-0-0*0*0+0-0+9','10*0-0-0*0*0+0*0+9','10*0-0-0*0*0-0+0+9','10*0-0-0*0*0-0-0+9','10*0-0-0*0*0-0*0+9','10*0-0-0*0*0*0+0+9','10*0-0-0*0*0*0-0+9','10*0-0-0*0*0*0*0+9','10*0-0*0+0+0+0+0+9','10*0-0*0+0+0+0-0+9','10*0-0*0+0+0+0*0+9','10*0-0*0+0+0-0+0+9','10*0-0*0+0+0-0-0+9','10*0-0*0+0+0-0*0+9','10*0-0*0+0+0*0+0+9','10*0-0*0+0+0*0-0+9','10*0-0*0+0+0*0*0+9','10*0-0*0+0-0+0+0+9','10*0-0*0+0-0+0-0+9','10*0-0*0+0-0+0*0+9','10*0-0*0+0-0-0+0+9','10*0-0*0+0-0-0-0+9','10*0-0*0+0-0-0*0+9','10*0-0*0+0-0*0+0+9','10*0-0*0+0-0*0-0+9','10*0-0*0+0-0*0*0+9','10*0-0*0+0*0+0+0+9','10*0-0*0+0*0+0-0+9','10*0-0*0+0*0+0*0+9','10*0-0*0+0*0-0+0+9','10*0-0*0+0*0-0-0+9','10*0-0*0+0*0-0*0+9','10*0-0*0+0*0*0+0+9','10*0-0*0+0*0*0-0+9','10*0-0*0+0*0*0*0+9','10*0-0*0-0+0+0+0+9','10*0-0*0-0+0+0-0+9','10*0-0*0-0+0+0*0+9','10*0-0*0-0+0-0+0+9','10*0-0*0-0+0-0-0+9','10*0-0*0-0+0-0*0+9','10*0-0*0-0+0*0+0+9','10*0-0*0-0+0*0-0+9','10*0-0*0-0+0*0*0+9','10*0-0*0-0-0+0+0+9','10*0-0*0-0-0+0-0+9','10*0-0*0-0-0+0*0+9','10*0-0*0-0-0-0+0+9','10*0-0*0-0-0-0-0+9','10*0-0*0-0-0-0*0+9','10*0-0*0-0-0*0+0+9','10*0-0*0-0-0*0-0+9','10*0-0*0-0-0*0*0+9','10*0-0*0-0*0+0+0+9','10*0-0*0-0*0+0-0+9','10*0-0*0-0*0+0*0+9','10*0-0*0-0*0-0+0+9','10*0-0*0-0*0-0-0+9','10*0-0*0-0*0-0*0+9','10*0-0*0-0*0*0+0+9','10*0-0*0-0*0*0-0+9','10*0-0*0-0*0*0*0+9','10*0-0*0*0+0+0+0+9','10*0-0*0*0+0+0-0+9','10*0-0*0*0+0+0*0+9','10*0-0*0*0+0-0+0+9','10*0-0*0*0+0-0-0+9','10*0-0*0*0+0-0*0+9','10*0-0*0*0+0*0+0+9','10*0-0*0*0+0*0-0+9','10*0-0*0*0+0*0*0+9','10*0-0*0*0-0+0+0+9','10*0-0*0*0-0+0-0+9','10*0-0*0*0-0+0*0+9','10*0-0*0*0-0-0+0+9','10*0-0*0*0-0-0-0+9','10*0-0*0*0-0-0*0+9','10*0-0*0*0-0*0+0+9','10*0-0*0*0-0*0-0+9','10*0-0*0*0-0*0*0+9','10*0-0*0*0*0+0+0+9','10*0-0*0*0*0+0-0+9','10*0-0*0*0*0+0*0+9','10*0-0*0*0*0-0+0+9','10*0-0*0*0*0-0-0+9','10*0-0*0*0*0-0*0+9','10*0-0*0*0*0*0+0+9','10*0-0*0*0*0*0-0+9','10*0-0*0*0*0*0*0+9','10*0*0+0+0+0+0+0+9','10*0*0+0+0+0+0-0+9','10*0*0+0+0+0+0*0+9','10*0*0+0+0+0-0+0+9','10*0*0+0+0+0-0-0+9','10*0*0+0+0+0-0*0+9','10*0*0+0+0+0*0+0+9','10*0*0+0+0+0*0-0+9','10*0*0+0+0+0*0*0+9','10*0*0+0+0-0+0+0+9','10*0*0+0+0-0+0-0+9','10*0*0+0+0-0+0*0+9','10*0*0+0+0-0-0+0+9','10*0*0+0+0-0-0-0+9','10*0*0+0+0-0-0*0+9','10*0*0+0+0-0*0+0+9','10*0*0+0+0-0*0-0+9','10*0*0+0+0-0*0*0+9','10*0*0+0+0*0+0+0+9','10*0*0+0+0*0+0-0+9','10*0*0+0+0*0+0*0+9','10*0*0+0+0*0-0+0+9','10*0*0+0+0*0-0-0+9','10*0*0+0+0*0-0*0+9','10*0*0+0+0*0*0+0+9','10*0*0+0+0*0*0-0+9','10*0*0+0+0*0*0*0+9','10*0*0+0-0+0+0+0+9','10*0*0+0-0+0+0-0+9','10*0*0+0-0+0+0*0+9','10*0*0+0-0+0-0+0+9','10*0*0+0-0+0-0-0+9','10*0*0+0-0+0-0*0+9','10*0*0+0-0+0*0+0+9','10*0*0+0-0+0*0-0+9','10*0*0+0-0+0*0*0+9','10*0*0+0-0-0+0+0+9','10*0*0+0-0-0+0-0+9','10*0*0+0-0-0+0*0+9','10*0*0+0-0-0-0+0+9','10*0*0+0-0-0-0-0+9','10*0*0+0-0-0-0*0+9','10*0*0+0-0-0*0+0+9','10*0*0+0-0-0*0-0+9','10*0*0+0-0-0*0*0+9','10*0*0+0-0*0+0+0+9','10*0*0+0-0*0+0-0+9','10*0*0+0-0*0+0*0+9','10*0*0+0-0*0-0+0+9','10*0*0+0-0*0-0-0+9','10*0*0+0-0*0-0*0+9','10*0*0+0-0*0*0+0+9','10*0*0+0-0*0*0-0+9','10*0*0+0-0*0*0*0+9','10*0*0+0*0+0+0+0+9','10*0*0+0*0+0+0-0+9','10*0*0+0*0+0+0*0+9','10*0*0+0*0+0-0+0+9','10*0*0+0*0+0-0-0+9','10*0*0+0*0+0-0*0+9','10*0*0+0*0+0*0+0+9','10*0*0+0*0+0*0-0+9','10*0*0+0*0+0*0*0+9','10*0*0+0*0-0+0+0+9','10*0*0+0*0-0+0-0+9','10*0*0+0*0-0+0*0+9','10*0*0+0*0-0-0+0+9','10*0*0+0*0-0-0-0+9','10*0*0+0*0-0-0*0+9','10*0*0+0*0-0*0+0+9','10*0*0+0*0-0*0-0+9','10*0*0+0*0-0*0*0+9','10*0*0+0*0*0+0+0+9','10*0*0+0*0*0+0-0+9','10*0*0+0*0*0+0*0+9','10*0*0+0*0*0-0+0+9','10*0*0+0*0*0-0-0+9','10*0*0+0*0*0-0*0+9','10*0*0+0*0*0*0+0+9','10*0*0+0*0*0*0-0+9','10*0*0+0*0*0*0*0+9','10*0*0-0+0+0+0+0+9','10*0*0-0+0+0+0-0+9','10*0*0-0+0+0+0*0+9','10*0*0-0+0+0-0+0+9','10*0*0-0+0+0-0-0+9','10*0*0-0+0+0-0*0+9','10*0*0-0+0+0*0+0+9','10*0*0-0+0+0*0-0+9','10*0*0-0+0+0*0*0+9','10*0*0-0+0-0+0+0+9','10*0*0-0+0-0+0-0+9','10*0*0-0+0-0+0*0+9','10*0*0-0+0-0-0+0+9','10*0*0-0+0-0-0-0+9','10*0*0-0+0-0-0*0+9','10*0*0-0+0-0*0+0+9','10*0*0-0+0-0*0-0+9','10*0*0-0+0-0*0*0+9','10*0*0-0+0*0+0+0+9','10*0*0-0+0*0+0-0+9','10*0*0-0+0*0+0*0+9','10*0*0-0+0*0-0+0+9','10*0*0-0+0*0-0-0+9','10*0*0-0+0*0-0*0+9','10*0*0-0+0*0*0+0+9','10*0*0-0+0*0*0-0+9','10*0*0-0+0*0*0*0+9','10*0*0-0-0+0+0+0+9','10*0*0-0-0+0+0-0+9','10*0*0-0-0+0+0*0+9','10*0*0-0-0+0-0+0+9','10*0*0-0-0+0-0-0+9','10*0*0-0-0+0-0*0+9','10*0*0-0-0+0*0+0+9','10*0*0-0-0+0*0-0+9','10*0*0-0-0+0*0*0+9','10*0*0-0-0-0+0+0+9','10*0*0-0-0-0+0-0+9','10*0*0-0-0-0+0*0+9','10*0*0-0-0-0-0+0+9','10*0*0-0-0-0-0-0+9','10*0*0-0-0-0-0*0+9','10*0*0-0-0-0*0+0+9','10*0*0-0-0-0*0-0+9','10*0*0-0-0-0*0*0+9','10*0*0-0-0*0+0+0+9','10*0*0-0-0*0+0-0+9','10*0*0-0-0*0+0*0+9','10*0*0-0-0*0-0+0+9','10*0*0-0-0*0-0-0+9','10*0*0-0-0*0-0*0+9','10*0*0-0-0*0*0+0+9','10*0*0-0-0*0*0-0+9','10*0*0-0-0*0*0*0+9','10*0*0-0*0+0+0+0+9','10*0*0-0*0+0+0-0+9','10*0*0-0*0+0+0*0+9','10*0*0-0*0+0-0+0+9','10*0*0-0*0+0-0-0+9','10*0*0-0*0+0-0*0+9','10*0*0-0*0+0*0+0+9','10*0*0-0*0+0*0-0+9','10*0*0-0*0+0*0*0+9','10*0*0-0*0-0+0+0+9','10*0*0-0*0-0+0-0+9','10*0*0-0*0-0+0*0+9','10*0*0-0*0-0-0+0+9','10*0*0-0*0-0-0-0+9','10*0*0-0*0-0-0*0+9','10*0*0-0*0-0*0+0+9','10*0*0-0*0-0*0-0+9','10*0*0-0*0-0*0*0+9','10*0*0-0*0*0+0+0+9','10*0*0-0*0*0+0-0+9','10*0*0-0*0*0+0*0+9','10*0*0-0*0*0-0+0+9','10*0*0-0*0*0-0-0+9','10*0*0-0*0*0-0*0+9','10*0*0-0*0*0*0+0+9','10*0*0-0*0*0*0-0+9','10*0*0-0*0*0*0*0+9','10*0*0*0+0+0+0+0+9','10*0*0*0+0+0+0-0+9','10*0*0*0+0+0+0*0+9','10*0*0*0+0+0-0+0+9','10*0*0*0+0+0-0-0+9','10*0*0*0+0+0-0*0+9','10*0*0*0+0+0*0+0+9','10*0*0*0+0+0*0-0+9','10*0*0*0+0+0*0*0+9','10*0*0*0+0-0+0+0+9','10*0*0*0+0-0+0-0+9','10*0*0*0+0-0+0*0+9','10*0*0*0+0-0-0+0+9','10*0*0*0+0-0-0-0+9','10*0*0*0+0-0-0*0+9','10*0*0*0+0-0*0+0+9','10*0*0*0+0-0*0-0+9','10*0*0*0+0-0*0*0+9','10*0*0*0+0*0+0+0+9','10*0*0*0+0*0+0-0+9','10*0*0*0+0*0+0*0+9','10*0*0*0+0*0-0+0+9','10*0*0*0+0*0-0-0+9','10*0*0*0+0*0-0*0+9','10*0*0*0+0*0*0+0+9','10*0*0*0+0*0*0-0+9','10*0*0*0+0*0*0*0+9','10*0*0*0-0+0+0+0+9','10*0*0*0-0+0+0-0+9','10*0*0*0-0+0+0*0+9','10*0*0*0-0+0-0+0+9','10*0*0*0-0+0-0-0+9','10*0*0*0-0+0-0*0+9','10*0*0*0-0+0*0+0+9','10*0*0*0-0+0*0-0+9','10*0*0*0-0+0*0*0+9','10*0*0*0-0-0+0+0+9','10*0*0*0-0-0+0-0+9','10*0*0*0-0-0+0*0+9','10*0*0*0-0-0-0+0+9','10*0*0*0-0-0-0-0+9','10*0*0*0-0-0-0*0+9','10*0*0*0-0-0*0+0+9','10*0*0*0-0-0*0-0+9','10*0*0*0-0-0*0*0+9','10*0*0*0-0*0+0+0+9','10*0*0*0-0*0+0-0+9','10*0*0*0-0*0+0*0+9','10*0*0*0-0*0-0+0+9','10*0*0*0-0*0-0-0+9','10*0*0*0-0*0-0*0+9','10*0*0*0-0*0*0+0+9','10*0*0*0-0*0*0-0+9','10*0*0*0-0*0*0*0+9','10*0*0*0*0+0+0+0+9','10*0*0*0*0+0+0-0+9','10*0*0*0*0+0+0*0+9','10*0*0*0*0+0-0+0+9','10*0*0*0*0+0-0-0+9','10*0*0*0*0+0-0*0+9','10*0*0*0*0+0*0+0+9','10*0*0*0*0+0*0-0+9','10*0*0*0*0+0*0*0+9','10*0*0*0*0-0+0+0+9','10*0*0*0*0-0+0-0+9','10*0*0*0*0-0+0*0+9','10*0*0*0*0-0-0+0+9','10*0*0*0*0-0-0-0+9','10*0*0*0*0-0-0*0+9','10*0*0*0*0-0*0+0+9','10*0*0*0*0-0*0-0+9','10*0*0*0*0-0*0*0+9','10*0*0*0*0*0+0+0+9','10*0*0*0*0*0+0-0+9','10*0*0*0*0*0+0*0+9','10*0*0*0*0*0-0+0+9','10*0*0*0*0*0-0-0+9','10*0*0*0*0*0-0*0+9','10*0*0*0*0*0*0+0+9','10*0*0*0*0*0*0-0+9','10*0*0*0*0*0*0*0+9','100*0+0+0+0+0+0+9','100*0+0+0+0+0-0+9','100*0+0+0+0+0*0+9','100*0+0+0+0-0+0+9','100*0+0+0+0-0-0+9','100*0+0+0+0-0*0+9','100*0+0+0+0*0+0+9','100*0+0+0+0*0-0+9','100*0+0+0+0*0*0+9','100*0+0+0-0+0+0+9','100*0+0+0-0+0-0+9','100*0+0+0-0+0*0+9','100*0+0+0-0-0+0+9','100*0+0+0-0-0-0+9','100*0+0+0-0-0*0+9','100*0+0+0-0*0+0+9','100*0+0+0-0*0-0+9','100*0+0+0-0*0*0+9','100*0+0+0*0+0+0+9','100*0+0+0*0+0-0+9','100*0+0+0*0+0*0+9','100*0+0+0*0-0+0+9','100*0+0+0*0-0-0+9','100*0+0+0*0-0*0+9','100*0+0+0*0*0+0+9','100*0+0+0*0*0-0+9','100*0+0+0*0*0*0+9','100*0+0-0+0+0+0+9','100*0+0-0+0+0-0+9','100*0+0-0+0+0*0+9','100*0+0-0+0-0+0+9','100*0+0-0+0-0-0+9','100*0+0-0+0-0*0+9','100*0+0-0+0*0+0+9','100*0+0-0+0*0-0+9','100*0+0-0+0*0*0+9','100*0+0-0-0+0+0+9','100*0+0-0-0+0-0+9','100*0+0-0-0+0*0+9','100*0+0-0-0-0+0+9','100*0+0-0-0-0-0+9','100*0+0-0-0-0*0+9','100*0+0-0-0*0+0+9','100*0+0-0-0*0-0+9','100*0+0-0-0*0*0+9','100*0+0-0*0+0+0+9','100*0+0-0*0+0-0+9','100*0+0-0*0+0*0+9','100*0+0-0*0-0+0+9','100*0+0-0*0-0-0+9','100*0+0-0*0-0*0+9','100*0+0-0*0*0+0+9','100*0+0-0*0*0-0+9','100*0+0-0*0*0*0+9','100*0+0*0+0+0+0+9','100*0+0*0+0+0-0+9','100*0+0*0+0+0*0+9','100*0+0*0+0-0+0+9','100*0+0*0+0-0-0+9','100*0+0*0+0-0*0+9','100*0+0*0+0*0+0+9','100*0+0*0+0*0-0+9','100*0+0*0+0*0*0+9','100*0+0*0-0+0+0+9','100*0+0*0-0+0-0+9','100*0+0*0-0+0*0+9','100*0+0*0-0-0+0+9','100*0+0*0-0-0-0+9','100*0+0*0-0-0*0+9','100*0+0*0-0*0+0+9','100*0+0*0-0*0-0+9','100*0+0*0-0*0*0+9','100*0+0*0*0+0+0+9','100*0+0*0*0+0-0+9','100*0+0*0*0+0*0+9','100*0+0*0*0-0+0+9','100*0+0*0*0-0-0+9','100*0+0*0*0-0*0+9','100*0+0*0*0*0+0+9','100*0+0*0*0*0-0+9','100*0+0*0*0*0*0+9','100*0-0+0+0+0+0+9','100*0-0+0+0+0-0+9','100*0-0+0+0+0*0+9','100*0-0+0+0-0+0+9','100*0-0+0+0-0-0+9','100*0-0+0+0-0*0+9','100*0-0+0+0*0+0+9','100*0-0+0+0*0-0+9','100*0-0+0+0*0*0+9','100*0-0+0-0+0+0+9','100*0-0+0-0+0-0+9','100*0-0+0-0+0*0+9','100*0-0+0-0-0+0+9','100*0-0+0-0-0-0+9','100*0-0+0-0-0*0+9','100*0-0+0-0*0+0+9','100*0-0+0-0*0-0+9','100*0-0+0-0*0*0+9','100*0-0+0*0+0+0+9','100*0-0+0*0+0-0+9','100*0-0+0*0+0*0+9','100*0-0+0*0-0+0+9','100*0-0+0*0-0-0+9','100*0-0+0*0-0*0+9','100*0-0+0*0*0+0+9','100*0-0+0*0*0-0+9','100*0-0+0*0*0*0+9','100*0-0-0+0+0+0+9','100*0-0-0+0+0-0+9','100*0-0-0+0+0*0+9','100*0-0-0+0-0+0+9','100*0-0-0+0-0-0+9','100*0-0-0+0-0*0+9','100*0-0-0+0*0+0+9','100*0-0-0+0*0-0+9','100*0-0-0+0*0*0+9','100*0-0-0-0+0+0+9','100*0-0-0-0+0-0+9','100*0-0-0-0+0*0+9','100*0-0-0-0-0+0+9','100*0-0-0-0-0-0+9','100*0-0-0-0-0*0+9','100*0-0-0-0*0+0+9','100*0-0-0-0*0-0+9','100*0-0-0-0*0*0+9','100*0-0-0*0+0+0+9','100*0-0-0*0+0-0+9','100*0-0-0*0+0*0+9','100*0-0-0*0-0+0+9','100*0-0-0*0-0-0+9','100*0-0-0*0-0*0+9','100*0-0-0*0*0+0+9','100*0-0-0*0*0-0+9','100*0-0-0*0*0*0+9','100*0-0*0+0+0+0+9','100*0-0*0+0+0-0+9','100*0-0*0+0+0*0+9','100*0-0*0+0-0+0+9','100*0-0*0+0-0-0+9','100*0-0*0+0-0*0+9','100*0-0*0+0*0+0+9','100*0-0*0+0*0-0+9','100*0-0*0+0*0*0+9','100*0-0*0-0+0+0+9','100*0-0*0-0+0-0+9','100*0-0*0-0+0*0+9','100*0-0*0-0-0+0+9','100*0-0*0-0-0-0+9','100*0-0*0-0-0*0+9','100*0-0*0-0*0+0+9','100*0-0*0-0*0-0+9','100*0-0*0-0*0*0+9','100*0-0*0*0+0+0+9','100*0-0*0*0+0-0+9','100*0-0*0*0+0*0+9','100*0-0*0*0-0+0+9','100*0-0*0*0-0-0+9','100*0-0*0*0-0*0+9','100*0-0*0*0*0+0+9','100*0-0*0*0*0-0+9','100*0-0*0*0*0*0+9','100*0*0+0+0+0+0+9','100*0*0+0+0+0-0+9','100*0*0+0+0+0*0+9','100*0*0+0+0-0+0+9','100*0*0+0+0-0-0+9','100*0*0+0+0-0*0+9','100*0*0+0+0*0+0+9','100*0*0+0+0*0-0+9','100*0*0+0+0*0*0+9','100*0*0+0-0+0+0+9','100*0*0+0-0+0-0+9','100*0*0+0-0+0*0+9','100*0*0+0-0-0+0+9','100*0*0+0-0-0-0+9','100*0*0+0-0-0*0+9','100*0*0+0-0*0+0+9','100*0*0+0-0*0-0+9','100*0*0+0-0*0*0+9','100*0*0+0*0+0+0+9','100*0*0+0*0+0-0+9','100*0*0+0*0+0*0+9','100*0*0+0*0-0+0+9','100*0*0+0*0-0-0+9','100*0*0+0*0-0*0+9','100*0*0+0*0*0+0+9','100*0*0+0*0*0-0+9','100*0*0+0*0*0*0+9','100*0*0-0+0+0+0+9','100*0*0-0+0+0-0+9','100*0*0-0+0+0*0+9','100*0*0-0+0-0+0+9','100*0*0-0+0-0-0+9','100*0*0-0+0-0*0+9','100*0*0-0+0*0+0+9','100*0*0-0+0*0-0+9','100*0*0-0+0*0*0+9','100*0*0-0-0+0+0+9','100*0*0-0-0+0-0+9','100*0*0-0-0+0*0+9','100*0*0-0-0-0+0+9','100*0*0-0-0-0-0+9','100*0*0-0-0-0*0+9','100*0*0-0-0*0+0+9','100*0*0-0-0*0-0+9','100*0*0-0-0*0*0+9','100*0*0-0*0+0+0+9','100*0*0-0*0+0-0+9','100*0*0-0*0+0*0+9','100*0*0-0*0-0+0+9','100*0*0-0*0-0-0+9','100*0*0-0*0-0*0+9','100*0*0-0*0*0+0+9','100*0*0-0*0*0-0+9','100*0*0-0*0*0*0+9','100*0*0*0+0+0+0+9','100*0*0*0+0+0-0+9','100*0*0*0+0+0*0+9','100*0*0*0+0-0+0+9','100*0*0*0+0-0-0+9','100*0*0*0+0-0*0+9','100*0*0*0+0*0+0+9','100*0*0*0+0*0-0+9','100*0*0*0+0*0*0+9','100*0*0*0-0+0+0+9','100*0*0*0-0+0-0+9','100*0*0*0-0+0*0+9','100*0*0*0-0-0+0+9','100*0*0*0-0-0-0+9','100*0*0*0-0-0*0+9','100*0*0*0-0*0+0+9','100*0*0*0-0*0-0+9','100*0*0*0-0*0*0+9','100*0*0*0*0+0+0+9','100*0*0*0*0+0-0+9','100*0*0*0*0+0*0+9','100*0*0*0*0-0+0+9','100*0*0*0*0-0-0+9','100*0*0*0*0-0*0+9','100*0*0*0*0*0+0+9','100*0*0*0*0*0-0+9','100*0*0*0*0*0*0+9','1000*0+0+0+0+0+9','1000*0+0+0+0-0+9','1000*0+0+0+0*0+9','1000*0+0+0-0+0+9','1000*0+0+0-0-0+9','1000*0+0+0-0*0+9','1000*0+0+0*0+0+9','1000*0+0+0*0-0+9','1000*0+0+0*0*0+9','1000*0+0-0+0+0+9','1000*0+0-0+0-0+9','1000*0+0-0+0*0+9','1000*0+0-0-0+0+9','1000*0+0-0-0-0+9','1000*0+0-0-0*0+9','1000*0+0-0*0+0+9','1000*0+0-0*0-0+9','1000*0+0-0*0*0+9','1000*0+0*0+0+0+9','1000*0+0*0+0-0+9','1000*0+0*0+0*0+9','1000*0+0*0-0+0+9','1000*0+0*0-0-0+9','1000*0+0*0-0*0+9','1000*0+0*0*0+0+9','1000*0+0*0*0-0+9','1000*0+0*0*0*0+9','1000*0-0+0+0+0+9','1000*0-0+0+0-0+9','1000*0-0+0+0*0+9','1000*0-0+0-0+0+9','1000*0-0+0-0-0+9','1000*0-0+0-0*0+9','1000*0-0+0*0+0+9','1000*0-0+0*0-0+9','1000*0-0+0*0*0+9','1000*0-0-0+0+0+9','1000*0-0-0+0-0+9','1000*0-0-0+0*0+9','1000*0-0-0-0+0+9','1000*0-0-0-0-0+9','1000*0-0-0-0*0+9','1000*0-0-0*0+0+9','1000*0-0-0*0-0+9','1000*0-0-0*0*0+9','1000*0-0*0+0+0+9','1000*0-0*0+0-0+9','1000*0-0*0+0*0+9','1000*0-0*0-0+0+9','1000*0-0*0-0-0+9','1000*0-0*0-0*0+9','1000*0-0*0*0+0+9','1000*0-0*0*0-0+9','1000*0-0*0*0*0+9','1000*0*0+0+0+0+9','1000*0*0+0+0-0+9','1000*0*0+0+0*0+9','1000*0*0+0-0+0+9','1000*0*0+0-0-0+9','1000*0*0+0-0*0+9','1000*0*0+0*0+0+9','1000*0*0+0*0-0+9','1000*0*0+0*0*0+9','1000*0*0-0+0+0+9','1000*0*0-0+0-0+9','1000*0*0-0+0*0+9','1000*0*0-0-0+0+9','1000*0*0-0-0-0+9','1000*0*0-0-0*0+9','1000*0*0-0*0+0+9','1000*0*0-0*0-0+9','1000*0*0-0*0*0+9','1000*0*0*0+0+0+9','1000*0*0*0+0-0+9','1000*0*0*0+0*0+9','1000*0*0*0-0+0+9','1000*0*0*0-0-0+9','1000*0*0*0-0*0+9','1000*0*0*0*0+0+9','1000*0*0*0*0-0+9','1000*0*0*0*0*0+9','10000*0+0+0+0+9','10000*0+0+0-0+9','10000*0+0+0*0+9','10000*0+0-0+0+9','10000*0+0-0-0+9','10000*0+0-0*0+9','10000*0+0*0+0+9','10000*0+0*0-0+9','10000*0+0*0*0+9','10000*0-0+0+0+9','10000*0-0+0-0+9','10000*0-0+0*0+9','10000*0-0-0+0+9','10000*0-0-0-0+9','10000*0-0-0*0+9','10000*0-0*0+0+9','10000*0-0*0-0+9','10000*0-0*0*0+9','10000*0*0+0+0+9','10000*0*0+0-0+9','10000*0*0+0*0+9','10000*0*0-0+0+9','10000*0*0-0-0+9','10000*0*0-0*0+9','10000*0*0*0+0+9','10000*0*0*0-0+9','10000*0*0*0*0+9','100000*0+0+0+9','100000*0+0-0+9','100000*0+0*0+9','100000*0-0+0+9','100000*0-0-0+9','100000*0-0*0+9','100000*0*0+0+9','100000*0*0-0+9','100000*0*0*0+9','1000000*0+0+9','1000000*0-0+9','1000000*0*0+9','10000000*0+9']"
      },
      {
        "input": "\"2147483648\", -2147483648",
        "expected_output": "[]"
      },
      {
        "input": "\"999999999\", 999999999",
        "expected_output": "['999999999']"
      },
      {
        "input": "\"01\", 1",
        "expected_output": "['0+1']"
      },
      {
        "input": "\"1234\", 11",
        "expected_output": "['1+2*3+4','1-2+3*4','12+3-4']"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def addOperators(self, num: str, target: int) -> List[str]:\n        ",
      "java": "class Solution {\n    public List<String> addOperators(String num, int target) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    vector<string> addOperators(string num, int target) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return sorted(result) == sorted(eval(expected))",
      "java": "List<String> resultList = (List<String>) result;\nList<String> expectedList = (List<String>) expected;\nCollections.sort(resultList);\nCollections.sort(expectedList);\nreturn resultList.equals(expectedList);",
      "cpp": "if (!result.isArray() ||!expected.isArray() || result.size()!= expected.size()) {\n        return false;\n    }\n\n    std::vector<std::string> resultVec;\n    std::vector<std::string> expectedVec;\n\n    for (const auto& val: result) {\n        if (!val.isString()) return false;\n        resultVec.push_back(val.asString());\n    }\n\n    for (const auto& val: expected) {\n        if (!val.isString()) return false;\n        expectedVec.push_back(val.asString());\n    }\n\n    std::sort(resultVec.begin(), resultVec.end()); // Sort the result vector\n    std::sort(expectedVec.begin(), expectedVec.end()); // Sort the expected vector\n\n    return resultVec == expectedVec;"
    },
    "explanation": "https://www.youtube.com/watch?v=tunRDBsP7OQ&pp=ygUhTmVldENvZGUgRXhwcmVzc2lvbiBBZGQgT3BlcmF0b3Jz",
    "method_name": "addOperators"
  },
  {
    "title": "Remove Invalid Parentheses",
    "source": "https://leetcode.com/problems/remove-invalid-parentheses/",
    "description": "Solve the problem titled \"Remove Invalid Parentheses\". Provide a full implementation that addresses the unique constraints and requirements defined in that problem.",
    "difficulty": "hard",
    "sample_test_cases": [
      {
        "input": "\"()())()\"",
        "expected_output": "['(())()','()()()']"
      },
      {
        "input": "\"(a)())()\"",
        "expected_output": "['(a())()','(a)()()']"
      },
      {
        "input": "\")(\"",
        "expected_output": "['']"
      }
    ],
    "hidden_test_cases": [
      {
        "input": "\"()())()\"",
        "expected_output": "['(())()','()()()']"
      },
      {
        "input": "\"(a)())()\"",
        "expected_output": "['(a())()','(a)()()']"
      },
      {
        "input": "\")(\"",
        "expected_output": "['']"
      },
      {
        "input": "\"((()\"",
        "expected_output": "['()']"
      },
      {
        "input": "\")()\"",
        "expected_output": "['()']"
      },
      {
        "input": "\"(())())\"",
        "expected_output": "['(()())','(())()']"
      },
      {
        "input": "\"())()(((\"",
        "expected_output": "['()()']"
      },
      {
        "input": "\"(a)(b)(c))(\"",
        "expected_output": "['(a(b)(c))','(a)(b(c))','(a)(b)(c)']"
      },
      {
        "input": "\")()(\"",
        "expected_output": "['()']"
      },
      {
        "input": "\"((())\"",
        "expected_output": "['(())']"
      }
    ],
    "boilerplate": {
      "python": "class Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        ",
      "java": "class Solution {\n    public List<String> removeInvalidParentheses(String s) {\n        \n    }\n}",
      "cpp": "class Solution {\npublic:\n    vector<string> removeInvalidParentheses(string s) {\n        \n    }\n};"
    },
    "compare_func": {
      "python": "return sorted(result) == sorted(eval(expected))",
      "java": "List<String> resultList = (List<String>) result;\nList<String> expectedList = (List<String>) expected;\nCollections.sort(resultList);\nCollections.sort(expectedList);\nreturn resultList.equals(expectedList);",
      "cpp": "if (!result.isArray() ||!expected.isArray() || result.size()!= expected.size()) {\n        return false;\n    }\n\n    std::vector<std::string> resultVec;\n    std::vector<std::string> expectedVec;\n\n    for (const auto& val: result) {\n        if (!val.isString()) return false;\n        resultVec.push_back(val.asString());\n    }\n\n    for (const auto& val: expected) {\n        if (!val.isString()) return false;\n        expectedVec.push_back(val.asString());\n    }\n\n    std::sort(resultVec.begin(), resultVec.end()); // Sort the result vector\n    std::sort(expectedVec.begin(), expectedVec.end()); // Sort the expected vector\n\n    return resultVec == expectedVec;"
    },
    "explanation": "https://www.youtube.com/watch?v=mgQ4O9iUEbg&pp=ygUjTmVldENvZGUgUmVtb3ZlIEludmFsaWQgUGFyZW50aGVzZXM%3D",
    "method_name": "removeInvalidParentheses"
  }
]